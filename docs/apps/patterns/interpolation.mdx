---
title: Interpolation
description: Dynamic values in component props using {{ }} templates.
icon: wand-magic-sparkles
---

Every string prop on every component supports `{{ }}` template interpolation. When the renderer encounters `{{ key }}` in a string value, it replaces it with the current value of `key` from [state](/apps/components/state). No opt-in required — it works everywhere.

```python
from prefab_ui.components import Text

Text("Hello, {{ name }}!")
```

If `name` is `"Trillian"` in state, this renders as "Hello, Trillian!".

## Where Values Come From

Interpolation resolves values from three sources, in priority order:

1. **Local scope** — values provided by [State](/apps/components/state) or [ForEach](/apps/components/foreach) components
2. **Global state** — values from `AppResult(state={...})`, named form controls, or [SetState](/apps/actions/set-state) actions
3. **Action context** — `$event` (the triggering value) and `$error` (error messages), available only inside action specs

Named form controls sync to global state automatically. When a user types into `Input(name="city")`, the key `city` updates on every keystroke and any `{{ city }}` reference re-renders instantly.

## Dot Paths

Use dot notation to reach into nested objects:

```python
from prefab_ui.components import Text

# If state contains { "user": { "address": { "city": "Betelgeuse" } } }
Text("Located in {{ user.address.city }}")
```

## Format Specifiers

Add a pipe after the key to format the resolved value:

```python
from prefab_ui.components import Column, Text

with Column(gap=2):
    Text("{{ score | percent }}")       # 0.75 → "75%"
    Text("{{ score | percent:1 }}")     # 0.756 → "75.6%"
    Text("{{ price | number:2 }}")      # 1234 → "1,234.00"
    Text("{{ price | currency }}")      # 1234 → "$1,234.00"
    Text("{{ price | currency:EUR }}")  # 1234 → "€1,234.00"
    Text("{{ date | date }}")           # ISO string → "Jan 15, 2025"
    Text("{{ date | date:short }}")     # → "1/15/2025"
    Text("{{ date | date:long }}")      # → "January 15, 2025"
    Text("{{ date | time }}")           # → "2:30 PM"
    Text("{{ date | datetime }}")       # → "Jan 15, 2025, 2:30 PM"
    Text("{{ name | upper }}")          # "arthur" → "ARTHUR"
    Text("{{ name | lower }}")          # "ARTHUR" → "arthur"
```

## Type Preservation

When a template is the *entire* string value, the resolved type is preserved. This matters for props that expect numbers or booleans:

```python
from prefab_ui.components import Progress

# "{{ volume }}" resolves to the number 75, not the string "75"
Progress(value="{{ volume }}", max=100)
```

Mixed templates always produce strings: `"Volume: {{ volume }}%"` → `"Volume: 75%"`.

## Universal Coverage

Interpolation applies to any string in the component tree — labels, placeholders, values, CSS classes, URLs, titles, descriptions, action arguments. A few examples across different components:

```python
from prefab_ui.components import Button, Badge, Input, Image

Button("View {{ name }}'s profile")
Badge("{{ status }}", variant="{{ badge_variant }}")
Input(placeholder="Search {{ category }}...")
Image(src="{{ avatar_url }}", alt="{{ name }}")
```

## Scoping with State

The [State](/apps/components/state) component provides local interpolation values to a subtree. Inner values shadow outer ones, and children see the merged context:

```python
from prefab_ui.components import State, Text, Column

with Column():
    with State(greeting="Don't Panic", name="Arthur"):
        Text("{{ greeting }}, {{ name }}")
        with State(name="Ford"):
            Text("{{ greeting }}, {{ name }}")
```

The first `Text` renders "Don't Panic, Arthur". The second renders "Don't Panic, Ford" — the inner `State` shadows `name` but inherits `greeting`.

See the [State](/apps/components/state) and [ForEach](/apps/components/foreach) docs for more on scoping and iteration.
