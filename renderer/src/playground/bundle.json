{
  "prefab_ui/__init__.py": "\"\"\"Prefab — the agentic frontend framework that even a human can use.\n\nA JSON component format that renders to real interactive frontends.\nTransport-agnostic: works with MCP servers, REST APIs, or any backend\nthat can return JSON.\n\nUsage::\n\n    from prefab_ui.components import Column, Heading, Text\n    from prefab_ui.response import UIResponse\n\n    def show_user(name: str) -> UIResponse:\n        return UIResponse(\n            state={\"name\": name},\n            view=Column(Heading(\"{{ name }}\")),\n        )\n\nSubmodules:\n\n- ``prefab_ui.components`` — UI components (Button, Grid, Card, etc.)\n- ``prefab_ui.actions`` — state actions (SetState, AppendState, etc.)\n- ``prefab_ui.css`` — CSS helpers (Responsive, Hover, Md, etc.)\n- ``prefab_ui.response`` — UIResponse\n- ``prefab_ui.define`` — Define (reusable component definitions)\n- ``prefab_ui.use`` — Use (component instantiation)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport importlib.metadata\n\ntry:\n    __version__ = importlib.metadata.version(\"prefab-ui\")\nexcept importlib.metadata.PackageNotFoundError:\n    __version__ = \"0.0.0-dev\"\n",
  "prefab_ui/app.py": "\"\"\"PrefabApp — the central application object for Prefab.\n\nDescribes what to render, what state to initialize, and what external\nassets to load.  Pure data model — transport-agnostic.\n\nUsage::\n\n    from prefab_ui.app import PrefabApp\n    from prefab_ui.components import Column, Heading, DataTable\n\n    app = PrefabApp(\n        view=Column(Heading(\"Dashboard\"), DataTable(data=users)),\n        state={\"users\": users},\n    )\n\n    html = app.html()      # complete self-contained page\n    csp = app.csp()        # CSP domains for sandboxed delivery\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nfrom contextvars import ContextVar\nfrom typing import Any\n\nimport pydantic_core\nfrom pydantic import BaseModel, Field, model_validator\n\nfrom prefab_ui.renderer import _get_origin, get_renderer_csp, get_renderer_head\n\nPROTOCOL_VERSION = \"0.2\"\n\n# ── Initial State ─────────────────────────────────────────────────────\n\n_initial_state: ContextVar[dict[str, Any] | None] = ContextVar(\n    \"_initial_state\", default=None\n)\n\n\ndef set_initial_state(**kwargs: Any) -> None:\n    \"\"\"Declare initial client-side state for the current app.\n\n    Called alongside component construction to define the starting\n    values that templates like ``{{ name }}`` resolve against::\n\n        set_initial_state(name=\"world\")\n\n        with Card():\n            H3(\"Hello, {{ name }}!\")\n    \"\"\"\n    current = _initial_state.get()\n    if current is None:\n        current = {}\n        _initial_state.set(current)\n    current.update(kwargs)\n\n\ndef get_initial_state() -> dict[str, Any] | None:\n    \"\"\"Retrieve state set by :func:`set_initial_state`, or ``None``.\"\"\"\n    return _initial_state.get()\n\n\ndef clear_initial_state() -> None:\n    \"\"\"Reset the initial-state accumulator.\"\"\"\n    _initial_state.set(None)\n\n\n_PAGE_TEMPLATE = \"\"\"\\\n<!doctype html>\n<html lang=\"en\">\n<head>\n{head}\n</head>\n<body style=\"max-width:64rem;margin:0 auto;padding:2rem\">\n  <div id=\"root\"></div>\n  <script id=\"prefab:initial-data\" type=\"application/json\">{data}</script>\n</body>\n</html>\"\"\"\n\n\nclass PrefabApp(BaseModel):\n    \"\"\"A complete Prefab application.\n\n    Describes the view, initial state, reusable component definitions,\n    and external assets.  Use ``html()`` to produce a self-contained\n    HTML page, or ``to_json()`` for the wire-format envelope.\n    \"\"\"\n\n    view: Any | None = Field(default=None, description=\"Component tree to render\")\n    state: dict[str, Any] | None = Field(\n        default=None,\n        description=\"Initial client-side state\",\n    )\n    defs: list[Any] | None = Field(\n        default=None,\n        description=\"Reusable component definitions (Define instances)\",\n    )\n    stylesheets: list[str] | None = Field(\n        default=None,\n        description=\"External CSS URLs to load in <head>\",\n    )\n    scripts: list[str] | None = Field(\n        default=None,\n        description=\"External JS URLs to load in <head>\",\n    )\n    connect_domains: list[str] | None = Field(\n        default=None,\n        description=\"Domains to allow in CSP connect-src (for Fetch actions)\",\n    )\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    @model_validator(mode=\"after\")\n    def _consume_initial_state(self) -> PrefabApp:\n        accumulated = get_initial_state()\n        if accumulated:\n            clear_initial_state()\n            if self.state is None:\n                self.state = accumulated\n            else:\n                # Explicit state= wins; accumulated values fill in gaps\n                self.state = {**accumulated, **self.state}\n\n        if self.state is not None:\n            for key in self.state:\n                if key.startswith(\"$\"):\n                    raise ValueError(f\"State key {key!r} uses reserved prefix '$'\")\n        return self\n\n    def to_json(self) -> dict[str, Any]:\n        \"\"\"Produce the Prefab wire format.\n\n        Returns a dict with ``version``, ``view``, ``defs``, and ``state``\n        as top-level keys (omitting any that are None).\n        \"\"\"\n        result: dict[str, Any] = {\"version\": PROTOCOL_VERSION}\n\n        if self.view is not None:\n            result[\"view\"] = self.view.to_json()\n\n        if self.defs:\n            result[\"defs\"] = {d.name: d.to_json() for d in self.defs}\n\n        if self.state is not None:\n            result[\"state\"] = pydantic_core.to_jsonable_python(self.state)\n\n        return result\n\n    def html(self) -> str:\n        \"\"\"Produce a complete, self-contained HTML page.\n\n        The page includes the Prefab renderer (JS/CSS), any user-specified\n        stylesheets and scripts, and the application data baked in as a\n        JSON ``<script>`` tag.\n        \"\"\"\n        head_parts = [get_renderer_head()]\n\n        if self.stylesheets:\n            for url in self.stylesheets:\n                head_parts.append(f'  <link rel=\"stylesheet\" href=\"{url}\">')\n\n        if self.scripts:\n            for url in self.scripts:\n                head_parts.append(f'  <script src=\"{url}\"></script>')\n\n        data_json = json.dumps(self.to_json(), separators=(\",\", \":\"))\n        # Escape </ to prevent premature closing of the script tag\n        safe_json = data_json.replace(\"</\", r\"<\\/\")\n\n        return _PAGE_TEMPLATE.format(\n            head=\"\\n\".join(head_parts),\n            data=safe_json,\n        )\n\n    def csp(self) -> dict[str, list[str]]:\n        \"\"\"Compute CSP domains from the app's asset configuration.\n\n        Merges the renderer's base CSP with origins extracted from\n        ``stylesheets``, ``scripts``, and ``connect_domains``.\n        \"\"\"\n        result = get_renderer_csp()\n\n        if self.connect_domains:\n            result[\"connect_domains\"] = list(self.connect_domains)\n\n        if self.stylesheets:\n            origins = sorted({_get_origin(url) for url in self.stylesheets})\n            result[\"style_domains\"] = origins\n\n        if self.scripts:\n            origins = sorted({_get_origin(url) for url in self.scripts})\n            result[\"script_domains\"] = origins\n\n        return result\n",
  "prefab_ui/css.py": "\"\"\"CSS utilities for Tailwind class composition.\n\nHelpers for building css_class values without repeating variant prefixes.\n\nPseudo-state helpers prefix each space-separated class::\n\n    from prefab_ui.css import Hover, FocusVisible\n\n    css_class=[\"p-4 border-0\", Hover(\"bg-blue-500 scale-105\")]\n    # → \"p-4 border-0 hover:bg-blue-500 hover:scale-105\"\n\n    css_class=[\"ring-0 border-0\", FocusVisible(\"border-b border-border\")]\n    # → \"ring-0 border-0 focus-visible:border-b focus-visible:border-border\"\n\nResponsive maps Tailwind breakpoints to values::\n\n    from prefab_ui.css import Responsive\n\n    Grid(columns=Responsive(default=1, md=2, lg=3))\n    Button(\"Go\", css_class=Responsive(default=\"w-full\", md=\"w-auto\"))\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\n# ── Responsive ─────────────────────────────────────────────────────────\n\n_BREAKPOINTS = (\"default\", \"sm\", \"md\", \"lg\", \"xl\", \"2xl\")\n\n_BreakpointFormatter = Any  # Callable[[Any], str] — avoid import complexity\n\n\nclass Responsive:\n    \"\"\"Breakpoint-aware values for responsive layouts.\n\n    Maps Tailwind breakpoints to values. At compile time, each entry is\n    prefixed with its breakpoint (``default`` emits unprefixed classes).\n\n    Usage::\n\n        Grid(columns=Responsive(default=1, md=2, lg=3))\n        Row(gap=Responsive(default=2, md=4))\n        Button(\"Go\", css_class=Responsive(default=\"w-full\", md=\"w-auto\"))\n    \"\"\"\n\n    __slots__ = (\"_values\",)\n\n    def __init__(self, **kwargs: Any) -> None:\n        invalid = set(kwargs) - set(_BREAKPOINTS)\n        if invalid:\n            raise ValueError(\n                f\"Invalid breakpoint(s): {', '.join(sorted(invalid))}. \"\n                f\"Valid breakpoints: {', '.join(_BREAKPOINTS)}\"\n            )\n        if not kwargs:\n            raise ValueError(\"Responsive() requires at least one breakpoint value\")\n        self._values: dict[str, Any] = kwargs\n\n    def __repr__(self) -> str:\n        inner = \", \".join(f\"{k}={v!r}\" for k, v in self._values.items())\n        return f\"Responsive({inner})\"\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, Responsive):\n            return self._values == other._values\n        return NotImplemented\n\n    @property\n    def values(self) -> dict[str, Any]:\n        return dict(self._values)\n\n    def compile_css(self, formatter: _BreakpointFormatter) -> str:\n        \"\"\"Compile to a space-separated Tailwind class string.\n\n        The *formatter* is called once per breakpoint entry and should\n        return one or more CSS utility classes for the given value.\n        \"\"\"\n        parts: list[str] = []\n        for bp in _BREAKPOINTS:\n            if bp not in self._values:\n                continue\n            classes = formatter(self._values[bp])\n            if not classes:\n                continue\n            if bp == \"default\":\n                parts.append(classes)\n            else:\n                for cls in classes.split():\n                    parts.append(f\"{bp}:{cls}\")\n        return \" \".join(parts)\n\n\n# ── Variant helpers ───────────────────────────────────────────────────\n\n\ndef _prefixed(prefix: str, classes: str) -> str:\n    \"\"\"Prefix each space-separated class with a Tailwind variant.\"\"\"\n    return \" \".join(f\"{prefix}:{cls}\" for cls in classes.split())\n\n\ndef Hover(classes: str) -> str:\n    \"\"\"Prefix classes with ``hover:``.\n\n    Example::\n\n        css_class=[\"p-4\", Hover(\"bg-blue-500 scale-105\")]\n        # → \"p-4 hover:bg-blue-500 hover:scale-105\"\n    \"\"\"\n    return _prefixed(\"hover\", classes)\n\n\ndef Focus(classes: str) -> str:\n    \"\"\"Prefix classes with ``focus:``.\"\"\"\n    return _prefixed(\"focus\", classes)\n\n\ndef FocusVisible(classes: str) -> str:\n    \"\"\"Prefix classes with ``focus-visible:``.\"\"\"\n    return _prefixed(\"focus-visible\", classes)\n\n\ndef FocusWithin(classes: str) -> str:\n    \"\"\"Prefix classes with ``focus-within:``.\"\"\"\n    return _prefixed(\"focus-within\", classes)\n\n\ndef Active(classes: str) -> str:\n    \"\"\"Prefix classes with ``active:``.\"\"\"\n    return _prefixed(\"active\", classes)\n\n\ndef Disabled(classes: str) -> str:\n    \"\"\"Prefix classes with ``disabled:``.\"\"\"\n    return _prefixed(\"disabled\", classes)\n\n\n# ── Breakpoint helpers ────────────────────────────────────────────────\n\n\ndef Sm(classes: str) -> str:\n    \"\"\"Prefix classes with ``sm:`` (≥640px).\"\"\"\n    return _prefixed(\"sm\", classes)\n\n\ndef Md(classes: str) -> str:\n    \"\"\"Prefix classes with ``md:`` (≥768px).\"\"\"\n    return _prefixed(\"md\", classes)\n\n\ndef Lg(classes: str) -> str:\n    \"\"\"Prefix classes with ``lg:`` (≥1024px).\"\"\"\n    return _prefixed(\"lg\", classes)\n\n\ndef Xl(classes: str) -> str:\n    \"\"\"Prefix classes with ``xl:`` (≥1280px).\"\"\"\n    return _prefixed(\"xl\", classes)\n\n\ndef Xxl(classes: str) -> str:\n    \"\"\"Prefix classes with ``2xl:`` (≥1536px).\"\"\"\n    return _prefixed(\"2xl\", classes)\n",
  "prefab_ui/define.py": "\"\"\"Define — named reusable component templates.\n\nA ``Define`` captures a component subtree as a named template that can be\nreferenced with :class:`~prefab_ui.use.Use`. Definitions live outside the\ncomponent tree and are passed to :class:`~prefab_ui.app.PrefabApp`\nvia the ``defs`` parameter.\n\nExample::\n\n    from prefab_ui.define import Define\n    from prefab_ui.use import Use\n    from prefab_ui.app import PrefabApp\n    from prefab_ui.components import Card, Column, Heading, Badge\n\n    with Define(\"user-card\") as user_card:\n        with Card():\n            Heading(\"{{ name }}\")\n            Badge(\"{{ role }}\")\n\n    with Column() as layout:\n        Use(\"user-card\", name=\"Alice\", role=\"Engineer\")\n        Use(\"user-card\", name=\"Bob\", role=\"Designer\")\n\n    PrefabApp(view=layout, defs=[user_card])\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Define(ContainerComponent):\n    \"\"\"Create a named, reusable component template.\n\n    Define captures children via the context manager but does **not**\n    attach itself to any parent container. Pass Define instances to\n    ``PrefabApp(defs=[...])`` to include them in the wire format.\n\n    Args:\n        name: Template name, referenced by :class:`~prefab_ui.use.Use`.\n    \"\"\"\n\n    type: Literal[\"Define\"] = \"Define\"\n    name: str = Field(description=\"Template name for $ref lookup\")\n\n    def model_post_init(self, __context: Any) -> None:\n        # Skip auto-append — Define lives outside the component tree.\n        pass\n\n    def __init__(self, name: str, /, **kwargs: Any) -> None:\n        kwargs[\"name\"] = name\n        super().__init__(**kwargs)\n\n    def to_json(self) -> dict[str, Any]:\n        \"\"\"Return the template body, not a Define wrapper.\n\n        Single child returns that child's JSON directly. Multiple\n        children are wrapped in an implicit Column.\n        \"\"\"\n        if len(self.children) == 1:\n            return self.children[0].to_json()\n        return {\n            \"type\": \"Column\",\n            \"children\": [c.to_json() for c in self.children],\n        }\n",
  "prefab_ui/testing.py": "\"\"\"Headless Prefab simulator for integration testing.\n\nSimulates the renderer's client-side behavior (state management, action\ndispatch, template interpolation) without a browser. Lets you invoke server\nfunctions, inspect state, find components in the view tree, and trigger\nactions.\n\nUsage::\n\n    from prefab_ui.testing import ActionResult, Simulator\n\n    async def handler(name: str, arguments: dict) -> ActionResult:\n        if name == \"search_users\":\n            return ActionResult(content={\"users\": [{\"name\": \"Alice\"}]})\n        return ActionResult(content={})\n\n    sim = Simulator(handler)\n\n    await sim.invoke(\"search_users\", {\"q\": \"Alice\"})\n    assert sim.state[\"users\"][0][\"name\"] == \"Alice\"\n\n    button = sim.find(\"Button\", label=\"Search\")\n    await sim.click(button)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom dataclasses import dataclass, field\nfrom typing import Any, Protocol, runtime_checkable\n\nTEMPLATE_RE = re.compile(r\"\\{\\{\\s*([\\w.$]+)\\s*\\}\\}\")\nMAX_ACTION_DEPTH = 10\n\n\n@dataclass\nclass ActionResult:\n    \"\"\"Result of a server-side action invocation.\"\"\"\n\n    content: dict[str, Any] = field(default_factory=dict)\n    is_error: bool = False\n    error_text: str | None = None\n\n\n@runtime_checkable\nclass ActionHandler(Protocol):\n    \"\"\"Protocol for handling server-bound actions.\"\"\"\n\n    async def __call__(self, name: str, arguments: dict[str, Any]) -> ActionResult: ...\n\n\nclass ComponentNotFoundError(LookupError):\n    \"\"\"Raised when a component cannot be found in the view tree.\"\"\"\n\n\nclass Simulator:\n    \"\"\"Headless Prefab renderer for testing.\n\n    Maintains client-side state and a view tree, simulates user\n    interactions by executing action chains through a handler.\n    \"\"\"\n\n    def __init__(self, handler: ActionHandler) -> None:\n        self.handler = handler\n        self.state: dict[str, Any] = {}\n        self.view: dict[str, Any] | None = None\n        self.toasts: list[dict[str, Any]] = []\n\n    # ── Server invocations ────────────────────────────────────────\n\n    async def invoke(self, name: str, arguments: dict[str, Any] | None = None) -> None:\n        \"\"\"Invoke a named server function and update state + view from the result.\"\"\"\n        result = await self.handler(name, arguments or {})\n        if result.is_error:\n            return\n        if result.content:\n            self._handle_structured_content(result.content)\n\n    # ── Component finding ────────────────────────────────────────\n\n    def find(self, type: str, **props: Any) -> dict[str, Any]:\n        \"\"\"Find the first component matching type and optional props.\n\n        Raises ComponentNotFoundError if no match is found.\n        \"\"\"\n        if self.view is None:\n            raise ComponentNotFoundError(\"No view tree — invoke a function first\")\n        result = self._find_recursive(self.view, type, props)\n        if result is None:\n            prop_desc = f\" with {props}\" if props else \"\"\n            raise ComponentNotFoundError(f\"{type}{prop_desc} not found in view tree\")\n        return result\n\n    def find_all(self, type: str, **props: Any) -> list[dict[str, Any]]:\n        \"\"\"Find all components matching type and optional props.\"\"\"\n        if self.view is None:\n            return []\n        results: list[dict[str, Any]] = []\n        self._find_all_recursive(self.view, type, props, results)\n        return results\n\n    # ── Interaction simulation ───────────────────────────────────\n\n    async def click(self, component: dict[str, Any]) -> None:\n        \"\"\"Simulate clicking a component (executes its onClick action).\"\"\"\n        action = component.get(\"onClick\")\n        if action is None:\n            raise ValueError(\n                f\"Component {component.get('type', '?')} has no onClick handler\"\n            )\n        await self._execute_actions(action)\n\n    async def set_value(self, component: dict[str, Any], value: Any) -> None:\n        \"\"\"Simulate changing a form input's value.\n\n        Sets auto-state for named components, then executes onChange.\n        \"\"\"\n        name = component.get(\"name\")\n        if name:\n            self.state[name] = value\n\n        action = component.get(\"onChange\")\n        if action:\n            await self._execute_actions(action, event=value)\n\n    async def submit(self, component: dict[str, Any]) -> None:\n        \"\"\"Simulate submitting a form (executes its onSubmit action).\"\"\"\n        action = component.get(\"onSubmit\")\n        if action is None:\n            raise ValueError(\n                f\"Component {component.get('type', '?')} has no onSubmit handler\"\n            )\n        await self._execute_actions(action)\n\n    # ── Action execution ─────────────────────────────────────────\n\n    async def _execute_actions(\n        self,\n        actions: dict[str, Any] | list[dict[str, Any]],\n        event: Any = None,\n        depth: int = 0,\n        error: str | None = None,\n    ) -> None:\n        \"\"\"Execute one or more actions sequentially with short-circuit.\"\"\"\n        action_list = actions if isinstance(actions, list) else [actions]\n        for action in action_list:\n            success = await self._execute_action(action, event, depth, error)\n            if not success:\n                break\n\n    async def _execute_action(\n        self,\n        action: dict[str, Any],\n        event: Any = None,\n        depth: int = 0,\n        error: str | None = None,\n    ) -> bool:\n        \"\"\"Execute a single action. Returns True on success.\"\"\"\n        if depth > MAX_ACTION_DEPTH:\n            return False\n\n        resolved = self._interpolate_dict(action, event, error)\n        success = True\n        error_message: str | None = None\n\n        action_type = resolved.get(\"action\")\n\n        if action_type == \"toolCall\":\n            tool_name = resolved[\"tool\"]\n            arguments = resolved.get(\"arguments\", {})\n            result = await self.handler(tool_name, arguments)\n\n            if result.is_error:\n                success = False\n                error_message = result.error_text or \"Unknown error\"\n            else:\n                result_key = resolved.get(\"resultKey\")\n                if result_key and result.content:\n                    data = self._extract_result_data(result.content)\n                    self.state[result_key] = data\n\n                if result.content:\n                    view = result.content.get(\"view\")\n                    if view:\n                        self.view = view\n\n        elif action_type == \"setState\":\n            self.state[resolved[\"key\"]] = resolved.get(\"value\")\n\n        elif action_type == \"toggleState\":\n            key = resolved[\"key\"]\n            self.state[key] = not self.state.get(key, False)\n\n        elif action_type == \"showToast\":\n            self.toasts.append(\n                {\n                    \"message\": resolved.get(\"message\"),\n                    \"variant\": resolved.get(\"variant\"),\n                    \"description\": resolved.get(\"description\"),\n                }\n            )\n\n        elif action_type in (\"sendMessage\", \"updateContext\", \"openLink\"):\n            pass  # Cannot simulate host interaction\n\n        # Dispatch lifecycle callbacks\n        if success:\n            callbacks = resolved.get(\"onSuccess\")\n            if callbacks:\n                await self._execute_actions(callbacks, depth=depth + 1)\n        else:\n            callbacks = resolved.get(\"onError\")\n            if callbacks:\n                await self._execute_actions(\n                    callbacks, depth=depth + 1, error=error_message\n                )\n\n        return success\n\n    # ── Interpolation ────────────────────────────────────────────\n\n    def _interpolate_dict(\n        self,\n        obj: dict[str, Any],\n        event: Any = None,\n        error: str | None = None,\n    ) -> dict[str, Any]:\n        \"\"\"Interpolate {{ key }} templates in a dict's values.\"\"\"\n        ctx = {**self.state}\n        if event is not None:\n            ctx[\"$event\"] = event\n        if error is not None:\n            ctx[\"$error\"] = error\n        return self._interpolate_value(obj, ctx)\n\n    def _interpolate_value(self, value: Any, ctx: dict[str, Any]) -> Any:\n        if isinstance(value, str):\n            return self._interpolate_string(value, ctx)\n        if isinstance(value, dict):\n            return {k: self._interpolate_value(v, ctx) for k, v in value.items()}\n        if isinstance(value, list):\n            return [self._interpolate_value(item, ctx) for item in value]\n        return value\n\n    def _interpolate_string(self, template: str, ctx: dict[str, Any]) -> Any:\n        \"\"\"Resolve {{ key }} templates. Preserves type for sole templates.\"\"\"\n        single = re.fullmatch(r\"\\{\\{\\s*([\\w.$]+)\\s*\\}\\}\", template)\n        if single:\n            resolved = self._resolve_path(single.group(1), ctx)\n            return resolved if resolved is not None else template\n\n        def replace(m: re.Match[str]) -> str:\n            resolved = self._resolve_path(m.group(1), ctx)\n            return str(resolved) if resolved is not None else \"\"\n\n        return TEMPLATE_RE.sub(replace, template)\n\n    @staticmethod\n    def _resolve_path(path: str, ctx: dict[str, Any]) -> Any:\n        \"\"\"Resolve a dot-path like 'user.name' from a context dict.\"\"\"\n        parts = path.split(\".\")\n        current: Any = ctx\n        for part in parts:\n            if current is None or not isinstance(current, dict):\n                return None\n            current = current.get(part)\n        return current\n\n    # ── Helpers ──────────────────────────────────────────────────\n\n    def _handle_structured_content(self, structured: dict[str, Any]) -> None:\n        \"\"\"Extract state and view from structured content.\"\"\"\n        view = structured.get(\"view\")\n        state = structured.get(\"state\", {})\n        self.state = state\n        if view:\n            self.view = view\n\n    @staticmethod\n    def _extract_result_data(structured: dict[str, Any]) -> Any:\n        \"\"\"Read state from envelope and unwrap single-value results.\"\"\"\n        state = structured.get(\"state\", {})\n        if not state:\n            return None\n        if len(state) == 1:\n            return next(iter(state.values()))\n        return state\n\n    def _find_recursive(\n        self,\n        node: dict[str, Any],\n        type: str,\n        props: dict[str, Any],\n    ) -> dict[str, Any] | None:\n        if node.get(\"type\") == type and all(node.get(k) == v for k, v in props.items()):\n            return node\n        for child in node.get(\"children\", []):\n            result = self._find_recursive(child, type, props)\n            if result is not None:\n                return result\n        return None\n\n    def _find_all_recursive(\n        self,\n        node: dict[str, Any],\n        type: str,\n        props: dict[str, Any],\n        results: list[dict[str, Any]],\n    ) -> None:\n        if node.get(\"type\") == type and all(node.get(k) == v for k, v in props.items()):\n            results.append(node)\n        for child in node.get(\"children\", []):\n            self._find_all_recursive(child, type, props, results)\n",
  "prefab_ui/use.py": "\"\"\"Use — reference a defined component template.\n\nA ``Use`` node references a :class:`~prefab_ui.define.Define` template by\nname. On the wire it desugars to ``{\"$ref\": \"name\"}``, with optional ``let``\nbindings for scoped overrides and ``cssClass`` for styling.\n\nExample::\n\n    from prefab_ui.define import Define\n    from prefab_ui.use import Use\n    from prefab_ui.components import Card, Column, Heading, Badge\n\n    with Define(\"user-card\") as user_card:\n        with Card():\n            Heading(\"{{ name }}\")\n            Badge(\"{{ role }}\")\n\n    with Column() as layout:\n        Use(\"user-card\", name=\"Alice\", role=\"Engineer\")\n        Use(\"user-card\", name=\"Bob\", role=\"Designer\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\n\n# Component base fields that should NOT be treated as state overrides.\n_BASE_FIELDS = frozenset(Component.model_fields)\n\n\nclass Use(Component):\n    \"\"\"Reference a defined component template by name.\n\n    Kwargs that aren't base component fields (``css_class``)\n    become scoped ``let`` bindings on the ``$ref`` node.\n\n    Args:\n        name: The template name (must match a ``Define`` name).\n        **kwargs: Scoped bindings and/or base component fields.\n    \"\"\"\n\n    # Use has a type field for Pydantic, but to_json() never emits it.\n    type: str = \"Use\"\n    name: str = Field(description=\"Template name to reference\")\n    overrides: dict[str, Any] = Field(default_factory=dict)\n\n    def __init__(self, name: str, /, **kwargs: Any) -> None:\n        init_kwargs: dict[str, Any] = {}\n        override_kwargs: dict[str, Any] = {}\n        for k, v in kwargs.items():\n            if k in _BASE_FIELDS:\n                init_kwargs[k] = v\n            else:\n                override_kwargs[k] = v\n        init_kwargs[\"name\"] = name\n        init_kwargs[\"overrides\"] = override_kwargs\n        super().__init__(**init_kwargs)\n\n    def to_json(self) -> dict[str, Any]:\n        \"\"\"Desugar to ``$ref`` with optional ``let`` and ``cssClass``.\"\"\"\n        ref: dict[str, Any] = {\"$ref\": self.name}\n\n        if self.overrides:\n            ref[\"let\"] = self.overrides\n        if self.css_class:\n            ref[\"cssClass\"] = self.css_class\n\n        return ref\n",
  "prefab_ui/components/__init__.py": "\"\"\"Prefab component library.\n\nAll components — structural, styled, and control-flow — are importable\nfrom this single package::\n\n    from prefab_ui.components import Card, Badge, H1, Grid, ForEach\n\"\"\"\n\nfrom prefab_ui.components.alert import Alert, AlertDescription, AlertTitle\nfrom prefab_ui.components.badge import Badge\nfrom prefab_ui.components.base import (\n    Component,\n    ContainerComponent,\n)\nfrom prefab_ui.components.button import Button\nfrom prefab_ui.components.calendar import Calendar\nfrom prefab_ui.components.chart import (\n    AreaChart,\n    BarChart,\n    ChartSeries,\n    LineChart,\n    PieChart,\n    RadarChart,\n    RadialChart,\n)\nfrom prefab_ui.components.button_group import ButtonGroup\nfrom prefab_ui.components.card import (\n    Card,\n    CardContent,\n    CardDescription,\n    CardFooter,\n    CardHeader,\n    CardTitle,\n)\nfrom prefab_ui.components.checkbox import Checkbox\nfrom prefab_ui.components.combobox import Combobox, ComboboxOption\nfrom prefab_ui.components.code import Code\nfrom prefab_ui.components.conditional import Elif, Else, If\nfrom prefab_ui.components.column import Column\nfrom prefab_ui.components.container import Container\nfrom prefab_ui.components.data_table import DataTable, DataTableColumn\nfrom prefab_ui.components.date_picker import DatePicker\nfrom prefab_ui.components.dialog import Dialog\nfrom prefab_ui.components.div import Div, Span\nfrom prefab_ui.components.accordion import Accordion, AccordionItem\nfrom prefab_ui.components.field import Field\nfrom prefab_ui.components.foreach import ForEach\nfrom prefab_ui.components.form import Form\nfrom prefab_ui.components.grid import Grid\nfrom prefab_ui.components.heading import Heading\nfrom prefab_ui.components.icon import Icon\nfrom prefab_ui.components.image import Image\nfrom prefab_ui.components.input import Input\nfrom prefab_ui.components.label import Label\nfrom prefab_ui.components.markdown import Markdown\nfrom prefab_ui.components.pages import Page, Pages\nfrom prefab_ui.components.popover import Popover\nfrom prefab_ui.components.progress import Progress\nfrom prefab_ui.components.radio import Radio, RadioGroup\nfrom prefab_ui.components.row import Row\nfrom prefab_ui.components.select import Select, SelectOption\nfrom prefab_ui.components.separator import Separator\nfrom prefab_ui.components.slot import Slot\nfrom prefab_ui.components.slider import Slider\nfrom prefab_ui.components.spinner import Spinner\nfrom prefab_ui.components.switch import Switch\nfrom prefab_ui.components.tabs import Tab, Tabs\nfrom prefab_ui.components.tooltip import Tooltip\nfrom prefab_ui.components.table import (\n    Table,\n    TableBody,\n    TableCaption,\n    TableCell,\n    TableFooter,\n    TableHead,\n    TableHeader,\n    TableRow,\n)\nfrom prefab_ui.components.text import Text\nfrom prefab_ui.components.textarea import Textarea\nfrom prefab_ui.components.typography import (\n    H1,\n    H2,\n    H3,\n    H4,\n    BlockQuote,\n    InlineCode,\n    Large,\n    Lead,\n    Muted,\n    P,\n    Small,\n)\n\n__all__ = [\n    \"H1\",\n    \"H2\",\n    \"H3\",\n    \"H4\",\n    \"Accordion\",\n    \"AccordionItem\",\n    \"Alert\",\n    \"AlertDescription\",\n    \"AlertTitle\",\n    \"AreaChart\",\n    \"Badge\",\n    \"BarChart\",\n    \"BlockQuote\",\n    \"Button\",\n    \"ButtonGroup\",\n    \"Calendar\",\n    \"Card\",\n    \"CardContent\",\n    \"CardDescription\",\n    \"CardFooter\",\n    \"CardHeader\",\n    \"CardTitle\",\n    \"ChartSeries\",\n    \"Checkbox\",\n    \"Code\",\n    \"Column\",\n    \"Combobox\",\n    \"ComboboxOption\",\n    \"Component\",\n    \"Container\",\n    \"ContainerComponent\",\n    \"DataTable\",\n    \"DataTableColumn\",\n    \"DatePicker\",\n    \"Dialog\",\n    \"Div\",\n    \"Elif\",\n    \"Else\",\n    \"Field\",\n    \"ForEach\",\n    \"Form\",\n    \"Grid\",\n    \"Heading\",\n    \"Icon\",\n    \"If\",\n    \"Image\",\n    \"InlineCode\",\n    \"Input\",\n    \"Label\",\n    \"Large\",\n    \"Lead\",\n    \"LineChart\",\n    \"Markdown\",\n    \"Muted\",\n    \"P\",\n    \"Page\",\n    \"Pages\",\n    \"PieChart\",\n    \"Popover\",\n    \"Progress\",\n    \"RadarChart\",\n    \"RadialChart\",\n    \"Radio\",\n    \"RadioGroup\",\n    \"Row\",\n    \"Select\",\n    \"SelectOption\",\n    \"Separator\",\n    \"Slider\",\n    \"Slot\",\n    \"Small\",\n    \"Span\",\n    \"Spinner\",\n    \"Switch\",\n    \"Tab\",\n    \"Table\",\n    \"TableBody\",\n    \"TableCaption\",\n    \"TableCell\",\n    \"TableFooter\",\n    \"TableHead\",\n    \"TableHeader\",\n    \"TableRow\",\n    \"Tabs\",\n    \"Text\",\n    \"Textarea\",\n    \"Tooltip\",\n]\n",
  "prefab_ui/components/accordion.py": "\"\"\"Accordion component for collapsible content sections.\n\nExample::\n\n    from prefab_ui.components import Accordion, AccordionItem, Text\n\n    with Accordion(default_open_items=0):\n        with AccordionItem(\"Getting Started\"):\n            Text(\"Install with pip install fastmcp\")\n        with AccordionItem(\"Configuration\"):\n            Text(\"Edit config.toml to customize settings.\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass AccordionItem(ContainerComponent):\n    \"\"\"A single collapsible section within an Accordion.\n\n    The ``title`` appears in the trigger; children are revealed on expand.\n\n    Example::\n\n        with AccordionItem(\"Details\"):\n            Text(\"Hidden content revealed on click.\")\n    \"\"\"\n\n    type: Literal[\"AccordionItem\"] = \"AccordionItem\"\n    title: str = Field(description=\"Accordion trigger label\")\n    value: str | None = Field(\n        default=None,\n        description=\"Unique value (defaults to title)\",\n    )\n\n    @overload\n    def __init__(self, title: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, title: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, title: str | None = None, **kwargs: Any) -> None:\n        if title is not None and \"title\" not in kwargs:\n            kwargs[\"title\"] = title\n        super().__init__(**kwargs)\n\n\nclass Accordion(ContainerComponent):\n    \"\"\"Accordion container — children must be ``AccordionItem`` components.\n\n    Example::\n\n        with Accordion(multiple=True, default_open_items=[0, 1]):\n            with AccordionItem(\"Section 1\"):\n                Text(\"Content 1\")\n            with AccordionItem(\"Section 2\"):\n                Text(\"Content 2\")\n    \"\"\"\n\n    type: Literal[\"Accordion\"] = \"Accordion\"\n    multiple: bool = Field(\n        default=False,\n        description=\"Allow multiple items to be open simultaneously\",\n    )\n    collapsible: bool = Field(\n        default=True,\n        description=\"Whether items can be fully collapsed (single mode)\",\n    )\n    default_open_items: int | str | list[int | str] | None = Field(\n        default=None,\n        exclude=True,\n        description=(\n            \"Initially expanded item(s). Pass an int for index-based \"\n            \"selection, or a str to match by value/title.\"\n        ),\n    )\n    default_values: list[str] | None = Field(\n        default=None,\n        alias=\"defaultValues\",\n        description=\"Wire format for default_open_items (always an array).\",\n    )\n\n    def _resolve_item(self, item: int | str) -> str:\n        if isinstance(item, int):\n            child = self.children[item]\n            if not isinstance(child, AccordionItem):\n                raise TypeError(\n                    f\"Child at index {item} is {type(child).__name__}, \"\n                    f\"not AccordionItem\"\n                )\n            return child.value or child.title\n        return item\n\n    def to_json(self) -> dict[str, Any]:\n        if self.default_open_items is not None and self.default_values is None:\n            items = (\n                self.default_open_items\n                if isinstance(self.default_open_items, list)\n                else [self.default_open_items]\n            )\n            self.default_values = [self._resolve_item(i) for i in items]\n        return super().to_json()\n",
  "prefab_ui/components/alert.py": "\"\"\"Alert components following shadcn/ui conventions.\n\nAlerts display important messages to users.\n\nExample::\n\n    from prefab_ui.components import Alert, AlertTitle, AlertDescription\n\n    # Default alert\n    with Alert():\n        AlertTitle(\"Heads up!\")\n        AlertDescription(\"You can add components to your app using the CLI.\")\n\n    # Destructive alert for errors\n    with Alert(variant=\"destructive\"):\n        AlertTitle(\"Error\")\n        AlertDescription(\"Your session has expired. Please log in again.\")\n\n    # Simple alert without title\n    with Alert():\n        AlertDescription(\"Your changes have been saved.\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component, ContainerComponent\n\nAlertVariant = Literal[\"default\", \"destructive\", \"success\", \"warning\", \"info\"]\n\n\nclass Alert(ContainerComponent):\n    \"\"\"An alert container for important messages.\n\n    Args:\n        variant: Visual style - \"default\", \"destructive\"\n        css_class: Additional CSS classes to apply\n\n    Example::\n\n        with Alert():\n            AlertTitle(\"Note\")\n            AlertDescription(\"This is an informational message.\")\n\n        with Alert(variant=\"destructive\"):\n            AlertTitle(\"Error\")\n            AlertDescription(\"Something went wrong.\")\n    \"\"\"\n\n    type: Literal[\"Alert\"] = \"Alert\"\n    variant: AlertVariant = Field(\n        default=\"default\",\n        description=\"Visual variant: default or destructive\",\n    )\n    icon: str | None = Field(\n        default=None,\n        description=\"Lucide icon name (kebab-case, e.g. 'circle-alert')\",\n    )\n\n\nclass AlertTitle(Component):\n    \"\"\"Alert title text.\n\n    Example::\n\n        AlertTitle(\"Important!\")\n        AlertTitle(\"{{ alert_type }}\")\n    \"\"\"\n\n    type: Literal[\"AlertTitle\"] = \"AlertTitle\"\n    content: str = Field(description=\"Title text\")\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept content as positional or keyword argument.\"\"\"\n        if content is not None:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n\n\nclass AlertDescription(Component):\n    \"\"\"Alert description text.\n\n    Example::\n\n        AlertDescription(\"Your changes have been saved successfully.\")\n        AlertDescription(\"{{ message }}\")\n    \"\"\"\n\n    type: Literal[\"AlertDescription\"] = \"AlertDescription\"\n    content: str = Field(description=\"Description text\")\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept content as positional or keyword argument.\"\"\"\n        if content is not None:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/badge.py": "\"\"\"Badge component following shadcn/ui conventions.\n\nBadges display short status indicators or labels.\n\nExample::\n\n    from prefab_ui.components import Badge\n\n    Badge(\"New\")\n    Badge(\"{{ status }}\")\n    Badge(\"Error\", variant=\"destructive\")\n    Badge(\"Draft\", variant=\"secondary\")\n    Badge(\"Custom\", variant=\"outline\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\n\nBadgeVariant = Literal[\n    \"default\",\n    \"secondary\",\n    \"destructive\",\n    \"success\",\n    \"warning\",\n    \"info\",\n    \"outline\",\n    \"ghost\",\n]\n\n\nclass Badge(Component):\n    \"\"\"A badge component for displaying status or labels.\n\n    Args:\n        label: Badge text\n        variant: Visual style - \"default\", \"secondary\", \"destructive\", \"outline\",\n            \"ghost\", \"success\", \"warning\", \"info\"\n        css_class: Additional CSS classes to apply\n\n    Example::\n\n        Badge(\"Active\")\n        Badge(\"{{ user.role }}\")\n        Badge(\"Error\", variant=\"destructive\")\n        Badge(\"Draft\", variant=\"secondary\")\n        Badge(\"Custom\", variant=\"outline\")\n        Badge(\"Ghost\", variant=\"ghost\")\n    \"\"\"\n\n    type: Literal[\"Badge\"] = \"Badge\"\n    label: str = Field(description=\"Badge text\")\n    variant: BadgeVariant = Field(\n        default=\"default\",\n        description=\"Visual variant: default, secondary, destructive, outline, ghost, success, warning, or info\",\n    )\n\n    @overload\n    def __init__(self, label: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, label: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, label: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept label as positional or keyword argument.\"\"\"\n        if label is not None:\n            kwargs[\"label\"] = label\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/base.py": "\"\"\"Base classes for MCP Apps UI components.\"\"\"\n\nfrom __future__ import annotations\n\nfrom contextvars import ContextVar\nfrom typing import Annotated, Any, Literal\n\nfrom pydantic import BaseModel, BeforeValidator, Field\nfrom typing_extensions import Self\n\nfrom prefab_ui.css import Responsive\n\n_component_stack: ContextVar[list[ContainerComponent] | None] = ContextVar(\n    \"_component_stack\", default=None\n)\n\n\n# ── Gap / Align / Justify ──────────────────────────────────────────────\n\n\ndef _coerce_gap(v: Any) -> int | tuple[int | None, int | None] | Responsive | None:\n    \"\"\"Normalize gap values: None, int, (int,), (x, y), or Responsive.\"\"\"\n    if v is None or isinstance(v, Responsive):\n        return v\n    if isinstance(v, (list, tuple)):\n        if len(v) == 1:\n            return int(v[0])\n        if len(v) == 2:\n            x = int(v[0]) if v[0] is not None else None\n            y = int(v[1]) if v[1] is not None else None\n            return (x, y)\n        raise ValueError(\"gap must have 1 or 2 values\")\n    return int(v)\n\n\nGap = Annotated[\n    int | tuple[int | None, int | None] | Responsive | None,\n    BeforeValidator(_coerce_gap),\n]\n\nAlign = Literal[\"start\", \"center\", \"end\", \"stretch\", \"baseline\"] | None\n\nJustify = (\n    Literal[\"start\", \"center\", \"end\", \"between\", \"around\", \"evenly\", \"stretch\"] | None\n)\n\n\n# ── Layout class compilation ───────────────────────────────────────────\n\n\ndef _gap_classes(gap: int | tuple[int | None, int | None]) -> str:\n    \"\"\"Return Tailwind gap classes for a plain gap value.\"\"\"\n    if isinstance(gap, tuple):\n        parts: list[str] = []\n        x, y = gap\n        if x is not None:\n            parts.append(f\"gap-x-{x}\")\n        if y is not None:\n            parts.append(f\"gap-y-{y}\")\n        return \" \".join(parts)\n    return f\"gap-{gap}\"\n\n\ndef _compile_layout_classes(\n    *,\n    gap: int | tuple[int | None, int | None] | Responsive | None = None,\n    columns: int | dict[str, int] | Responsive | None = None,\n    align: str | None = None,\n    justify: str | None = None,\n) -> str | None:\n    \"\"\"Compile layout kwargs to a Tailwind class string.\"\"\"\n    parts: list[str] = []\n\n    # Gap\n    if gap is not None:\n        if isinstance(gap, Responsive):\n            parts.append(gap.compile_css(_gap_classes))\n        else:\n            parts.append(_gap_classes(gap))\n\n    # Columns\n    if columns is not None:\n        if isinstance(columns, Responsive):\n            parts.append(columns.compile_css(lambda n: f\"grid-cols-{n}\"))\n        elif isinstance(columns, dict):\n            parts.append(Responsive(**columns).compile_css(lambda n: f\"grid-cols-{n}\"))\n        else:\n            parts.append(f\"grid-cols-{columns}\")\n\n    if align is not None:\n        parts.append(f\"items-{align}\")\n    if justify is not None:\n        parts.append(f\"justify-{justify}\")\n    return \" \".join(parts) if parts else None\n\n\ndef _merge_css_classes(*classes: str | None) -> str | None:\n    \"\"\"Merge multiple class strings, returning None if empty.\"\"\"\n    merged = \" \".join(c for c in classes if c)\n    return merged or None\n\n\ndef _coerce_css_class(v: Any) -> str | None:\n    \"\"\"Compile css_class to a flat string.\n\n    Accepts a plain string, a Responsive object, or a list mixing both.\n    \"\"\"\n    if v is None:\n        return None\n    if isinstance(v, list):\n        parts: list[str] = []\n        for item in v:\n            if isinstance(item, Responsive):\n                compiled = item.compile_css(lambda s: str(s))\n                if compiled:\n                    parts.append(compiled)\n            elif item:\n                parts.append(str(item))\n        return \" \".join(parts) or None\n    if isinstance(v, Responsive):\n        compiled = v.compile_css(lambda s: str(s))\n        return compiled or None\n    return str(v)\n\n\nclass Component(BaseModel):\n    \"\"\"Base class for all UI components.\n\n    Components serialize to JSON via ``to_json()`` for the React renderer.\n    When created inside a ``ContainerComponent`` context manager, they\n    automatically append themselves to the parent's children list.\n    \"\"\"\n\n    model_config = {\"populate_by_name\": True, \"arbitrary_types_allowed\": True}\n\n    css_class: Annotated[str | None, BeforeValidator(_coerce_css_class)] = Field(\n        default=None,\n        alias=\"cssClass\",\n        description=\"CSS/Tailwind classes for styling. Accepts a Responsive() for breakpoint-aware classes.\",\n    )\n\n    def model_post_init(self, __context: Any) -> None:\n        stack = _component_stack.get() or []\n        if stack:\n            stack[-1].children.append(self)\n\n    def to_json(self) -> dict[str, Any]:\n        \"\"\"Serialize to JSON format for the React renderer.\n\n        Produces ``{\"type\": \"ClassName\", ...props}`` with ``None`` values\n        excluded. Children are serialized recursively.\n        \"\"\"\n        return self.model_dump(by_alias=True, exclude_none=True)\n\n\nclass ContainerComponent(Component):\n    \"\"\"Component that can contain child components.\n\n    Use as a context manager to build nested layouts::\n\n        with Column():\n            Text(\"hello\")\n            Text(\"world\")\n    \"\"\"\n\n    children: list[Component] = Field(default_factory=list)\n    let: dict[str, Any] | None = Field(\n        default=None,\n        description=\"Scoped bindings available to children. Values are template strings.\",\n    )\n\n    def __enter__(self) -> Self:\n        stack = _component_stack.get() or []\n        _component_stack.set([*stack, self])\n        return self\n\n    def __exit__(self, *args: Any) -> None:\n        stack = _component_stack.get() or []\n        _component_stack.set(stack[:-1])\n\n    def to_json(self) -> dict[str, Any]:\n        d = super().to_json()\n        # model_dump includes children=[] (not None), so always replace with\n        # recursive serialization or remove the key when empty.\n        d.pop(\"children\", None)\n        if self.children:\n            d[\"children\"] = _serialize_children(self.children)\n        return d\n\n\ndef _to_case(node: Component) -> dict[str, Any]:\n    \"\"\"Convert an If or Elif node to a Condition case entry.\"\"\"\n    condition = getattr(node, \"condition\", \"\")\n    stripped = condition.strip()\n    if not (stripped.startswith(\"{{\") and stripped.endswith(\"}}\")):\n        condition = f\"{{{{ {condition} }}}}\"\n    case: dict[str, Any] = {\"when\": condition}\n    children = getattr(node, \"children\", [])\n    if children:\n        case[\"children\"] = _serialize_children(children)\n    return case\n\n\ndef _serialize_children(children: list[Component]) -> list[dict[str, Any]]:\n    \"\"\"Serialize children, grouping If/Elif/Else chains into Condition nodes.\"\"\"\n    result: list[dict[str, Any]] = []\n    i = 0\n    while i < len(children):\n        child = children[i]\n        child_type = getattr(child, \"type\", None)\n\n        if child_type == \"If\":\n            cases: list[dict[str, Any]] = [_to_case(child)]\n            else_children: list[dict[str, Any]] | None = None\n            i += 1\n            while i < len(children):\n                t = getattr(children[i], \"type\", None)\n                if t == \"Elif\":\n                    cases.append(_to_case(children[i]))\n                    i += 1\n                elif t == \"Else\":\n                    inner = getattr(children[i], \"children\", [])\n                    else_children = _serialize_children(inner)\n                    i += 1\n                    break\n                else:\n                    break\n            node: dict[str, Any] = {\"type\": \"Condition\", \"cases\": cases}\n            if else_children:\n                node[\"else\"] = else_children\n            result.append(node)\n\n        elif child_type in (\"Elif\", \"Else\"):\n            raise ValueError(\n                f\"{child_type} without preceding If — \"\n                f\"Elif and Else must immediately follow an If or Elif\"\n            )\n\n        else:\n            result.append(child.to_json())\n            i += 1\n\n    return result\n",
  "prefab_ui/components/button.py": "\"\"\"Button component following shadcn/ui conventions.\n\nButtons support multiple variants and sizes, with automatic dark mode styling.\n\nExample::\n\n    from prefab_ui.components import Button\n\n    Button(\"Click me\")\n    Button(\"Save\", variant=\"default\")\n    Button(\"Delete\", variant=\"destructive\")\n    Button(\"Cancel\", variant=\"outline\")\n    Button(\"More options\", variant=\"ghost\")\n    Button(\"Learn more\", variant=\"link\")\n\n    # Sizes\n    Button(\"Small\", size=\"sm\")\n    Button(\"Large\", size=\"lg\")\n    Button(\"Icon\", size=\"icon\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component\n\nButtonVariant = Literal[\n    \"default\",\n    \"destructive\",\n    \"outline\",\n    \"secondary\",\n    \"ghost\",\n    \"link\",\n    \"success\",\n    \"warning\",\n    \"info\",\n]\nButtonSize = Literal[\n    \"default\", \"xs\", \"sm\", \"lg\", \"icon\", \"icon-xs\", \"icon-sm\", \"icon-lg\"\n]\n\n\nclass Button(Component):\n    \"\"\"A button component with multiple variants and sizes.\n\n    Args:\n        label: Button text\n        variant: Visual style - \"default\", \"destructive\", \"outline\", \"secondary\", \"ghost\", \"link\"\n        size: Button size - \"default\", \"sm\", \"lg\", \"icon\"\n        disabled: Whether the button is disabled\n        css_class: Additional CSS classes to apply\n\n    Example::\n\n        Button(\"Save Changes\")\n        Button(\"Delete\", variant=\"destructive\")\n        Button(\"Cancel\", variant=\"outline\", size=\"sm\")\n    \"\"\"\n\n    type: Literal[\"Button\"] = \"Button\"\n    label: str = Field(description=\"Button text\")\n    icon: str | None = Field(\n        default=None,\n        description=\"Lucide icon name (kebab-case, e.g. 'arrow-right')\",\n    )\n    variant: ButtonVariant = Field(\n        default=\"default\",\n        description=\"Visual variant: default, destructive, outline, secondary, ghost, link\",\n    )\n    size: ButtonSize = Field(\n        default=\"default\",\n        description=\"Size: default, sm, lg, icon\",\n    )\n    disabled: bool | str = Field(\n        default=False, description=\"Whether the button is disabled\"\n    )\n    on_click: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onClick\",\n        description=\"Action(s) to execute when clicked\",\n    )\n\n    @overload\n    def __init__(self, label: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, label: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, label: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept label as positional or keyword argument.\"\"\"\n        if label is not None:\n            kwargs[\"label\"] = label\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/button_group.py": "\"\"\"ButtonGroup component following shadcn/ui v4 conventions.\n\nGroups buttons together with merged borders and adjusted corners.\n\nExample::\n\n    from prefab_ui.components import Button, ButtonGroup\n\n    with ButtonGroup():\n        Button(\"Previous\")\n        Button(\"Next\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass ButtonGroup(ContainerComponent):\n    \"\"\"A container that groups buttons with merged borders.\n\n    Args:\n        orientation: Layout direction - \"horizontal\" or \"vertical\"\n        css_class: Additional CSS classes to apply\n\n    Example::\n\n        from prefab_ui.components import Button, ButtonGroup\n\n        with ButtonGroup():\n            Button(\"Save\")\n            Button(\"Cancel\", variant=\"outline\")\n\n        with ButtonGroup(orientation=\"vertical\"):\n            Button(\"Top\")\n            Button(\"Middle\")\n            Button(\"Bottom\")\n    \"\"\"\n\n    type: Literal[\"ButtonGroup\"] = \"ButtonGroup\"\n    orientation: Literal[\"horizontal\", \"vertical\"] = Field(\n        default=\"horizontal\",\n        description=\"Layout direction: horizontal or vertical\",\n    )\n",
  "prefab_ui/components/calendar.py": "\"\"\"Calendar component for date selection.\n\nExample::\n\n    from prefab_ui.components import Calendar\n\n    Calendar(name=\"selectedDate\")\n    Calendar(mode=\"range\", name=\"dateRange\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component\n\n\nclass Calendar(Component):\n    \"\"\"Date picker calendar.\n\n    Selected date(s) stored in state as ISO strings.\n\n    Example::\n\n        Calendar(name=\"selectedDate\")\n        Calendar(mode=\"range\", name=\"dateRange\")\n    \"\"\"\n\n    type: Literal[\"Calendar\"] = \"Calendar\"\n    mode: Literal[\"single\", \"multiple\", \"range\"] = Field(\n        default=\"single\",\n        description=\"Selection mode: single date, multiple dates, or date range\",\n    )\n    name: str | None = Field(\n        default=None,\n        description=\"State key for storing the selected date (ISO string)\",\n    )\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) when selection changes\",\n    )\n",
  "prefab_ui/components/card.py": "\"\"\"Card components following shadcn/ui conventions.\n\nCards provide a contained surface for grouping related content.\n\nExample::\n\n    from prefab_ui.components import (\n        Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter\n    )\n    from prefab_ui.components import Button, P\n\n    with Card():\n        with CardHeader():\n            CardTitle(\"Create project\")\n            CardDescription(\"Deploy your new project in one-click.\")\n        with CardContent():\n            P(\"Your project will be created with default settings.\")\n        with CardFooter():\n            Button(\"Cancel\", variant=\"outline\")\n            Button(\"Deploy\")\n\n    # Simple card\n    with Card(css_class=\"p-6\"):\n        H3(\"Quick Stats\")\n        P(\"{{ summary }}\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Card(ContainerComponent):\n    \"\"\"A card container with border and shadow.\n\n    Cards group related content and actions. Use CardHeader, CardContent,\n    and CardFooter for structured layouts.\n\n    Example::\n\n        with Card():\n            CardTitle(\"Title\")\n            P(\"Content\")\n    \"\"\"\n\n    type: Literal[\"Card\"] = \"Card\"\n\n\nclass CardHeader(ContainerComponent):\n    \"\"\"Card header section for title and description.\n\n    Example::\n\n        with CardHeader():\n            CardTitle(\"Account\")\n            CardDescription(\"Manage your account settings.\")\n    \"\"\"\n\n    type: Literal[\"CardHeader\"] = \"CardHeader\"\n\n\nclass CardTitle(ContainerComponent):\n    \"\"\"Card title text.\n\n    Can contain a string or child components.\n\n    Example::\n\n        CardTitle(\"Settings\")\n        CardTitle(\"{{ project_name }}\")\n    \"\"\"\n\n    type: Literal[\"CardTitle\"] = \"CardTitle\"\n    content: str | None = Field(\n        default=None,\n        description=\"Title text (alternative to children)\",\n    )\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str | None = None, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept content as positional or keyword argument.\"\"\"\n        if content is not None and \"content\" not in kwargs:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n\n\nclass CardDescription(ContainerComponent):\n    \"\"\"Card description text, typically below the title.\n\n    Example::\n\n        CardDescription(\"Make changes to your account here.\")\n    \"\"\"\n\n    type: Literal[\"CardDescription\"] = \"CardDescription\"\n    content: str | None = Field(\n        default=None,\n        description=\"Description text (alternative to children)\",\n    )\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str | None = None, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept content as positional or keyword argument.\"\"\"\n        if content is not None and \"content\" not in kwargs:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n\n\nclass CardContent(ContainerComponent):\n    \"\"\"Card content section for the main body.\n\n    Example::\n\n        with CardContent():\n            P(\"Your content here.\")\n    \"\"\"\n\n    type: Literal[\"CardContent\"] = \"CardContent\"\n\n\nclass CardFooter(ContainerComponent):\n    \"\"\"Card footer section, typically for actions.\n\n    Example::\n\n        with CardFooter():\n            Button(\"Cancel\", variant=\"outline\")\n            Button(\"Save\")\n    \"\"\"\n\n    type: Literal[\"CardFooter\"] = \"CardFooter\"\n",
  "prefab_ui/components/chart.py": "\"\"\"Chart components — BarChart, LineChart, AreaChart, PieChart, RadarChart, RadialChart.\n\nBuilt on Recharts + shadcn ChartContainer in the renderer.\n\nExample::\n\n    from prefab_ui.components import BarChart, ChartSeries\n\n    BarChart(\n        data=[\n            {\"month\": \"Jan\", \"desktop\": 186, \"mobile\": 80},\n            {\"month\": \"Feb\", \"desktop\": 305, \"mobile\": 200},\n        ],\n        series=[\n            ChartSeries(data_key=\"desktop\", label=\"Desktop\"),\n            ChartSeries(data_key=\"mobile\", label=\"Mobile\"),\n        ],\n        x_axis=\"month\",\n    )\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import BaseModel, Field\n\nfrom prefab_ui.components.base import Component\n\n\nclass ChartSeries(BaseModel):\n    \"\"\"Series definition for cartesian charts (Bar, Line, Area).\"\"\"\n\n    model_config = {\"populate_by_name\": True}\n\n    data_key: str = Field(alias=\"dataKey\", description=\"Data field to plot\")\n    label: str | None = Field(\n        default=None, description=\"Display label (defaults to dataKey)\"\n    )\n    color: str | None = Field(default=None, description=\"CSS color override\")\n\n\nclass BarChart(Component):\n    \"\"\"Bar chart with one or more series.\n\n    Example::\n\n        BarChart(\n            data=[{\"month\": \"Jan\", \"a\": 10, \"b\": 20}],\n            series=[ChartSeries(data_key=\"a\"), ChartSeries(data_key=\"b\")],\n            x_axis=\"month\",\n            stacked=True,\n        )\n    \"\"\"\n\n    type: Literal[\"BarChart\"] = \"BarChart\"\n    data: list[dict[str, Any]] | str = Field(\n        description=\"Row data or {{ interpolation }} reference\"\n    )\n    series: list[ChartSeries] = Field(description=\"Series to render as bars\")\n    x_axis: str | None = Field(\n        default=None, alias=\"xAxis\", description=\"Data key for x-axis labels\"\n    )\n    height: int = Field(default=300, description=\"Chart height in pixels\")\n    stacked: bool = Field(default=False, description=\"Stack bars\")\n    horizontal: bool = Field(\n        default=False, description=\"Render as horizontal bar chart\"\n    )\n    bar_radius: int = Field(\n        default=4, alias=\"barRadius\", description=\"Corner radius on bars\"\n    )\n    show_legend: bool = Field(\n        default=False, alias=\"showLegend\", description=\"Show legend\"\n    )\n    show_tooltip: bool = Field(\n        default=True, alias=\"showTooltip\", description=\"Show tooltip on hover\"\n    )\n    show_grid: bool = Field(\n        default=True, alias=\"showGrid\", description=\"Show cartesian grid\"\n    )\n\n\nclass LineChart(Component):\n    \"\"\"Line chart with one or more series.\n\n    Example::\n\n        LineChart(\n            data=[{\"month\": \"Jan\", \"a\": 10}],\n            series=[ChartSeries(data_key=\"a\")],\n            x_axis=\"month\",\n        )\n    \"\"\"\n\n    type: Literal[\"LineChart\"] = \"LineChart\"\n    data: list[dict[str, Any]] | str = Field(\n        description=\"Row data or {{ interpolation }} reference\"\n    )\n    series: list[ChartSeries] = Field(description=\"Series to render as lines\")\n    x_axis: str | None = Field(\n        default=None, alias=\"xAxis\", description=\"Data key for x-axis labels\"\n    )\n    height: int = Field(default=300, description=\"Chart height in pixels\")\n    curve: Literal[\"linear\", \"smooth\", \"step\"] = Field(\n        default=\"linear\", description=\"Line interpolation style\"\n    )\n    show_dots: bool = Field(\n        default=False, alias=\"showDots\", description=\"Show dots at data points\"\n    )\n    show_legend: bool = Field(\n        default=False, alias=\"showLegend\", description=\"Show legend\"\n    )\n    show_tooltip: bool = Field(\n        default=True, alias=\"showTooltip\", description=\"Show tooltip on hover\"\n    )\n    show_grid: bool = Field(\n        default=True, alias=\"showGrid\", description=\"Show cartesian grid\"\n    )\n\n\nclass AreaChart(Component):\n    \"\"\"Area chart with one or more series.\n\n    Example::\n\n        AreaChart(\n            data=[{\"month\": \"Jan\", \"a\": 10, \"b\": 20}],\n            series=[ChartSeries(data_key=\"a\"), ChartSeries(data_key=\"b\")],\n            x_axis=\"month\",\n            stacked=True,\n        )\n    \"\"\"\n\n    type: Literal[\"AreaChart\"] = \"AreaChart\"\n    data: list[dict[str, Any]] | str = Field(\n        description=\"Row data or {{ interpolation }} reference\"\n    )\n    series: list[ChartSeries] = Field(description=\"Series to render as areas\")\n    x_axis: str | None = Field(\n        default=None, alias=\"xAxis\", description=\"Data key for x-axis labels\"\n    )\n    height: int = Field(default=300, description=\"Chart height in pixels\")\n    stacked: bool = Field(default=False, description=\"Stack areas\")\n    curve: Literal[\"linear\", \"smooth\", \"step\"] = Field(\n        default=\"linear\", description=\"Line interpolation style\"\n    )\n    show_dots: bool = Field(\n        default=False, alias=\"showDots\", description=\"Show dots at data points\"\n    )\n    show_legend: bool = Field(\n        default=False, alias=\"showLegend\", description=\"Show legend\"\n    )\n    show_tooltip: bool = Field(\n        default=True, alias=\"showTooltip\", description=\"Show tooltip on hover\"\n    )\n    show_grid: bool = Field(\n        default=True, alias=\"showGrid\", description=\"Show cartesian grid\"\n    )\n\n\nclass PieChart(Component):\n    \"\"\"Pie or donut chart.\n\n    Example::\n\n        PieChart(\n            data=[\n                {\"browser\": \"Chrome\", \"visitors\": 275},\n                {\"browser\": \"Safari\", \"visitors\": 200},\n            ],\n            data_key=\"visitors\",\n            name_key=\"browser\",\n            inner_radius=60,\n        )\n    \"\"\"\n\n    type: Literal[\"PieChart\"] = \"PieChart\"\n    data: list[dict[str, Any]] | str = Field(\n        description=\"Row data or {{ interpolation }} reference\"\n    )\n    data_key: str = Field(alias=\"dataKey\", description=\"Numeric value field\")\n    name_key: str = Field(alias=\"nameKey\", description=\"Label field\")\n    height: int = Field(default=300, description=\"Chart height in pixels\")\n    inner_radius: int = Field(\n        default=0, alias=\"innerRadius\", description=\"Inner radius (>0 for donut)\"\n    )\n    show_label: bool = Field(\n        default=False, alias=\"showLabel\", description=\"Show labels on slices\"\n    )\n    padding_angle: int = Field(\n        default=0, alias=\"paddingAngle\", description=\"Gap between slices in degrees\"\n    )\n    show_legend: bool = Field(\n        default=False, alias=\"showLegend\", description=\"Show legend\"\n    )\n    show_tooltip: bool = Field(\n        default=True, alias=\"showTooltip\", description=\"Show tooltip on hover\"\n    )\n\n\nclass RadarChart(Component):\n    \"\"\"Radar (spider) chart with one or more series plotted on radial axes.\n\n    Example::\n\n        RadarChart(\n            data=[\n                {\"subject\": \"Math\", \"alice\": 120, \"bob\": 98},\n                {\"subject\": \"English\", \"alice\": 98, \"bob\": 130},\n            ],\n            series=[ChartSeries(data_key=\"alice\"), ChartSeries(data_key=\"bob\")],\n            axis_key=\"subject\",\n        )\n    \"\"\"\n\n    type: Literal[\"RadarChart\"] = \"RadarChart\"\n    data: list[dict[str, Any]] | str = Field(\n        description=\"Row data or {{ interpolation }} reference\"\n    )\n    series: list[ChartSeries] = Field(description=\"Series to render as radar areas\")\n    axis_key: str | None = Field(\n        default=None, alias=\"axisKey\", description=\"Data key for angular axis labels\"\n    )\n    height: int = Field(default=300, description=\"Chart height in pixels\")\n    filled: bool = Field(\n        default=True, description=\"Fill radar polygons (False for lines only)\"\n    )\n    show_dots: bool = Field(\n        default=False, alias=\"showDots\", description=\"Show dots at vertices\"\n    )\n    show_legend: bool = Field(\n        default=False, alias=\"showLegend\", description=\"Show legend\"\n    )\n    show_tooltip: bool = Field(\n        default=True, alias=\"showTooltip\", description=\"Show tooltip on hover\"\n    )\n    show_grid: bool = Field(\n        default=True, alias=\"showGrid\", description=\"Show polar grid\"\n    )\n\n\nclass RadialChart(Component):\n    \"\"\"Radial bar chart — categorical data as concentric rings.\n\n    Example::\n\n        RadialChart(\n            data=[\n                {\"browser\": \"Chrome\", \"visitors\": 275},\n                {\"browser\": \"Safari\", \"visitors\": 200},\n            ],\n            data_key=\"visitors\",\n            name_key=\"browser\",\n        )\n    \"\"\"\n\n    type: Literal[\"RadialChart\"] = \"RadialChart\"\n    data: list[dict[str, Any]] | str = Field(\n        description=\"Row data or {{ interpolation }} reference\"\n    )\n    data_key: str = Field(alias=\"dataKey\", description=\"Numeric value field\")\n    name_key: str = Field(alias=\"nameKey\", description=\"Label field\")\n    height: int = Field(default=300, description=\"Chart height in pixels\")\n    inner_radius: int = Field(\n        default=30, alias=\"innerRadius\", description=\"Inner radius in pixels\"\n    )\n    start_angle: int = Field(\n        default=180, alias=\"startAngle\", description=\"Arc start angle in degrees\"\n    )\n    end_angle: int = Field(\n        default=0, alias=\"endAngle\", description=\"Arc end angle in degrees\"\n    )\n    show_legend: bool = Field(\n        default=False, alias=\"showLegend\", description=\"Show legend\"\n    )\n    show_tooltip: bool = Field(\n        default=True, alias=\"showTooltip\", description=\"Show tooltip on hover\"\n    )\n",
  "prefab_ui/components/checkbox.py": "\"\"\"Checkbox component for binary choices.\n\nCheckboxes let users select one or more options from a set.\n\nExample::\n\n    from prefab_ui.components import Checkbox, Label\n\n    Checkbox(checked=True, label=\"Accept terms\")\n    Checkbox(label=\"Subscribe to newsletter\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component\n\n\nclass Checkbox(Component):\n    \"\"\"Checkbox input component.\n\n    Args:\n        label: Label text to display next to checkbox\n        checked: Whether checkbox is checked\n        name: Form field name\n        value: Form value when checked\n        disabled: Whether checkbox is disabled\n        required: Whether checkbox is required\n        css_class: Additional CSS classes\n\n    Example::\n\n        Checkbox(label=\"Remember me\")\n        Checkbox(checked=True, label=\"Agreed\")\n        Checkbox(label=\"Enable {{ feature_name }}\", checked=\"{{ is_enabled }}\")\n    \"\"\"\n\n    type: Literal[\"Checkbox\"] = \"Checkbox\"\n    label: str | None = Field(default=None, description=\"Label text\")\n    checked: bool = Field(default=False, description=\"Whether checkbox is checked\")\n    name: str | None = Field(default=None, description=\"Form field name\")\n    value: str | None = Field(default=None, description=\"Form value\")\n    disabled: bool = Field(default=False, description=\"Whether checkbox is disabled\")\n    required: bool = Field(default=False, description=\"Whether checkbox is required\")\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) to execute when checked state changes\",\n    )\n",
  "prefab_ui/components/code.py": "\"\"\"Code block display component.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\n\n\nclass Code(Component):\n    \"\"\"Code block with optional syntax highlighting.\n\n    Example::\n\n        Code(\"{{ source_code }}\", language=\"python\")\n    \"\"\"\n\n    type: Literal[\"Code\"] = \"Code\"\n    content: str = Field(description=\"Code content\")\n    language: str | None = Field(\n        default=None, description=\"Syntax highlighting language\"\n    )\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept content as positional or keyword argument.\"\"\"\n        if content is not None:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/column.py": "\"\"\"Column layout container.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import (\n    Align,\n    ContainerComponent,\n    Gap,\n    Justify,\n    _compile_layout_classes,\n    _merge_css_classes,\n)\n\n\nclass Column(ContainerComponent):\n    \"\"\"Vertical flex container.\n\n    Example::\n\n        with Column():\n            Heading(\"Title\")\n            Text(\"Body\")\n\n        with Column(gap=4):\n            Heading(\"Title\")\n            Text(\"Body\")\n    \"\"\"\n\n    type: Literal[\"Column\"] = \"Column\"\n    gap: Gap = Field(default=None, exclude=True)\n    align: Align = Field(default=None, exclude=True)\n    justify: Justify = Field(default=None, exclude=True)\n\n    def model_post_init(self, __context: Any) -> None:\n        layout = _compile_layout_classes(\n            gap=self.gap, align=self.align, justify=self.justify\n        )\n        self.css_class = _merge_css_classes(layout, self.css_class)\n        super().model_post_init(__context)\n",
  "prefab_ui/components/combobox.py": "\"\"\"Combobox — searchable select dropdown.\n\nA filterable dropdown for selecting from large option lists. Options are\ndefined as ``ComboboxOption`` children, similar to ``Select``/``SelectOption``.\n\nExample::\n\n    from prefab_ui.components import Combobox, ComboboxOption\n\n    with Combobox(placeholder=\"Select a framework...\", name=\"framework\"):\n        ComboboxOption(\"Next.js\", value=\"nextjs\")\n        ComboboxOption(\"Remix\", value=\"remix\")\n        ComboboxOption(\"Astro\", value=\"astro\")\n        ComboboxOption(\"SvelteKit\", value=\"sveltekit\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component, ContainerComponent\n\n\nclass ComboboxOption(Component):\n    \"\"\"A single option within a Combobox.\n\n    Example::\n\n        ComboboxOption(\"Next.js\", value=\"nextjs\")\n    \"\"\"\n\n    type: Literal[\"ComboboxOption\"] = \"ComboboxOption\"\n    value: str = Field(description=\"Option value\")\n    label: str = Field(description=\"Display label\")\n    disabled: bool = Field(default=False, description=\"Whether option is disabled\")\n\n    @overload\n    def __init__(self, label: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, label: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, label: str | None = None, **kwargs: Any) -> None:\n        if label is not None and \"label\" not in kwargs:\n            kwargs[\"label\"] = label\n        if \"value\" not in kwargs and label is not None:\n            kwargs[\"value\"] = label.lower().replace(\" \", \"-\")\n        super().__init__(**kwargs)\n\n\nclass Combobox(ContainerComponent):\n    \"\"\"Searchable select dropdown.\n\n    Children must be ``ComboboxOption`` components.\n\n    Args:\n        placeholder: Placeholder text when no value selected\n        search_placeholder: Placeholder text in the search input\n        name: State key for the selected value\n        disabled: Whether the combobox is disabled\n\n    Example::\n\n        with Combobox(placeholder=\"Pick a language...\", name=\"lang\"):\n            ComboboxOption(\"Python\", value=\"python\")\n            ComboboxOption(\"TypeScript\", value=\"typescript\")\n            ComboboxOption(\"Rust\", value=\"rust\")\n    \"\"\"\n\n    type: Literal[\"Combobox\"] = \"Combobox\"\n    placeholder: str | None = Field(\n        default=None,\n        description=\"Placeholder text shown when no value is selected\",\n    )\n    search_placeholder: str | None = Field(\n        default=None,\n        alias=\"searchPlaceholder\",\n        description=\"Placeholder text in the search input\",\n    )\n    name: str | None = Field(\n        default=None,\n        description=\"State key for the selected value\",\n    )\n    disabled: bool = Field(default=False, description=\"Whether combobox is disabled\")\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) when the selected value changes\",\n    )\n",
  "prefab_ui/components/conditional.py": "\"\"\"Conditional rendering components: If, Elif, Else.\n\nThese components express conditional logic in the Python DSL as natural\nsiblings, mirroring Python's own if/elif/else syntax::\n\n    with If(\"inventory == 0\"):\n        Alert(\"Out of stock\", variant=\"destructive\")\n    with Elif(\"inventory < 10\"):\n        Alert(\"Low stock\")\n    with Else():\n        Badge(\"In stock\")\n\nDuring serialization, the parent container groups consecutive If/Elif/Else\nsiblings into a single ``Condition`` node in the wire format. These component\ntypes never appear in the JSON directly.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass If(ContainerComponent):\n    \"\"\"Conditional branch — renders children when the condition is truthy.\n\n    Args:\n        condition: Expression string evaluated against the current state.\n\n    Example::\n\n        with If(\"count > 0\"):\n            Text(\"{{ count }} items\")\n    \"\"\"\n\n    type: Literal[\"If\"] = \"If\"\n    condition: str = Field(description=\"Expression to evaluate\")\n\n    @overload\n    def __init__(self, condition: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, condition: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, condition: str | None = None, **kwargs: Any) -> None:\n        if condition is not None:\n            kwargs[\"condition\"] = condition\n        super().__init__(**kwargs)\n\n\nclass Elif(ContainerComponent):\n    \"\"\"Alternate conditional branch — must follow an If or another Elif.\n\n    Args:\n        condition: Expression string evaluated against the current state.\n\n    Example::\n\n        with Elif(\"count == 0\"):\n            Text(\"No items\")\n    \"\"\"\n\n    type: Literal[\"Elif\"] = \"Elif\"\n    condition: str = Field(description=\"Expression to evaluate\")\n\n    @overload\n    def __init__(self, condition: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, condition: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, condition: str | None = None, **kwargs: Any) -> None:\n        if condition is not None:\n            kwargs[\"condition\"] = condition\n        super().__init__(**kwargs)\n\n\nclass Else(ContainerComponent):\n    \"\"\"Default branch — renders when no preceding If/Elif matched.\n\n    Example::\n\n        with Else():\n            Text(\"Fallback content\")\n    \"\"\"\n\n    type: Literal[\"Else\"] = \"Else\"\n",
  "prefab_ui/components/container.py": "\"\"\"Responsive container with sensible defaults.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Container(ContainerComponent):\n    \"\"\"A centered, max-width container with responsive padding.\n\n    Wraps content in Tailwind's ``container`` with automatic horizontal\n    centering and padding that scales with the viewport.\n\n    Example::\n\n        with Container():\n            H1(\"Dashboard\")\n            Grid(columns=3):\n                ...\n    \"\"\"\n\n    type: Literal[\"Container\"] = \"Container\"\n",
  "prefab_ui/components/data_table.py": "\"\"\"DataTable — a high-level table with built-in sorting, filtering, pagination.\n\nBuilt on @tanstack/react-table in the renderer.\n\nExample::\n\n    from prefab_ui.components import DataTable, DataTableColumn\n\n    DataTable(\n        columns=[\n            DataTableColumn(key=\"name\", header=\"Name\", sortable=True),\n            DataTableColumn(key=\"email\", header=\"Email\"),\n            DataTableColumn(key=\"role\", header=\"Role\"),\n        ],\n        rows=\"{{ users }}\",\n        searchable=True,\n        paginated=True,\n    )\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import BaseModel, Field\n\nfrom prefab_ui.components.base import Component\n\n\nclass DataTableColumn(BaseModel):\n    \"\"\"Column definition for DataTable.\"\"\"\n\n    model_config = {\"populate_by_name\": True}\n\n    key: str = Field(description=\"Data key to display in this column\")\n    header: str = Field(description=\"Column header text\")\n    sortable: bool = Field(default=False, description=\"Enable sorting for this column\")\n\n\nclass DataTable(Component):\n    \"\"\"High-level data table with sorting, filtering, and pagination.\n\n    Accepts flat ``columns`` and ``rows`` — the renderer handles the rest.\n\n    Example::\n\n        DataTable(\n            columns=[\n                DataTableColumn(key=\"name\", header=\"Name\", sortable=True),\n                DataTableColumn(key=\"email\", header=\"Email\"),\n            ],\n            rows=data[\"users\"],\n            searchable=True,\n            paginated=True,\n        )\n    \"\"\"\n\n    type: Literal[\"DataTable\"] = \"DataTable\"\n    columns: list[DataTableColumn] = Field(description=\"Column definitions\")\n    rows: list[dict[str, Any]] | str = Field(\n        default_factory=list,\n        description=\"Row data or {{ interpolation }} reference\",\n    )\n    searchable: bool = Field(default=False, description=\"Show search/filter input\")\n    paginated: bool = Field(default=False, description=\"Show pagination controls\")\n    page_size: int = Field(\n        default=10, alias=\"pageSize\", description=\"Rows per page when paginated\"\n    )\n    caption: str | None = Field(default=None, description=\"Optional table caption\")\n",
  "prefab_ui/components/date_picker.py": "\"\"\"DatePicker — popover with a calendar for selecting dates.\n\nExample::\n\n    from prefab_ui.components import DatePicker\n\n    DatePicker(placeholder=\"Select deadline\", name=\"deadline\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component\n\n\nclass DatePicker(Component):\n    \"\"\"Date picker with a popover calendar.\n\n    A button trigger shows the selected date; clicking opens a calendar.\n\n    Example::\n\n        DatePicker(placeholder=\"Pick a date\", name=\"deadline\")\n    \"\"\"\n\n    type: Literal[\"DatePicker\"] = \"DatePicker\"\n    placeholder: str = Field(\n        default=\"Pick a date\",\n        description=\"Button text when no date is selected\",\n    )\n    name: str | None = Field(\n        default=None,\n        description=\"State key for the selected date (ISO string)\",\n    )\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) when date changes\",\n    )\n",
  "prefab_ui/components/dialog.py": "\"\"\"Dialog (modal) — overlay with a trigger and content.\n\nThe first child becomes the trigger; remaining children become the dialog body.\n\nExample::\n\n    from prefab_ui.components import Dialog, Button, Text, Row\n    from prefab_ui.actions import ToolCall\n\n    with Dialog(title=\"Confirm Delete\", description=\"This action cannot be undone.\"):\n        Button(\"Delete\", variant=\"destructive\")  # trigger\n        Text(\"Are you sure you want to delete this item?\")\n        with Row(gap=2):\n            Button(\"Cancel\", variant=\"outline\")\n            Button(\"Confirm\", on_click=ToolCall(\"delete_item\"))\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Dialog(ContainerComponent):\n    \"\"\"Modal dialog overlay.\n\n    First child = trigger, remaining children = dialog body.\n\n    Example::\n\n        with Dialog(title=\"Edit Profile\"):\n            Button(\"Edit\")\n            with Column(gap=3):\n                Input(name=\"displayName\", placeholder=\"Display name\")\n                Button(\"Save\", on_click=ToolCall(\"update_profile\"))\n    \"\"\"\n\n    type: Literal[\"Dialog\"] = \"Dialog\"\n    title: str | None = Field(default=None, description=\"Dialog header title\")\n    description: str | None = Field(\n        default=None, description=\"Dialog header description\"\n    )\n",
  "prefab_ui/components/div.py": "\"\"\"Generic div and span containers with no default styling.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component, ContainerComponent\n\n\nclass Div(ContainerComponent):\n    \"\"\"A bare container with no default styling.\n\n    This is the Python equivalent of ``<div className=\"...\">`` in React.\n    Use when you need a wrapper with custom Tailwind classes that\n    Column/Row/Grid don't naturally express.\n\n    Example::\n\n        with Div(css_class=\"flex items-center gap-4 px-6 py-4\"):\n            Badge(\"deploy\", variant=\"outline\")\n            P(\"Deployed v2.4.1\")\n\n    For CSS that Tailwind can't express (vendor prefixes, ``clamp()``,\n    ``mask-image``, etc.), use the *style* escape hatch::\n\n        Div(style={\"mask-image\": \"linear-gradient(to bottom, black 70%, transparent)\"})\n    \"\"\"\n\n    type: Literal[\"Div\"] = \"Div\"\n    style: dict[str, str] | None = Field(\n        default=None, description=\"Inline CSS styles as a dict of property/value pairs.\"\n    )\n\n\nclass Span(Component):\n    \"\"\"An inline text element with no default styling.\n\n    Example::\n\n        Span(\"14m ago\", css_class=\"text-sm text-muted-foreground\")\n    \"\"\"\n\n    type: Literal[\"Span\"] = \"Span\"\n    content: str = Field(description=\"Text content\")\n    style: dict[str, str] | None = Field(\n        default=None, description=\"Inline CSS styles as a dict of property/value pairs.\"\n    )\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        if content is not None:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/field.py": "\"\"\"Field component for choice card layouts.\n\nField wraps a form control (Switch, Checkbox, etc.) in a bordered card\nwith a title and optional description. Clicking anywhere on the card\nactivates the wrapped control.\n\nExample::\n\n    from prefab_ui.components import Field, Switch\n\n    with Field(title=\"Dark mode\", description=\"Use dark theme\"):\n        Switch(name=\"dark_mode\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field as PydanticField\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Field(ContainerComponent):\n    \"\"\"Choice card container for form controls.\n\n    Renders a bordered card with title/description on the left and\n    the child control on the right. The entire card is clickable.\n\n    Args:\n        title: Card heading text (required).\n        description: Secondary text below the title.\n        disabled: Whether the field is dimmed and non-interactive.\n\n    Example::\n\n        with Field(title=\"Notifications\", description=\"Get notified\"):\n            Switch(name=\"notifications\")\n    \"\"\"\n\n    type: Literal[\"Field\"] = \"Field\"\n    title: str = PydanticField(description=\"Card heading text\")\n    description: str | None = PydanticField(\n        default=None, description=\"Secondary text below the title\"\n    )\n    disabled: bool = PydanticField(\n        default=False, description=\"Whether the field is dimmed and non-interactive\"\n    )\n",
  "prefab_ui/components/foreach.py": "\"\"\"ForEach control-flow component for iterating over lists.\n\nRepeats its children once per item in a data list, passing each item as the\ndata context for interpolation.\n\nExample::\n\n    from prefab_ui.components import ForEach\n    from prefab_ui.components import Card, CardTitle, Badge\n\n    with ForEach(\"users\"):\n        with Card():\n            CardTitle(\"{{ name }}\")\n            Badge(\"{{ role }}\")\n\nWhen rendered with ``data={\"users\": [{\"name\": \"Alice\", ...}, ...]}``, produces\none Card per user.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass ForEach(ContainerComponent):\n    \"\"\"Repeat children for each item in a data list.\n\n    Args:\n        key: The data field containing the list to iterate over.\n        css_class: Additional CSS classes for the wrapper element.\n\n    Example::\n\n        with ForEach(\"users\"):\n            with Card():\n                CardTitle(\"{{ name }}\")\n\n        # With data={\"users\": [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]}\n        # renders two Cards.\n    \"\"\"\n\n    type: Literal[\"ForEach\"] = \"ForEach\"\n    key: str = Field(description=\"Data field containing the list to iterate over\")\n\n    @overload\n    def __init__(self, key: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, key: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, key: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept key as positional or keyword argument.\"\"\"\n        if key is not None:\n            kwargs[\"key\"] = key\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/form.py": "\"\"\"Form component with Pydantic model integration.\n\nForms group inputs with labels. The ``from_model()`` classmethod generates\na complete form from a Pydantic model's field definitions, using Pydantic\n``Field()`` metadata for labels, descriptions, constraints, and UI hints.\n\nExample::\n\n    from pydantic import BaseModel, Field\n    from prefab_ui.components import Form\n\n    class UserProfile(BaseModel):\n        name: str = Field(title=\"Full Name\", min_length=1)\n        email: str\n        age: int = Field(ge=0, le=150)\n        active: bool = True\n\n    Form.from_model(UserProfile, on_submit=ToolCall(\"save_profile\"))\n\"\"\"\n\nfrom __future__ import annotations\n\nimport datetime\nimport types\nfrom typing import Any, Literal, Union, get_args, get_origin, overload\n\nimport annotated_types\nfrom pydantic import BaseModel, Field, SecretStr\nfrom pydantic.fields import FieldInfo\nfrom pydantic_core import PydanticUndefined\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.actions.mcp import ToolCall\nfrom prefab_ui.actions.ui import ShowToast\nfrom prefab_ui.components.base import (\n    ContainerComponent,\n    _compile_layout_classes,\n    _merge_css_classes,\n)\n\n\nclass Form(ContainerComponent):\n    \"\"\"Form container that groups labeled inputs.\n\n    Use ``Form.from_model()`` to auto-generate a form from a Pydantic model,\n    or build forms manually with context-manager syntax.\n\n    Example::\n\n        with Form():\n            Label(\"Name\")\n            Input(name=\"name\", placeholder=\"Your name\")\n            Button(\"Submit\", on_click=ToolCall(\"save\"))\n    \"\"\"\n\n    type: Literal[\"Form\"] = \"Form\"\n    gap: int = Field(default=4, exclude=True)\n    on_submit: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onSubmit\",\n        description=\"Action(s) to execute when the form is submitted\",\n    )\n\n    def model_post_init(self, __context: Any) -> None:\n        layout = _compile_layout_classes(gap=self.gap)\n        self.css_class = _merge_css_classes(layout, self.css_class)\n        super().model_post_init(__context)\n\n    @overload\n    @classmethod\n    def from_model(\n        cls,\n        model: type[BaseModel],\n        *,\n        fields_only: Literal[True],\n        submit_label: str = \"Submit\",\n        on_submit: Action | list[Action] | None = None,\n        css_class: str | None = None,\n    ) -> list[Any]: ...\n\n    @overload\n    @classmethod\n    def from_model(\n        cls,\n        model: type[BaseModel],\n        *,\n        fields_only: Literal[False] = ...,\n        submit_label: str = \"Submit\",\n        on_submit: Action | list[Action] | None = None,\n        css_class: str | None = None,\n    ) -> Form: ...\n\n    @classmethod\n    def from_model(\n        cls,\n        model: type[BaseModel],\n        *,\n        fields_only: bool = False,\n        submit_label: str = \"Submit\",\n        on_submit: Action | list[Action] | None = None,\n        css_class: str | None = None,\n    ) -> Form | list[Any]:\n        \"\"\"Generate a form from a Pydantic model.\n\n        Introspects the model's fields and creates appropriate input\n        components for each, using Pydantic ``Field()`` metadata:\n\n        - ``title`` → label text (falls back to humanized field name)\n        - ``description`` → placeholder / help text\n        - ``min_length`` / ``max_length`` → HTML input constraints\n        - ``ge`` / ``le`` / ``gt`` / ``lt`` → number min/max\n        - ``json_schema_extra={\"ui\": {\"type\": \"textarea\"}}`` → textarea\n        - ``SecretStr`` → password input\n        - ``exclude=True`` → skip field\n\n        Type mapping:\n\n        - ``str`` → text input (email/password/tel/url detected by name)\n        - ``int`` / ``float`` → number input\n        - ``bool`` → checkbox\n        - ``datetime.date`` → date input\n        - ``datetime.time`` → time input\n        - ``datetime.datetime`` → datetime-local input\n        - ``Literal[...]`` → select dropdown\n        - ``SecretStr`` → password input\n\n        When ``on_submit`` is a single ``ToolCall`` with no ``arguments``,\n        arguments are auto-filled from the model's fields under a ``data``\n        key. This enables the self-calling tool pattern::\n\n            Form.from_model(Contact, on_submit=ToolCall(\"create_contact\"))\n            # auto-generates: arguments={\"data\": {\"name\": \"{{ name }}\", ...}}\n\n        A default ``on_error`` toast is added if not already specified.\n\n        When ``fields_only=True``, only the field components (labeled\n        inputs) are created — no ``Form`` wrapper and no submit button.\n        The fields auto-parent to whatever context manager is active,\n        letting you compose them into custom layouts::\n\n            with Form(on_submit=ToolCall(\"save\")):\n                with CardContent():\n                    Form.from_model(Contact, fields_only=True)\n                with CardFooter():\n                    Button(\"Submit\")\n\n        Args:\n            model: Pydantic model class to generate from.\n            fields_only: If True, generate only field components without\n                a Form wrapper or submit button. Returns a list of the\n                created components.\n            submit_label: Text for the submit button.\n            on_submit: Action(s) fired on submit. A ``ToolCall`` with no\n                arguments gets auto-filled from model fields.\n            css_class: Additional CSS classes on the form container.\n        \"\"\"\n        from prefab_ui.components.base import _component_stack\n        from prefab_ui.components.button import Button\n\n        if fields_only:\n            # Suppress the stack during creation to avoid duplicates\n            # (Labels/Inputs would otherwise auto-parent to both the\n            # Column AND the outer context). Then manually add the\n            # top-level field components to the active context.\n            saved_stack = _component_stack.get()\n            _component_stack.set(None)\n            try:\n                children: list[Any] = []\n                for name, field_info in model.model_fields.items():\n                    component = _field_to_component(name, field_info)\n                    if component is not None:\n                        children.append(component)\n            finally:\n                _component_stack.set(saved_stack)\n\n            if saved_stack:\n                for child in children:\n                    saved_stack[-1].children.append(child)\n\n            return children\n\n        on_submit = _maybe_enrich_tool_call(on_submit, model)\n\n        # Form is created with the stack active so it auto-parents to any\n        # outer context manager (e.g. ``with Card(): Form.from_model(...)``).\n        form = cls(on_submit=on_submit, css_class=css_class)\n\n        # Suppress the stack while building internal components so they\n        # don't also get auto-added to the outer container.\n        saved_stack = _component_stack.get()\n        _component_stack.set(None)\n        try:\n            children = []\n\n            for name, field_info in model.model_fields.items():\n                component = _field_to_component(name, field_info)\n                if component is not None:\n                    children.append(component)\n\n            if on_submit is not None:\n                children.append(Button(submit_label, on_click=on_submit))\n        finally:\n            _component_stack.set(saved_stack)\n\n        form.children = children\n        return form\n\n\ndef _maybe_enrich_tool_call(\n    on_submit: Action | list[Action] | None,\n    model: type[BaseModel],\n) -> Action | list[Action] | None:\n    \"\"\"Auto-fill ToolCall arguments from model fields when empty.\n\n    Only triggers when on_submit is a single ToolCall with no arguments.\n    Wraps field templates under a ``data`` key so the receiving tool gets\n    ``data: Model`` as a single parameter.\n    \"\"\"\n    if not isinstance(on_submit, ToolCall):\n        return on_submit\n    if on_submit.arguments:\n        return on_submit\n\n    field_templates = {\n        name: \"{{ \" + name + \" }}\"\n        for name in model.model_fields\n        if not (model.model_fields[name].exclude)\n    }\n\n    kwargs: dict[str, Any] = {\n        \"tool\": on_submit.tool,\n        \"arguments\": {\"data\": field_templates},\n    }\n    if on_submit.result_key is not None:\n        kwargs[\"result_key\"] = on_submit.result_key\n    if on_submit.on_success is not None:\n        kwargs[\"on_success\"] = on_submit.on_success\n    if on_submit.on_error is not None:\n        kwargs[\"on_error\"] = on_submit.on_error\n    else:\n        kwargs[\"on_error\"] = ShowToast(\"{{ $error }}\", variant=\"error\")\n\n    return ToolCall(**kwargs)\n\n\ndef _humanize(name: str) -> str:\n    \"\"\"Convert snake_case field name to Title Case label.\"\"\"\n    return name.replace(\"_\", \" \").title()\n\n\ndef _unwrap_optional(annotation: Any) -> tuple[Any, bool]:\n    \"\"\"Strip Optional/Union[X, None] wrapper, returning (inner_type, is_optional).\"\"\"\n    origin = get_origin(annotation)\n    if origin is Union or origin is types.UnionType:\n        args = [a for a in get_args(annotation) if a is not type(None)]\n        if len(args) == 1:\n            return args[0], True\n    return annotation, False\n\n\ndef _is_literal(annotation: Any) -> bool:\n    return get_origin(annotation) is Literal\n\n\ndef _extract_constraints(field_info: FieldInfo) -> dict[str, Any]:\n    \"\"\"Extract numeric and string constraints from Pydantic field metadata.\"\"\"\n    constraints: dict[str, Any] = {}\n    for meta in field_info.metadata:\n        if isinstance(meta, annotated_types.MinLen):\n            constraints[\"min_length\"] = meta.min_length\n        elif isinstance(meta, annotated_types.MaxLen):\n            constraints[\"max_length\"] = meta.max_length\n        elif isinstance(meta, annotated_types.Ge):\n            constraints[\"min\"] = meta.ge\n        elif isinstance(meta, annotated_types.Le):\n            constraints[\"max\"] = meta.le\n        elif isinstance(meta, annotated_types.Gt):\n            constraints[\"min\"] = meta.gt\n        elif isinstance(meta, annotated_types.Lt):\n            constraints[\"max\"] = meta.lt\n        elif isinstance(meta, annotated_types.MultipleOf):\n            constraints[\"step\"] = meta.multiple_of\n        elif hasattr(meta, \"pattern\") and not isinstance(meta, type):\n            constraints[\"pattern\"] = meta.pattern\n    return constraints\n\n\ndef _get_ui_hints(field_info: FieldInfo) -> dict[str, Any]:\n    \"\"\"Extract UI hints from json_schema_extra.\"\"\"\n    extra = field_info.json_schema_extra\n    if isinstance(extra, dict):\n        ui = extra.get(\"ui\")  # type: ignore[union-attr]\n        if isinstance(ui, dict):\n            return ui\n    return {}\n\n\ndef _field_to_component(name: str, field_info: FieldInfo) -> Any:\n    \"\"\"Map a single Pydantic field to the appropriate form component(s).\"\"\"\n    from prefab_ui.components.checkbox import Checkbox\n    from prefab_ui.components.column import Column\n    from prefab_ui.components.input import Input\n    from prefab_ui.components.label import Label\n    from prefab_ui.components.select import Select, SelectOption\n    from prefab_ui.components.textarea import Textarea\n\n    annotation = field_info.annotation\n    if annotation is None:\n        return None\n\n    if field_info.exclude:\n        return None\n\n    inner, is_optional = _unwrap_optional(annotation)\n    required = not is_optional and field_info.is_required()\n\n    label_text = field_info.title or _humanize(name)\n    placeholder = field_info.description or label_text\n    default = (\n        field_info.default if field_info.default is not PydanticUndefined else None\n    )\n    constraints = _extract_constraints(field_info)\n    ui_hints = _get_ui_hints(field_info)\n\n    # UI hint override: textarea\n    if ui_hints.get(\"type\") == \"textarea\":\n        rows = ui_hints.get(\"rows\")\n        value = str(default) if isinstance(default, str) else None\n        col = Column(gap=2)\n        col.children = [\n            Label(label_text),\n            Textarea(\n                name=name,\n                placeholder=placeholder,\n                value=value,\n                rows=rows,\n                required=required,\n                min_length=constraints.get(\"min_length\"),\n                max_length=constraints.get(\"max_length\"),\n            ),\n        ]\n        return col\n\n    # Literal → Select dropdown\n    if _is_literal(inner):\n        options = get_args(inner)\n        select = Select(name=name, placeholder=placeholder, required=required)\n        for opt in options:\n            opt_str = str(opt)\n            select.children.append(\n                SelectOption(\n                    value=opt_str,\n                    label=_humanize(opt_str),\n                    selected=default == opt,\n                )\n            )\n        col = Column(gap=2)\n        col.children = [Label(label_text), select]\n        return col\n\n    # bool → Checkbox\n    if inner is bool:\n        checked = bool(default) if default is not None else False\n        return Checkbox(label=label_text, name=name, checked=checked)\n\n    # SecretStr → password input\n    if inner is SecretStr:\n        col = Column(gap=2)\n        col.children = [\n            Label(label_text),\n            Input(\n                input_type=\"password\",\n                name=name,\n                placeholder=placeholder,\n                required=required,\n                min_length=constraints.get(\"min_length\"),\n                max_length=constraints.get(\"max_length\"),\n            ),\n        ]\n        return col\n\n    # date/time types → specialized input\n    if inner is datetime.date:\n        col = Column(gap=2)\n        col.children = [\n            Label(label_text),\n            Input(input_type=\"date\", name=name, required=required),\n        ]\n        return col\n\n    if inner is datetime.time:\n        col = Column(gap=2)\n        col.children = [\n            Label(label_text),\n            Input(input_type=\"time\", name=name, required=required),\n        ]\n        return col\n\n    if inner is datetime.datetime:\n        col = Column(gap=2)\n        col.children = [\n            Label(label_text),\n            Input(input_type=\"datetime-local\", name=name, required=required),\n        ]\n        return col\n\n    # int / float → number input\n    if inner in (int, float):\n        value = str(default) if default is not None else None\n        col = Column(gap=2)\n        col.children = [\n            Label(label_text),\n            Input(\n                input_type=\"number\",\n                name=name,\n                placeholder=placeholder,\n                value=value,\n                required=required,\n                min=constraints.get(\"min\"),\n                max=constraints.get(\"max\"),\n                step=constraints.get(\"step\"),\n            ),\n        ]\n        return col\n\n    # Skip unsupported complex types (lists, dicts, nested models)\n    origin = get_origin(inner)\n    if origin in (list, dict, set, frozenset, tuple):\n        return None\n    if isinstance(inner, type) and issubclass(inner, BaseModel):\n        return None\n\n    # str (default) → text input, detect email by field name\n    input_type = \"text\"\n    if \"email\" in name.lower():\n        input_type = \"email\"\n    elif \"password\" in name.lower():\n        input_type = \"password\"\n    elif \"phone\" in name.lower() or \"tel\" in name.lower():\n        input_type = \"tel\"\n    elif \"url\" in name.lower() or \"website\" in name.lower():\n        input_type = \"url\"\n\n    value = str(default) if isinstance(default, str) else None\n    col = Column(gap=2)\n    col.children = [\n        Label(label_text),\n        Input(\n            input_type=input_type,\n            name=name,\n            placeholder=placeholder,\n            value=value,\n            required=required,\n            min_length=constraints.get(\"min_length\"),\n            max_length=constraints.get(\"max_length\"),\n            pattern=constraints.get(\"pattern\"),\n        ),\n    ]\n    return col\n",
  "prefab_ui/components/grid.py": "\"\"\"Grid layout container.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import (\n    Align,\n    ContainerComponent,\n    Gap,\n    Justify,\n    Responsive,\n    _compile_layout_classes,\n    _merge_css_classes,\n)\n\n\ndef _compile_column_template(columns: list[int | str]) -> str:\n    \"\"\"Compile a column list to a CSS grid-template-columns value.\n\n    Integers become ``Nfr`` (fractional units); strings pass through as-is.\n\n        [1, \"auto\", 1]  → \"1fr auto 1fr\"\n        [2, 1]          → \"2fr 1fr\"\n        [\"200px\", 1, 1] → \"200px 1fr 1fr\"\n    \"\"\"\n    parts: list[str] = []\n    for v in columns:\n        if isinstance(v, int):\n            parts.append(f\"{v}fr\")\n        else:\n            parts.append(v)\n    return \" \".join(parts)\n\n\nclass Grid(ContainerComponent):\n    \"\"\"Responsive CSS grid container.\n\n    Args:\n        columns: Number of columns (1-12), a list of column widths, a\n            Responsive mapping, or a dict of breakpoint→column-count.\n            Defaults to 3 equal columns. Pass a list for custom widths::\n\n                Grid(columns=[1, \"auto\", 1])  # 1fr auto 1fr\n\n            In a list, integers become fractional units (``1`` → ``1fr``)\n            and strings pass through (``\"auto\"``, ``\"200px\"``).\n        min_column_width: Minimum column width for auto-fill responsive\n            grids (e.g. ``\"16rem\"``). Mutually exclusive with *columns*.\n        gap: Gap between children: int, (x, y) tuple, or Responsive.\n        css_class: Additional CSS classes to apply.\n\n    Example::\n\n        with Grid(columns=3):\n            Card(...)\n            Card(...)\n            Card(...)\n\n        # Custom widths: sidebar + content\n        with Grid(columns=[1, 3]):\n            Sidebar(...)\n            MainContent(...)\n\n        # Responsive: 1 col on mobile, 2 on md, 3 on lg\n        with Grid(columns={\"default\": 1, \"md\": 2, \"lg\": 3}):\n            Card(...)\n\n        # Auto-fill: as many columns as fit, each ≥ 16rem\n        with Grid(min_column_width=\"16rem\"):\n            Card(...)\n    \"\"\"\n\n    type: Literal[\"Grid\"] = \"Grid\"\n    columns: int | list[int | str] | dict[str, int] | Responsive | None = Field(\n        default=None,\n        exclude=True,\n    )\n    column_template: str | None = Field(\n        default=None,\n        alias=\"columnTemplate\",\n        description=\"CSS grid-template-columns value for custom column widths.\",\n    )\n    min_column_width: str | None = Field(default=None, alias=\"minColumnWidth\")\n    gap: Gap = Field(default=None, exclude=True)\n    align: Align = Field(default=None, exclude=True)\n    justify: Justify = Field(default=None, exclude=True)\n\n    @overload\n    def __init__(self, columns: int, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(\n        self,\n        *,\n        columns: int | list[int | str] | dict[str, int] | Responsive,\n        **kwargs: Any,\n    ) -> None: ...\n\n    @overload\n    def __init__(self, *, min_column_width: str, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, **kwargs: Any) -> None: ...\n\n    def __init__(\n        self,\n        columns: int | list[int | str] | dict[str, int] | Responsive | None = None,\n        **kwargs: Any,\n    ) -> None:\n        if columns is not None:\n            kwargs[\"columns\"] = columns\n        # Default to 3 columns when neither columns nor min_column_width given\n        if columns is None and \"min_column_width\" not in kwargs:\n            kwargs.setdefault(\"columns\", 3)\n        super().__init__(**kwargs)\n\n    def model_post_init(self, __context: Any) -> None:\n        # List columns → inline style via column_template (not a Tailwind class)\n        columns_for_layout: int | dict[str, int] | Responsive | None\n        if isinstance(self.columns, list):\n            self.column_template = _compile_column_template(self.columns)\n            columns_for_layout = None\n        else:\n            columns_for_layout = self.columns\n\n        layout = _compile_layout_classes(\n            gap=self.gap,\n            columns=columns_for_layout,\n            align=self.align,\n            justify=self.justify,\n        )\n        self.css_class = _merge_css_classes(layout, self.css_class)\n        super().model_post_init(__context)\n",
  "prefab_ui/components/heading.py": "\"\"\"Heading display component.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.typography import _text_init, _TextComponent\n\n\nclass Heading(_TextComponent):\n    \"\"\"Section heading (h1-h4).\n\n    Example::\n\n        Heading(\"{{ name }}\", level=2)\n    \"\"\"\n\n    type: Literal[\"Heading\"] = \"Heading\"\n    level: Literal[1, 2, 3, 4] = Field(\n        default=1, description=\"Heading level (1=h1, 4=h4)\"\n    )\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n",
  "prefab_ui/components/icon.py": "\"\"\"Icon component for rendering lucide icons by name.\n\nUses the lucide-react icon library. Pass any icon name in kebab-case.\nBrowse available icons at https://lucide.dev/icons.\n\nExample::\n\n    from prefab_ui.components import Icon, Button\n\n    # Standalone icon\n    Icon(\"circle-alert\")\n\n    # Inside a button (renders inline)\n    with Button():\n        Icon(\"download\")\n        \"Download file\"\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\n\n\nclass Icon(Component):\n    \"\"\"Renders a lucide icon by name.\n\n    Args:\n        name: Lucide icon name in kebab-case (e.g., \"arrow-right\", \"circle-alert\")\n        size: Icon size — \"sm\" (16px), \"default\" (16px with standard spacing),\n            or \"lg\" (24px)\n\n    Example::\n\n        Icon(\"check\")\n        Icon(\"arrow-right\", size=\"lg\")\n    \"\"\"\n\n    type: Literal[\"Icon\"] = \"Icon\"\n    name: str = Field(description=\"Lucide icon name in kebab-case\")\n    size: Literal[\"sm\", \"default\", \"lg\"] = Field(\n        default=\"default\",\n        description=\"Icon size variant\",\n    )\n\n    @overload\n    def __init__(self, name: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, name: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, name: str | None = None, **kwargs: Any) -> None:\n        if name is not None and \"name\" not in kwargs:\n            kwargs[\"name\"] = name\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/image.py": "\"\"\"Image display component.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\n\n\nclass Image(Component):\n    \"\"\"Image element.\n\n    Example::\n\n        Image(src=\"{{ avatar_url }}\", alt=\"{{ name }}\")\n    \"\"\"\n\n    type: Literal[\"Image\"] = \"Image\"\n    src: str = Field(description=\"Image URL\")\n    alt: str = Field(default=\"\", description=\"Alt text\")\n    width: str | None = Field(default=None, description=\"CSS width\")\n    height: str | None = Field(default=None, description=\"CSS height\")\n",
  "prefab_ui/components/input.py": "\"\"\"Input component for text entry.\n\nText inputs with full form validation styling and dark mode support.\n\nExample::\n\n    from prefab_ui.components import Input, Label\n\n    Input(placeholder=\"Enter your name\")\n    Input(input_type=\"email\", placeholder=\"you@example.com\")\n    Input(input_type=\"password\", placeholder=\"••••••••\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component\n\nInputType = Literal[\n    \"text\",\n    \"email\",\n    \"password\",\n    \"number\",\n    \"tel\",\n    \"url\",\n    \"search\",\n    \"date\",\n    \"time\",\n    \"datetime-local\",\n    \"file\",\n]\n\n\nclass Input(Component):\n    \"\"\"Text input field component.\n\n    Args:\n        input_type: Input type (text, email, password, etc.)\n        placeholder: Placeholder text\n        value: Initial value\n        name: Form field name\n        disabled: Whether input is disabled\n        required: Whether input is required\n        css_class: Additional CSS classes\n\n    Example::\n\n        Input(placeholder=\"Search...\")\n        Input(input_type=\"email\", placeholder=\"Email\", required=True)\n        Input(input_type=\"password\", value=\"{{ user_password }}\")\n    \"\"\"\n\n    type: Literal[\"Input\"] = \"Input\"\n    input_type: InputType = Field(\n        default=\"text\",\n        alias=\"inputType\",\n        description=\"Input type (text, email, password, etc.)\",\n    )\n    placeholder: str | None = Field(\n        default=None,\n        description=\"Placeholder text\",\n    )\n    value: str | None = Field(default=None, description=\"Input value\")\n    name: str | None = Field(default=None, description=\"Form field name\")\n    disabled: bool = Field(default=False, description=\"Whether input is disabled\")\n    required: bool = Field(default=False, description=\"Whether input is required\")\n    min_length: int | None = Field(\n        default=None,\n        alias=\"minLength\",\n        description=\"Minimum character length\",\n    )\n    max_length: int | None = Field(\n        default=None,\n        alias=\"maxLength\",\n        description=\"Maximum character length\",\n    )\n    min: float | None = Field(\n        default=None, description=\"Minimum value (for number inputs)\"\n    )\n    max: float | None = Field(\n        default=None, description=\"Maximum value (for number inputs)\"\n    )\n    step: float | None = Field(\n        default=None, description=\"Step increment (for number inputs)\"\n    )\n    pattern: str | None = Field(\n        default=None, description=\"Regex pattern for validation\"\n    )\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) to execute when value changes\",\n    )\n",
  "prefab_ui/components/label.py": "\"\"\"Label component for form fields.\n\nLabels identify form inputs and provide accessible descriptions.\n\nExample::\n\n    from prefab_ui.components import Label, Input\n\n    with Label(\"Email address\"):\n        Input(placeholder=\"you@example.com\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Label(ContainerComponent):\n    \"\"\"Label element for form fields.\n\n    Args:\n        text: Label text (optional if using children)\n        for_id: ID of the associated input element\n        css_class: Additional CSS classes\n\n    Example::\n\n        Label(\"Username\")\n        Label(\"Email\", for_id=\"email-input\")\n\n        # With children\n        with Label():\n            Text(\"Password\")\n            Input(input_type=\"password\")\n    \"\"\"\n\n    type: Literal[\"Label\"] = \"Label\"\n    text: str | None = Field(default=None, description=\"Label text\")\n    for_id: str | None = Field(\n        default=None,\n        alias=\"forId\",\n        description=\"ID of the associated form field\",\n    )\n\n    @overload\n    def __init__(self, text: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, text: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, text: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept text as positional or keyword argument.\"\"\"\n        if text is not None:\n            kwargs[\"text\"] = text\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/markdown.py": "\"\"\"Markdown display component.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\n\n\nclass Markdown(Component):\n    \"\"\"Rendered markdown component.\n\n    Example::\n\n        Markdown(\"**Name:** {{ name }}\\\\n\\\\n{{ bio }}\")\n    \"\"\"\n\n    type: Literal[\"Markdown\"] = \"Markdown\"\n    content: str = Field(description=\"Markdown content\")\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        if content is not None:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/pages.py": "\"\"\"Pages component — multi-page layout driven by state.\n\nOnly the active page renders. Navigate by setting state.\n\nExample::\n\n    from prefab_ui.components import Pages, Page, Text, Button\n    from prefab_ui.actions import SetState\n\n    with Pages(name=\"page\", default_value=\"home\"):\n        with Page(\"Home\"):\n            Text(\"Welcome!\")\n            Button(\"Go to Settings\", on_click=SetState(\"page\", \"settings\"))\n        with Page(\"Settings\"):\n            Text(\"Settings go here.\")\n            Button(\"Back\", on_click=SetState(\"page\", \"home\"))\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Page(ContainerComponent):\n    \"\"\"A single page within a Pages container.\n\n    Example::\n\n        with Page(\"Settings\"):\n            Text(\"Settings content.\")\n    \"\"\"\n\n    type: Literal[\"Page\"] = \"Page\"\n    title: str = Field(description=\"Page identifier / label\")\n    value: str | None = Field(\n        default=None,\n        description=\"Unique value for this page (defaults to title)\",\n    )\n\n    @overload\n    def __init__(self, title: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, title: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, title: str | None = None, **kwargs: Any) -> None:\n        if title is not None and \"title\" not in kwargs:\n            kwargs[\"title\"] = title\n        super().__init__(**kwargs)\n\n\nclass Pages(ContainerComponent):\n    \"\"\"Multi-page layout — only the active Page renders.\n\n    Control which page shows via the state key matching ``name``.\n\n    Example::\n\n        with Pages(name=\"currentPage\", default_value=\"home\"):\n            with Page(\"Home\"):\n                Text(\"Home content\")\n            with Page(\"Settings\"):\n                Text(\"Settings content\")\n    \"\"\"\n\n    type: Literal[\"Pages\"] = \"Pages\"\n    default_value: str | None = Field(\n        default=None,\n        alias=\"defaultValue\",\n        description=\"Initially active page value\",\n    )\n    name: str | None = Field(\n        default=None,\n        description=\"State key for tracking the active page\",\n    )\n",
  "prefab_ui/components/popover.py": "\"\"\"Popover — floating content panel triggered by a child element.\n\nThe first child becomes the trigger; remaining children become the content.\n\nExample::\n\n    from prefab_ui.components import Popover, Button, Column, Label, Slider\n\n    with Popover(title=\"Settings\"):\n        Button(\"Open\")          # trigger\n        with Column(gap=3):     # content\n            Label(\"Volume\")\n            Slider(name=\"volume\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Popover(ContainerComponent):\n    \"\"\"Popover floating panel.\n\n    First child = trigger, remaining children = content.\n\n    Example::\n\n        with Popover(title=\"Options\"):\n            Button(\"Configure\")\n            with Column(gap=2):\n                Label(\"Setting\")\n                Input(name=\"value\")\n    \"\"\"\n\n    type: Literal[\"Popover\"] = \"Popover\"\n    title: str | None = Field(default=None, description=\"Optional popover header title\")\n    description: str | None = Field(\n        default=None, description=\"Optional popover description\"\n    )\n    side: Literal[\"top\", \"right\", \"bottom\", \"left\"] | None = Field(\n        default=None, description=\"Which side to show the popover\"\n    )\n",
  "prefab_ui/components/progress.py": "\"\"\"Progress bar component.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\n\n\nclass Progress(Component):\n    \"\"\"A progress bar showing completion status.\n\n    Example::\n\n        Progress(value=75)\n        Progress(value=3, max=10)\n        Progress(value=80, indicator_class=\"bg-green-500\")\n    \"\"\"\n\n    type: Literal[\"Progress\"] = \"Progress\"\n    value: float | str = Field(\n        default=0,\n        description=\"Current progress value\",\n    )\n    max: float = Field(default=100, description=\"Maximum value (progress is value/max)\")\n    indicator_class: str | None = Field(\n        default=None,\n        alias=\"indicatorClass\",\n        description=\"Tailwind classes for the indicator bar (e.g. 'bg-green-500')\",\n    )\n",
  "prefab_ui/components/radio.py": "\"\"\"Radio button components for mutually exclusive choices.\n\nRadio buttons let users select exactly one option from a set.\n\nExample::\n\n    from prefab_ui.components import RadioGroup, Radio\n\n    with RadioGroup(name=\"size\"):\n        Radio(value=\"sm\", label=\"Small\")\n        Radio(value=\"md\", label=\"Medium\", checked=True)\n        Radio(value=\"lg\", label=\"Large\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component, ContainerComponent\n\n\nclass RadioGroup(ContainerComponent):\n    \"\"\"Container for radio button options.\n\n    Args:\n        name: Form field name (shared by all radios in group)\n        css_class: Additional CSS classes\n\n    Example::\n\n        with RadioGroup(name=\"theme\"):\n            Radio(value=\"light\", label=\"Light\")\n            Radio(value=\"dark\", label=\"Dark\")\n    \"\"\"\n\n    type: Literal[\"RadioGroup\"] = \"RadioGroup\"\n    name: str | None = Field(default=None, description=\"Form field name for all radios\")\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) to execute when selection changes\",\n    )\n\n\nclass Radio(Component):\n    \"\"\"Radio button input component.\n\n    Args:\n        value: Form value for this option\n        label: Label text to display\n        checked: Whether radio is initially selected\n        name: Form field name (usually set by RadioGroup)\n        disabled: Whether radio is disabled\n        required: Whether radio is required\n        css_class: Additional CSS classes\n\n    Example::\n\n        Radio(value=\"yes\", label=\"Yes\")\n        Radio(value=\"no\", label=\"No\", checked=True)\n    \"\"\"\n\n    type: Literal[\"Radio\"] = \"Radio\"\n    value: str = Field(description=\"Form value\")\n    label: str | None = Field(default=None, description=\"Label text\")\n    checked: bool = Field(default=False, description=\"Whether radio is selected\")\n    name: str | None = Field(default=None, description=\"Form field name\")\n    disabled: bool = Field(default=False, description=\"Whether radio is disabled\")\n    required: bool = Field(default=False, description=\"Whether radio is required\")\n",
  "prefab_ui/components/row.py": "\"\"\"Row layout container.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import (\n    Align,\n    ContainerComponent,\n    Gap,\n    Justify,\n    _compile_layout_classes,\n    _merge_css_classes,\n)\n\n\nclass Row(ContainerComponent):\n    \"\"\"Horizontal flex container.\n\n    Example::\n\n        with Row():\n            Text(\"Left\")\n            Text(\"Right\")\n\n        with Row(gap=4, align=\"center\"):\n            Icon(\"check\")\n            Text(\"Confirmed\")\n    \"\"\"\n\n    type: Literal[\"Row\"] = \"Row\"\n    gap: Gap = Field(default=None, exclude=True)\n    align: Align = Field(default=None, exclude=True)\n    justify: Justify = Field(default=None, exclude=True)\n\n    def model_post_init(self, __context: Any) -> None:\n        layout = _compile_layout_classes(\n            gap=self.gap, align=self.align, justify=self.justify\n        )\n        self.css_class = _merge_css_classes(layout, self.css_class)\n        super().model_post_init(__context)\n",
  "prefab_ui/components/select.py": "\"\"\"Select component for dropdown choices.\n\nSelect dropdowns let users pick from a list of options.\n\nExample::\n\n    from prefab_ui.components import Select, SelectOption\n\n    with Select(placeholder=\"Choose size...\"):\n        SelectOption(value=\"sm\", label=\"Small\")\n        SelectOption(value=\"md\", label=\"Medium\")\n        SelectOption(value=\"lg\", label=\"Large\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component, ContainerComponent\n\nSelectSize = Literal[\"sm\", \"default\"]\n\n\nclass Select(ContainerComponent):\n    \"\"\"Select dropdown container.\n\n    Args:\n        placeholder: Placeholder text when no option selected\n        name: Form field name\n        size: Select size (\"sm\" or \"default\")\n        disabled: Whether select is disabled\n        required: Whether select is required\n        css_class: Additional CSS classes\n\n    Example::\n\n        with Select(placeholder=\"Pick one...\", name=\"choice\"):\n            SelectOption(value=\"a\", label=\"Option A\")\n            SelectOption(value=\"b\", label=\"Option B\")\n    \"\"\"\n\n    type: Literal[\"Select\"] = \"Select\"\n    placeholder: str | None = Field(\n        default=None,\n        description=\"Placeholder text\",\n    )\n    name: str | None = Field(default=None, description=\"Form field name\")\n    size: SelectSize = Field(default=\"default\", description=\"Select size (sm, default)\")\n    disabled: bool = Field(default=False, description=\"Whether select is disabled\")\n    required: bool = Field(default=False, description=\"Whether select is required\")\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) to execute when selection changes\",\n    )\n\n\nclass SelectOption(Component):\n    \"\"\"Select dropdown option.\n\n    Args:\n        value: Option value\n        label: Display text\n        selected: Whether option is initially selected\n        disabled: Whether option is disabled\n        css_class: Additional CSS classes\n\n    Example::\n\n        SelectOption(value=\"yes\", label=\"Yes\")\n        SelectOption(value=\"no\", label=\"No\", selected=True)\n    \"\"\"\n\n    type: Literal[\"SelectOption\"] = \"SelectOption\"\n    value: str = Field(description=\"Option value\")\n    label: str = Field(description=\"Display text\")\n    selected: bool = Field(default=False, description=\"Whether option is selected\")\n    disabled: bool = Field(default=False, description=\"Whether option is disabled\")\n\n    @overload\n    def __init__(self, label: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, label: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, label: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept label as positional or keyword argument.\"\"\"\n        if label is not None:\n            kwargs[\"label\"] = label\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/separator.py": "\"\"\"Separator component for visual dividers.\n\nSeparators create visual divisions between content sections.\n\nExample::\n\n    from prefab_ui.components import Separator\n\n    Separator()\n    Separator(orientation=\"vertical\")\n    Separator(spacing=4)\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component, _merge_css_classes\n\nSeparatorOrientation = Literal[\"horizontal\", \"vertical\"]\n\n\nclass Separator(Component):\n    \"\"\"Visual divider component.\n\n    Args:\n        orientation: Separator direction (horizontal or vertical)\n        spacing: Space around the separator (Tailwind spacing scale).\n            Adds vertical margin for horizontal separators and horizontal\n            margin for vertical separators.\n        css_class: Additional CSS classes\n\n    Example::\n\n        Separator()  # Horizontal by default\n        Separator(orientation=\"vertical\")\n        Separator(spacing=4)  # Extra breathing room\n    \"\"\"\n\n    type: Literal[\"Separator\"] = \"Separator\"\n    orientation: SeparatorOrientation = Field(\n        default=\"horizontal\", description=\"Separator orientation\"\n    )\n    spacing: int | None = Field(\n        default=None,\n        exclude=True,\n        description=\"Space around the separator (Tailwind spacing scale)\",\n    )\n\n    def model_post_init(self, __context: Any) -> None:\n        if self.spacing is not None:\n            direction = \"mx\" if self.orientation == \"vertical\" else \"my\"\n            self.css_class = _merge_css_classes(\n                f\"{direction}-{self.spacing}\", self.css_class\n            )\n        super().model_post_init(__context)\n",
  "prefab_ui/components/slider.py": "\"\"\"Slider component for range input.\n\nSliders let users select a numeric value from a range.\n\nExample::\n\n    from prefab_ui.components import Slider\n\n    Slider(min=0, max=100, value=50)\n    Slider(min=0, max=10, step=0.5, value=5)\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component\n\n\nclass Slider(Component):\n    \"\"\"Range slider input component.\n\n    Args:\n        min: Minimum value\n        max: Maximum value\n        value: Initial value\n        step: Step increment\n        name: Form field name\n        disabled: Whether slider is disabled\n        css_class: Additional CSS classes\n\n    Example::\n\n        Slider(min=0, max=100, value=50)\n        Slider(min=0, max=1, step=0.1, value=0.5)\n    \"\"\"\n\n    type: Literal[\"Slider\"] = \"Slider\"\n    min: float = Field(default=0, description=\"Minimum value\")\n    max: float = Field(default=100, description=\"Maximum value\")\n    value: float | None = Field(default=None, description=\"Initial value\")\n    step: float | None = Field(default=None, description=\"Step increment\")\n    name: str | None = Field(default=None, description=\"Form field name\")\n    disabled: bool = Field(default=False, description=\"Whether slider is disabled\")\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) to execute when value changes\",\n    )\n",
  "prefab_ui/components/slot.py": "\"\"\"Dynamic view slot — renders a component tree from state.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Slot(ContainerComponent):\n    \"\"\"Render a component tree stored in state.\n\n    ``Slot`` is a named placeholder in your layout. When the state key\n    contains a component tree, Slot renders it. When the state key is\n    empty, Slot renders its children as fallback content::\n\n        with Slot(\"detail_view\"):\n            Text(\"Select an item to see details\")\n\n    The slot content is typically populated by an action with\n    ``result_key``::\n\n        Button(\n            \"Load Details\",\n            on_click=ToolCall(\"get_detail\", result_key=\"detail_view\"),\n        )\n    \"\"\"\n\n    type: Literal[\"Slot\"] = \"Slot\"\n    name: str = Field(description=\"State key containing the component tree to render.\")\n\n    def __init__(self, name: str, **kwargs: Any) -> None:\n        kwargs[\"name\"] = name\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/spinner.py": "\"\"\"Spinner loading indicator.\n\nExample::\n\n    from prefab_ui.components import Spinner\n\n    Spinner()\n    Spinner(size=\"lg\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\n\n\nclass Spinner(Component):\n    \"\"\"Animated loading spinner.\n\n    Args:\n        size: Spinner size — \"sm\", \"default\", or \"lg\"\n\n    Example::\n\n        Spinner()\n        Spinner(size=\"lg\")\n    \"\"\"\n\n    type: Literal[\"Spinner\"] = \"Spinner\"\n    size: Literal[\"sm\", \"default\", \"lg\"] = Field(\n        default=\"default\",\n        description=\"Spinner size variant\",\n    )\n",
  "prefab_ui/components/switch.py": "\"\"\"Switch component for toggle controls.\n\nSwitches provide an alternative to checkboxes for on/off states.\n\nExample::\n\n    from prefab_ui.components import Switch\n\n    Switch(label=\"Enable notifications\", checked=True)\n    Switch(label=\"Dark mode\", size=\"sm\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component\n\nSwitchSize = Literal[\"sm\", \"default\"]\n\n\nclass Switch(Component):\n    \"\"\"Toggle switch component.\n\n    Args:\n        label: Label text to display next to switch\n        checked: Whether switch is on\n        size: Switch size (\"sm\" or \"default\")\n        name: Form field name\n        disabled: Whether switch is disabled\n        required: Whether switch is required\n        css_class: Additional CSS classes\n\n    Example::\n\n        Switch(label=\"Enabled\")\n        Switch(checked=True, label=\"Active\", size=\"sm\")\n    \"\"\"\n\n    type: Literal[\"Switch\"] = \"Switch\"\n    label: str | None = Field(default=None, description=\"Label text\")\n    checked: bool = Field(default=False, description=\"Whether switch is on\")\n    size: SwitchSize = Field(default=\"default\", description=\"Switch size (sm, default)\")\n    name: str | None = Field(default=None, description=\"Form field name\")\n    disabled: bool = Field(default=False, description=\"Whether switch is disabled\")\n    required: bool = Field(default=False, description=\"Whether switch is required\")\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) to execute when toggled\",\n    )\n",
  "prefab_ui/components/table.py": "\"\"\"Table components following shadcn/ui conventions.\n\nTables display structured data in rows and columns.\n\nExample::\n\n    from prefab_ui.components import (\n        Table, TableHeader, TableBody, TableRow, TableHead, TableCell, TableCaption\n    )\n\n    with Table():\n        TableCaption(\"Recent orders\")\n        with TableHeader():\n            with TableRow():\n                TableHead(\"Order\")\n                TableHead(\"Status\")\n                TableHead(\"Amount\")\n        with TableBody():\n            with TableRow():\n                TableCell(\"ORD-001\")\n                TableCell(\"Shipped\")\n                TableCell(\"$250.00\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component, ContainerComponent\n\n\nclass Table(ContainerComponent):\n    \"\"\"Table container.\n\n    Use TableHeader, TableBody, TableRow, TableHead, and TableCell to build\n    structured table layouts.\n    \"\"\"\n\n    type: Literal[\"Table\"] = \"Table\"\n\n\nclass TableHeader(ContainerComponent):\n    \"\"\"Table header section containing header rows.\"\"\"\n\n    type: Literal[\"TableHeader\"] = \"TableHeader\"\n\n\nclass TableBody(ContainerComponent):\n    \"\"\"Table body section containing data rows.\"\"\"\n\n    type: Literal[\"TableBody\"] = \"TableBody\"\n\n\nclass TableFooter(ContainerComponent):\n    \"\"\"Table footer section.\"\"\"\n\n    type: Literal[\"TableFooter\"] = \"TableFooter\"\n\n\nclass TableRow(ContainerComponent):\n    \"\"\"A single table row containing cells.\"\"\"\n\n    type: Literal[\"TableRow\"] = \"TableRow\"\n\n\nclass TableHead(ContainerComponent):\n    \"\"\"A header cell within a TableRow.\n\n    Example::\n\n        TableHead(\"Name\")\n    \"\"\"\n\n    type: Literal[\"TableHead\"] = \"TableHead\"\n    content: str | None = Field(\n        default=None,\n        description=\"Header text (alternative to children)\",\n    )\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str | None = None, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        if content is not None and \"content\" not in kwargs:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n\n\nclass TableCell(ContainerComponent):\n    \"\"\"A data cell within a TableRow.\n\n    Can contain text or arbitrary child components.\n\n    Example::\n\n        TableCell(\"$250.00\")\n        # or with children:\n        with TableCell():\n            Badge(\"Active\", variant=\"success\")\n    \"\"\"\n\n    type: Literal[\"TableCell\"] = \"TableCell\"\n    content: str | None = Field(\n        default=None,\n        description=\"Cell text (alternative to children)\",\n    )\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str | None = None, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        if content is not None and \"content\" not in kwargs:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n\n\nclass TableCaption(Component):\n    \"\"\"Table caption text.\n\n    Example::\n\n        TableCaption(\"A list of recent invoices\")\n    \"\"\"\n\n    type: Literal[\"TableCaption\"] = \"TableCaption\"\n    content: str = Field(description=\"Caption text\")\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        if content is not None and \"content\" not in kwargs:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/tabs.py": "\"\"\"Tabs component for switching between panels of content.\n\nExample::\n\n    from prefab_ui.components import Tabs, Tab, Text\n\n    with Tabs(default_value=\"general\"):\n        with Tab(\"General\"):\n            Text(\"General settings here.\")\n        with Tab(\"Advanced\"):\n            Text(\"Advanced settings here.\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import ContainerComponent\n\nTabsVariant = Literal[\"default\", \"line\"]\n\n\nclass Tab(ContainerComponent):\n    \"\"\"A single tab panel within a Tabs container.\n\n    The ``title`` appears in the tab trigger; children are the panel content.\n\n    Example::\n\n        with Tab(\"Settings\"):\n            Text(\"Content shown when this tab is active.\")\n    \"\"\"\n\n    type: Literal[\"Tab\"] = \"Tab\"\n    title: str = Field(description=\"Tab trigger label\")\n    value: str | None = Field(\n        default=None,\n        description=\"Unique value for this tab (defaults to title)\",\n    )\n    disabled: bool = Field(default=False, description=\"Disable this tab\")\n\n    @overload\n    def __init__(self, title: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, title: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, title: str | None = None, **kwargs: Any) -> None:\n        if title is not None and \"title\" not in kwargs:\n            kwargs[\"title\"] = title\n        super().__init__(**kwargs)\n\n\nclass Tabs(ContainerComponent):\n    \"\"\"Tab container — children must be ``Tab`` components.\n\n    Example::\n\n        with Tabs(default_value=\"general\"):\n            with Tab(\"General\"):\n                Text(\"General settings\")\n            with Tab(\"Advanced\"):\n                Text(\"Advanced settings\")\n    \"\"\"\n\n    type: Literal[\"Tabs\"] = \"Tabs\"\n    variant: TabsVariant = Field(\n        default=\"default\",\n        description=\"Visual style — 'default' (pill) or 'line' (underline)\",\n    )\n    default_value: str | None = Field(\n        default=None,\n        alias=\"defaultValue\",\n        description=\"Value of the initially active tab\",\n    )\n    name: str | None = Field(\n        default=None,\n        description=\"State key for tracking the active tab\",\n    )\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) when the active tab changes\",\n    )\n",
  "prefab_ui/components/text.py": "\"\"\"Text display component.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom prefab_ui.components.typography import _text_init, _TextComponent\n\n\nclass Text(_TextComponent):\n    \"\"\"Body text component.\n\n    Example::\n\n        Text(\"Hello, {{ name }}!\")\n    \"\"\"\n\n    type: Literal[\"Text\"] = \"Text\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n",
  "prefab_ui/components/textarea.py": "\"\"\"Textarea component for multi-line text entry.\n\nMulti-line text inputs with auto-sizing and form validation styling.\n\nExample::\n\n    from prefab_ui.components import Textarea, Label\n\n    Textarea(placeholder=\"Enter your message...\")\n    Textarea(rows=5, placeholder=\"Feedback\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component\n\n\nclass Textarea(Component):\n    \"\"\"Multi-line text input component.\n\n    Args:\n        placeholder: Placeholder text\n        value: Initial value\n        name: Form field name\n        rows: Number of visible text rows\n        disabled: Whether textarea is disabled\n        required: Whether textarea is required\n        css_class: Additional CSS classes\n\n    Example::\n\n        Textarea(placeholder=\"Write something...\")\n        Textarea(rows=10, value=\"{{ comment_text }}\")\n    \"\"\"\n\n    type: Literal[\"Textarea\"] = \"Textarea\"\n    placeholder: str | None = Field(\n        default=None,\n        description=\"Placeholder text\",\n    )\n    value: str | None = Field(default=None, description=\"Textarea value\")\n    name: str | None = Field(default=None, description=\"Form field name\")\n    rows: int | None = Field(default=None, description=\"Number of visible text rows\")\n    disabled: bool = Field(default=False, description=\"Whether textarea is disabled\")\n    required: bool = Field(default=False, description=\"Whether textarea is required\")\n    min_length: int | None = Field(\n        default=None,\n        alias=\"minLength\",\n        description=\"Minimum character length\",\n    )\n    max_length: int | None = Field(\n        default=None,\n        alias=\"maxLength\",\n        description=\"Maximum character length\",\n    )\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) to execute when value changes\",\n    )\n",
  "prefab_ui/components/tooltip.py": "\"\"\"Tooltip — hover text on any component.\n\nExample::\n\n    from prefab_ui.components import Tooltip, Button\n\n    with Tooltip(\"Click to save your changes\"):\n        Button(\"Save\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Tooltip(ContainerComponent):\n    \"\"\"Tooltip that appears on hover over its child.\n\n    Wrap any single component to show tooltip text on hover.\n\n    Example::\n\n        with Tooltip(\"Saves the current document\"):\n            Button(\"Save\")\n    \"\"\"\n\n    type: Literal[\"Tooltip\"] = \"Tooltip\"\n    content: str = Field(description=\"Tooltip text\")\n    side: Literal[\"top\", \"right\", \"bottom\", \"left\"] | None = Field(\n        default=None, description=\"Which side to show the tooltip\"\n    )\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        if content is not None and \"content\" not in kwargs:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/typography.py": "\"\"\"Typography components following shadcn/ui conventions.\n\nThese components provide semantic text styling with automatic dark mode support.\nExample::\n\n    from prefab_ui.components import H1, H2, P, Muted, Lead\n\n    H1(\"Dashboard\")\n    H2(\"User Profile\")\n    P(\"Welcome to the application.\")\n    Muted(\"Last updated 5 minutes ago\")\n    Lead(\"A comprehensive guide to getting started.\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component, _merge_css_classes\n\nTextAlign = Literal[\"left\", \"center\", \"right\", \"justify\"] | None\n\n\nclass _TextComponent(Component):\n    \"\"\"Base class for text components that accept positional content.\"\"\"\n\n    content: str = Field(description=\"Text content\")\n    bold: bool | None = Field(default=None, description=\"Render text in bold\")\n    italic: bool | None = Field(default=None, description=\"Render text in italic\")\n    align: TextAlign = Field(default=None, exclude=True)\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept content as positional or keyword argument.\"\"\"\n        if content is not None:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n\n    def model_post_init(self, __context: Any) -> None:\n        if self.align is not None:\n            self.css_class = _merge_css_classes(f\"text-{self.align}\", self.css_class)\n        super().model_post_init(__context)\n\n\ndef _text_init(self: _TextComponent, content: str | None = None, **kwargs: Any) -> None:\n    \"\"\"Shared init implementation for text components.\"\"\"\n    if content is not None:\n        kwargs[\"content\"] = content\n    Component.__init__(self, **kwargs)\n\n\nclass H1(_TextComponent):\n    \"\"\"Large page heading (h1).\n\n    Example::\n\n        H1(\"Dashboard\")\n        H1(\"{{ title }}\")  # With interpolation\n    \"\"\"\n\n    type: Literal[\"H1\"] = \"H1\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass H2(_TextComponent):\n    \"\"\"Section heading (h2).\n\n    Example::\n\n        H2(\"User Settings\")\n        H2(\"{{ section_name }}\")\n    \"\"\"\n\n    type: Literal[\"H2\"] = \"H2\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass H3(_TextComponent):\n    \"\"\"Subsection heading (h3).\n\n    Example::\n\n        H3(\"Account Details\")\n    \"\"\"\n\n    type: Literal[\"H3\"] = \"H3\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass H4(_TextComponent):\n    \"\"\"Small heading (h4).\n\n    Example::\n\n        H4(\"Additional Options\")\n    \"\"\"\n\n    type: Literal[\"H4\"] = \"H4\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass P(_TextComponent):\n    \"\"\"Paragraph text.\n\n    Example::\n\n        P(\"Welcome to the application.\")\n        P(\"Hello, {{ name }}!\")\n    \"\"\"\n\n    type: Literal[\"P\"] = \"P\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass Lead(_TextComponent):\n    \"\"\"Lead paragraph with larger text for introductions.\n\n    Example::\n\n        Lead(\"A comprehensive guide to building MCP applications.\")\n    \"\"\"\n\n    type: Literal[\"Lead\"] = \"Lead\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass Large(_TextComponent):\n    \"\"\"Large text for emphasis.\n\n    Example::\n\n        Large(\"Important information\")\n    \"\"\"\n\n    type: Literal[\"Large\"] = \"Large\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass Small(_TextComponent):\n    \"\"\"Small text for fine print or metadata.\n\n    Example::\n\n        Small(\"Terms and conditions apply\")\n    \"\"\"\n\n    type: Literal[\"Small\"] = \"Small\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass Muted(_TextComponent):\n    \"\"\"Muted/secondary text for less prominent information.\n\n    Example::\n\n        Muted(\"Last updated 5 minutes ago\")\n        Muted(\"{{ subtitle }}\")\n    \"\"\"\n\n    type: Literal[\"Muted\"] = \"Muted\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass BlockQuote(_TextComponent):\n    \"\"\"Block quotation.\n\n    Example::\n\n        BlockQuote(\"The best way to predict the future is to invent it.\")\n    \"\"\"\n\n    type: Literal[\"BlockQuote\"] = \"BlockQuote\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass InlineCode(_TextComponent):\n    \"\"\"Inline code snippet.\n\n    Example::\n\n        InlineCode(\"npm install\")\n        InlineCode(\"{{ command }}\")\n    \"\"\"\n\n    type: Literal[\"InlineCode\"] = \"InlineCode\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n",
  "prefab_ui/actions/__init__.py": "\"\"\"Declarative actions for interactive Prefab components.\n\nActions define what happens when a user interacts with a component (clicks a\nbutton, changes a slider, etc.). They serialize to JSON and are executed by the\nclient-side renderer.\n\n**Transport-agnostic actions** — work with any backend:\n\n    Slider(on_change=SetState(\"brightness\"))\n    Button(\"Toggle\", on_click=ToggleState(\"showDetails\"))\n    Button(\"Open\", on_click=OpenLink(\"https://example.com\"))\n\n**MCP transport actions** — communicate with an MCP server:\n\n    Button(\"Refresh\", on_click=ToolCall(\"get_data\"))\n    Button(\"Ask AI\", on_click=SendMessage(\"Summarize this\"))\n\nActions compose — pass a list for sequential execution::\n\n    Button(\"Submit\", on_click=[\n        SetState(\"loading\", True),\n        ToolCall(\"process\", arguments={\"query\": \"{{ query }}\"}),\n    ])\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom prefab_ui.actions.base import ActionBase\nfrom prefab_ui.actions.mcp import SendMessage, ToolCall, UpdateContext\nfrom prefab_ui.actions.navigation import OpenLink\nfrom prefab_ui.actions.state import AppendState, PopState, SetState, ToggleState\nfrom prefab_ui.actions.ui import CloseOverlay, ShowToast\n\n__all__ = [\n    \"Action\",\n    \"ActionBase\",\n    \"AppendState\",\n    \"CloseOverlay\",\n    \"OpenLink\",\n    \"PopState\",\n    \"SendMessage\",\n    \"SetState\",\n    \"ShowToast\",\n    \"ToggleState\",\n    \"ToolCall\",\n    \"UpdateContext\",\n]\n\nAction = (\n    ToolCall\n    | SendMessage\n    | UpdateContext\n    | OpenLink\n    | SetState\n    | ToggleState\n    | AppendState\n    | PopState\n    | ShowToast\n    | CloseOverlay\n)\n",
  "prefab_ui/actions/base.py": "\"\"\"Base class for all Prefab actions.\n\nEvery action type inherits from ``ActionBase``, which provides the\n``on_success`` and ``on_error`` lifecycle callbacks. These let you chain\nreactions to action outcomes without writing custom logic:\n\n    ToolCall(\"save\",\n        on_success=ShowToast(\"Saved!\"),\n        on_error=ShowToast(\"Save failed\", variant=\"error\"),\n    )\n\nCallbacks can themselves have callbacks (recursive), and the renderer\nenforces a depth limit to prevent infinite loops. When actions compose\nas a list, the first error short-circuits the chain — the failing action's\n``on_error`` runs, then execution stops.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, Field, SerializeAsAny\n\n\nclass ActionBase(BaseModel):\n    \"\"\"Base for all action types — provides lifecycle callbacks.\n\n    Subclasses add an ``action`` literal discriminator and their own fields.\n    The renderer serializes ``on_success``/``on_error`` recursively and\n    dispatches them after the parent action completes.\n\n    Uses ``SerializeAsAny`` so that Pydantic serializes callback values\n    using the concrete runtime type (e.g. ShowToast) rather than the\n    declared base type (ActionBase), which would strip subclass fields.\n    \"\"\"\n\n    model_config = {\"populate_by_name\": True}\n\n    on_success: SerializeAsAny[ActionBase] | list[SerializeAsAny[ActionBase]] | None = (\n        Field(\n            default=None,\n            alias=\"onSuccess\",\n            description=\"Action(s) to run when this action succeeds\",\n        )\n    )\n    on_error: SerializeAsAny[ActionBase] | list[SerializeAsAny[ActionBase]] | None = (\n        Field(\n            default=None,\n            alias=\"onError\",\n            description=\"Action(s) to run when this action fails\",\n        )\n    )\n",
  "prefab_ui/actions/mcp.py": "\"\"\"MCP transport actions.\n\nThese actions communicate with an MCP server via the MCP Apps protocol.\nThey're only meaningful when the renderer is connected to an MCP host.\n\nFor transport-agnostic actions (state, navigation, toasts), see the parent\nmodule.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions.base import ActionBase\n\n\nclass ToolCall(ActionBase):\n    \"\"\"Call a server tool. The renderer proxies via ``app.callServerTool()``.\n\n    If ``result_key`` is set, the tool's return value is written into\n    client-side state at that key. The key supports interpolation:\n    ``result_key=\"detail_{{ selectedId }}\"``.\n    \"\"\"\n\n    action: Literal[\"toolCall\"] = \"toolCall\"\n    tool: str = Field(description=\"Name of the server tool to call\")\n    arguments: dict[str, Any] = Field(\n        default_factory=dict,\n        description=\"Arguments to pass. Supports {{ key }} interpolation.\",\n    )\n    result_key: str | None = Field(\n        default=None,\n        alias=\"resultKey\",\n        description=\"State key to store the tool result under\",\n    )\n\n    def __init__(self, tool: str, **kwargs: Any) -> None:\n        kwargs[\"tool\"] = tool\n        super().__init__(**kwargs)\n\n\nclass SendMessage(ActionBase):\n    \"\"\"Send a message to the chat via ``app.sendMessage()``.\"\"\"\n\n    action: Literal[\"sendMessage\"] = \"sendMessage\"\n    content: str = Field(description=\"Message text to send\")\n\n    def __init__(self, content: str, **kwargs: Any) -> None:\n        kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n\n\nclass UpdateContext(ActionBase):\n    \"\"\"Update model context without triggering a response.\"\"\"\n\n    action: Literal[\"updateContext\"] = \"updateContext\"\n    content: str | None = Field(default=None, description=\"Text content to add\")\n    structured_content: dict[str, Any] | None = Field(\n        default=None,\n        alias=\"structuredContent\",\n        description=\"Structured content to add\",\n    )\n",
  "prefab_ui/actions/navigation.py": "\"\"\"Navigation actions.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions.base import ActionBase\n\n\nclass OpenLink(ActionBase):\n    \"\"\"Open a URL via the host.\"\"\"\n\n    action: Literal[\"openLink\"] = \"openLink\"\n    url: str = Field(description=\"URL to open\")\n\n    def __init__(self, url: str, **kwargs: Any) -> None:\n        kwargs[\"url\"] = url\n        super().__init__(**kwargs)\n",
  "prefab_ui/actions/state.py": "\"\"\"Client-side state management actions.\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom typing import Any, Literal\n\nfrom pydantic import Field, field_validator\n\nfrom prefab_ui.actions.base import ActionBase\n\n_KEY_RE = re.compile(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\")\n\n\ndef _validate_path(path: str) -> str:\n    \"\"\"Validate a state key or dot-path.\n\n    Each segment must be either a valid identifier (``[a-zA-Z_][a-zA-Z0-9_]*``)\n    or a pure integer (array index). Periods delimit segments.\n    \"\"\"\n    for segment in path.split(\".\"):\n        if \"{{\" in segment:\n            continue\n        if segment.isdigit():\n            continue\n        if not _KEY_RE.match(segment):\n            raise ValueError(\n                f\"Invalid path segment: {segment!r}. \"\n                \"Segments must be identifiers ([a-zA-Z_][a-zA-Z0-9_]*) or integers.\"\n            )\n    return path\n\n\nclass SetState(ActionBase):\n    \"\"\"Set a client-side state variable. No server round-trip.\n\n    The default ``value`` of ``{{ $event }}`` captures the event value\n    (slider position, input text, checkbox state, etc.).\n\n    The ``key`` supports dot-paths for nested updates::\n\n        SetState(\"todos.0.done\", True)   # deep-update into a list\n    \"\"\"\n\n    action: Literal[\"setState\"] = \"setState\"\n    key: str = Field(description=\"State key or dot-path to set\")\n    value: Any = Field(\n        default=\"{{ $event }}\",\n        description=\"Value to set. Use '{{ $event }}' for the event value.\",\n    )\n\n    @field_validator(\"key\")\n    @classmethod\n    def _validate_key(cls, v: str) -> str:\n        return _validate_path(v)\n\n    def __init__(self, key: str, value: Any = \"{{ $event }}\", **kwargs: Any) -> None:\n        kwargs[\"key\"] = key\n        kwargs[\"value\"] = value\n        super().__init__(**kwargs)\n\n\nclass ToggleState(ActionBase):\n    \"\"\"Flip a boolean state variable. No server round-trip.\"\"\"\n\n    action: Literal[\"toggleState\"] = \"toggleState\"\n    key: str = Field(description=\"State key or dot-path to toggle\")\n\n    @field_validator(\"key\")\n    @classmethod\n    def _validate_key(cls, v: str) -> str:\n        return _validate_path(v)\n\n    def __init__(self, key: str, **kwargs: Any) -> None:\n        kwargs[\"key\"] = key\n        super().__init__(**kwargs)\n\n\nclass AppendState(ActionBase):\n    \"\"\"Append a value to a state array.\n\n    Appends to the end by default. Pass ``index`` to insert at a specific\n    position (supports negative indices, e.g. ``index=0`` to prepend).\n\n    If the key doesn't exist yet, creates a new single-element array.\n    \"\"\"\n\n    action: Literal[\"appendState\"] = \"appendState\"\n    key: str = Field(description=\"State key or dot-path to the array\")\n    value: Any = Field(\n        default=\"{{ $event }}\",\n        description=\"Value to append.\",\n    )\n    index: int | str | None = Field(\n        default=None,\n        description=\"Insert position (int or template string). None to append at end.\",\n    )\n\n    @field_validator(\"key\")\n    @classmethod\n    def _validate_key(cls, v: str) -> str:\n        return _validate_path(v)\n\n    def __init__(\n        self,\n        key: str,\n        value: Any = \"{{ $event }}\",\n        *,\n        index: int | str | None = None,\n        **kwargs: Any,\n    ) -> None:\n        kwargs[\"key\"] = key\n        kwargs[\"value\"] = value\n        kwargs[\"index\"] = index\n        super().__init__(**kwargs)\n\n\nclass PopState(ActionBase):\n    \"\"\"Remove an item by index from a state array.\n\n    Supports negative indices (e.g. ``-1`` for the last element).\n    \"\"\"\n\n    action: Literal[\"popState\"] = \"popState\"\n    key: str = Field(description=\"State key or dot-path to the array\")\n    index: int | str = Field(\n        description=\"Index to remove (int or template string like '{{ $index }}').\"\n    )\n\n    @field_validator(\"key\")\n    @classmethod\n    def _validate_key(cls, v: str) -> str:\n        return _validate_path(v)\n\n    def __init__(self, key: str, index: int | str, **kwargs: Any) -> None:\n        kwargs[\"key\"] = key\n        kwargs[\"index\"] = index\n        super().__init__(**kwargs)\n",
  "prefab_ui/actions/ui.py": "\"\"\"UI-focused client-side actions.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions.base import ActionBase\n\n\nclass ShowToast(ActionBase):\n    \"\"\"Display a toast notification. Client-side only, no server trip.\"\"\"\n\n    action: Literal[\"showToast\"] = \"showToast\"\n    message: str = Field(description=\"Toast message text\")\n    description: str | None = Field(default=None, description=\"Optional secondary text\")\n    variant: Literal[\"default\", \"success\", \"error\", \"warning\", \"info\"] | None = Field(\n        default=None, description=\"Toast style variant\"\n    )\n    duration: int | None = Field(\n        default=None, description=\"Auto-dismiss duration in milliseconds\"\n    )\n\n    def __init__(self, message: str, **kwargs: Any) -> None:\n        kwargs[\"message\"] = message\n        super().__init__(**kwargs)\n\n\nclass CloseOverlay(ActionBase):\n    \"\"\"Close the nearest ancestor overlay (Dialog or Popover).\"\"\"\n\n    action: Literal[\"closeOverlay\"] = \"closeOverlay\"\n",
  "prefab_ui/renderer/__init__.py": "\"\"\"Renderer resource loader for Prefab.\n\nShips a pre-built, self-contained HTML file (all JS/CSS inlined) inside the\nPython package.  ``get_renderer_html()`` reads and returns it directly — no\nexternal server, CDN, or CSP domains required.\n\nSet ``PREFAB_RENDERER_URL`` to load renderer assets from an external origin\ninstead — useful for local development with ``npx vite preview`` or a CDN::\n\n    PREFAB_RENDERER_URL=http://localhost:4173 uv run python my_server.py\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\nfrom urllib.parse import urlparse\n\n_BUNDLED_HTML = Path(__file__).parent / \"app.html\"\n\n_EXTERNAL_HEAD = \"\"\"\\\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Prefab</title>\n  <link rel=\"stylesheet\" crossorigin href=\"{base_url}/assets/renderer.css\">\n  <script type=\"module\" crossorigin src=\"{base_url}/assets/renderer.js\"></script>\"\"\"\n\n_EXTERNAL_TEMPLATE = \"\"\"\\\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Prefab</title>\n  <link rel=\"stylesheet\" crossorigin href=\"{base_url}/assets/renderer.css\">\n</head>\n<body>\n  <div id=\"root\"></div>\n  <script type=\"module\" crossorigin src=\"{base_url}/assets/renderer.js\"></script>\n</body>\n</html>\n\"\"\"\n\n\ndef _get_origin(url: str) -> str:\n    \"\"\"Extract the origin (scheme + host + port) from a URL.\"\"\"\n    parsed = urlparse(url)\n    origin = f\"{parsed.scheme}://{parsed.hostname}\"\n    if parsed.port:\n        origin += f\":{parsed.port}\"\n    return origin\n\n\ndef get_renderer_head() -> str:\n    \"\"\"Return the renderer ``<head>`` content (JS, CSS, meta tags).\n\n    For bundled mode, extracts everything between ``<head>`` and\n    ``</head>`` from the self-contained HTML bundle.  For external mode,\n    returns ``<link>``/``<script>`` tags pointing at the external URL.\n    \"\"\"\n    override = os.environ.get(\"PREFAB_RENDERER_URL\")\n    if override:\n        return _EXTERNAL_HEAD.format(base_url=override.rstrip(\"/\"))\n    html = _BUNDLED_HTML.read_text(encoding=\"utf-8\")\n    head_start = html.index(\"<head>\") + len(\"<head>\")\n    head_end = html.index(\"</head>\")\n    return html[head_start:head_end].rstrip()\n\n\ndef get_renderer_html() -> str:\n    \"\"\"Return the renderer HTML.\n\n    By default, returns the bundled single-file HTML with all JS/CSS\n    inlined.  When ``PREFAB_RENDERER_URL`` is set, returns a lightweight\n    stub that loads assets from that external origin.\n    \"\"\"\n    override = os.environ.get(\"PREFAB_RENDERER_URL\")\n    if override:\n        return _EXTERNAL_TEMPLATE.format(base_url=override.rstrip(\"/\"))\n    return _BUNDLED_HTML.read_text(encoding=\"utf-8\")\n\n\ndef get_renderer_csp() -> dict[str, list[str]]:\n    \"\"\"Return CSP domains needed for the renderer to load.\n\n    The bundled renderer is fully self-contained, so no CSP domains are\n    needed.  When ``PREFAB_RENDERER_URL`` is set, returns the external\n    origin so the host sandbox allows loading those assets.\n    \"\"\"\n    override = os.environ.get(\"PREFAB_RENDERER_URL\")\n    if override:\n        return {\"resource_domains\": [_get_origin(override.rstrip(\"/\"))]}\n    return {\"resource_domains\": []}\n"
}