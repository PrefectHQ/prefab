{
  "prefab_ui/__init__.py": "\"\"\"Prefab — the agentic frontend framework that even humans can use.\n\nA JSON component format that renders to real interactive frontends.\nTransport-agnostic: works with MCP servers, REST APIs, or any backend\nthat can return JSON.\n\nUsage::\n\n    from prefab_ui.components import Column, Heading, Text\n    from prefab_ui.response import UIResponse\n\n    def show_user(name: str) -> UIResponse:\n        return UIResponse(\n            state={\"name\": name},\n            view=Column(Heading(\"{{ name }}\")),\n        )\n\nSubmodules:\n\n- ``prefab_ui.components`` — UI components (Button, Grid, Card, etc.)\n- ``prefab_ui.actions`` — state actions (SetState, AppendState, etc.)\n- ``prefab_ui.css`` — CSS helpers (Responsive, Hover, Md, etc.)\n- ``prefab_ui.response`` — UIResponse\n- ``prefab_ui.define`` — Define (reusable component definitions)\n- ``prefab_ui.use`` — Use (component instantiation)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport importlib.metadata\n\ntry:\n    __version__ = importlib.metadata.version(\"prefab-ui\")\nexcept importlib.metadata.PackageNotFoundError:\n    __version__ = \"0.0.0-dev\"\n",
  "prefab_ui/app.py": "\"\"\"PrefabApp — the central application object for Prefab.\n\nDescribes what to render, what state to initialize, and what external\nassets to load.  Pure data model — transport-agnostic.\n\nUsage::\n\n    from prefab_ui.app import PrefabApp\n    from prefab_ui.components import Column, Heading, DataTable\n\n    app = PrefabApp(\n        view=Column(Heading(\"Dashboard\"), DataTable(data=users)),\n        state={\"users\": users},\n    )\n\n    html = app.html()      # complete self-contained page\n    csp = app.csp()        # CSP domains for sandboxed delivery\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nfrom contextvars import ContextVar\nfrom typing import Any\n\nimport pydantic_core\nfrom pydantic import BaseModel, Field, model_validator\n\nfrom prefab_ui.renderer import _get_origin, get_renderer_csp, get_renderer_head\n\nPROTOCOL_VERSION = \"0.2\"\n\n# ── Initial State ─────────────────────────────────────────────────────\n\n_initial_state: ContextVar[dict[str, Any] | None] = ContextVar(\n    \"_initial_state\", default=None\n)\n\n\ndef set_initial_state(**kwargs: Any) -> None:\n    \"\"\"Declare initial client-side state for the current app.\n\n    Called alongside component construction to define the starting\n    values that templates like ``{{ name }}`` resolve against::\n\n        set_initial_state(name=\"world\")\n\n        with Card():\n            H3(\"Hello, {{ name }}!\")\n    \"\"\"\n    current = _initial_state.get()\n    if current is None:\n        current = {}\n        _initial_state.set(current)\n    current.update(kwargs)\n\n\ndef get_initial_state() -> dict[str, Any] | None:\n    \"\"\"Retrieve state set by :func:`set_initial_state`, or ``None``.\"\"\"\n    return _initial_state.get()\n\n\ndef clear_initial_state() -> None:\n    \"\"\"Reset the initial-state accumulator.\"\"\"\n    _initial_state.set(None)\n\n\n_PAGE_TEMPLATE = \"\"\"\\\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <title>{title}</title>\n{head}\n</head>\n<body>\n  <div id=\"root\" style=\"max-width:64rem;margin:0 auto;padding:2rem\"></div>\n  <script id=\"prefab:initial-data\" type=\"application/json\">{data}</script>\n</body>\n</html>\"\"\"\n\n\nclass PrefabApp(BaseModel):\n    \"\"\"A complete Prefab application.\n\n    Describes the view, initial state, reusable component definitions,\n    and external assets.  Use ``html()`` to produce a self-contained\n    HTML page, or ``to_json()`` for the wire-format envelope.\n    \"\"\"\n\n    title: str = Field(default=\"Prefab\", description=\"HTML page title\")\n    view: Any | None = Field(default=None, description=\"Component tree to render\")\n    state: dict[str, Any] | None = Field(\n        default=None,\n        description=\"Initial client-side state\",\n    )\n    defs: list[Any] | None = Field(\n        default=None,\n        description=\"Reusable component definitions (Define instances)\",\n    )\n    stylesheets: list[str] | None = Field(\n        default=None,\n        description=\"External CSS URLs to load in <head>\",\n    )\n    scripts: list[str] | None = Field(\n        default=None,\n        description=\"External JS URLs to load in <head>\",\n    )\n    connect_domains: list[str] | None = Field(\n        default=None,\n        description=\"Domains to allow in CSP connect-src (for Fetch actions)\",\n    )\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    @model_validator(mode=\"after\")\n    def _consume_initial_state(self) -> PrefabApp:\n        accumulated = get_initial_state()\n        if accumulated:\n            clear_initial_state()\n            if self.state is None:\n                self.state = accumulated\n            else:\n                # Explicit state= wins; accumulated values fill in gaps\n                self.state = {**accumulated, **self.state}\n\n        if self.state is not None:\n            for key in self.state:\n                if key.startswith(\"$\"):\n                    raise ValueError(f\"State key {key!r} uses reserved prefix '$'\")\n        return self\n\n    def to_json(self) -> dict[str, Any]:\n        \"\"\"Produce the Prefab wire format.\n\n        Returns a dict with ``version``, ``view``, ``defs``, and ``state``\n        as top-level keys (omitting any that are None).\n        \"\"\"\n        result: dict[str, Any] = {\"version\": PROTOCOL_VERSION}\n\n        if self.view is not None:\n            result[\"view\"] = self.view.to_json()\n\n        if self.defs:\n            result[\"defs\"] = {d.name: d.to_json() for d in self.defs}\n\n        if self.state is not None:\n            result[\"state\"] = pydantic_core.to_jsonable_python(self.state)\n\n        return result\n\n    def html(self) -> str:\n        \"\"\"Produce a complete, self-contained HTML page.\n\n        The page includes the Prefab renderer (JS/CSS), any user-specified\n        stylesheets and scripts, and the application data baked in as a\n        JSON ``<script>`` tag.\n        \"\"\"\n        head_parts = [get_renderer_head()]\n\n        if self.stylesheets:\n            for url in self.stylesheets:\n                head_parts.append(f'  <link rel=\"stylesheet\" href=\"{url}\">')\n\n        if self.scripts:\n            for url in self.scripts:\n                head_parts.append(f'  <script src=\"{url}\"></script>')\n\n        data_json = json.dumps(self.to_json(), separators=(\",\", \":\"))\n        # Escape </ to prevent premature closing of the script tag\n        safe_json = data_json.replace(\"</\", r\"<\\/\")\n\n        return _PAGE_TEMPLATE.format(\n            title=self.title,\n            head=\"\\n\".join(head_parts),\n            data=safe_json,\n        )\n\n    def csp(self) -> dict[str, list[str]]:\n        \"\"\"Compute CSP domains from the app's asset configuration.\n\n        Merges the renderer's base CSP with origins extracted from\n        ``stylesheets``, ``scripts``, and ``connect_domains``.\n        \"\"\"\n        result = get_renderer_csp()\n\n        if self.connect_domains:\n            result[\"connect_domains\"] = list(self.connect_domains)\n\n        if self.stylesheets:\n            origins = sorted({_get_origin(url) for url in self.stylesheets})\n            result[\"style_domains\"] = origins\n\n        if self.scripts:\n            origins = sorted({_get_origin(url) for url in self.scripts})\n            result[\"script_domains\"] = origins\n\n        return result\n",
  "prefab_ui/css.py": "\"\"\"CSS utilities for Tailwind class composition.\n\nHelpers for building css_class values without repeating variant prefixes.\n\nPseudo-state helpers prefix each space-separated class::\n\n    from prefab_ui.css import Hover, FocusVisible\n\n    css_class=[\"p-4 border-0\", Hover(\"bg-blue-500 scale-105\")]\n    # → \"p-4 border-0 hover:bg-blue-500 hover:scale-105\"\n\n    css_class=[\"ring-0 border-0\", FocusVisible(\"border-b border-border\")]\n    # → \"ring-0 border-0 focus-visible:border-b focus-visible:border-border\"\n\nResponsive maps Tailwind breakpoints to values::\n\n    from prefab_ui.css import Responsive\n\n    Grid(columns=Responsive(default=1, md=2, lg=3))\n    Button(\"Go\", css_class=Responsive(default=\"w-full\", md=\"w-auto\"))\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\n# ── Responsive ─────────────────────────────────────────────────────────\n\n_BREAKPOINTS = (\"default\", \"sm\", \"md\", \"lg\", \"xl\", \"2xl\")\n\n_BreakpointFormatter = Any  # Callable[[Any], str] — avoid import complexity\n\n\nclass Responsive:\n    \"\"\"Breakpoint-aware values for responsive layouts.\n\n    Maps Tailwind breakpoints to values. At compile time, each entry is\n    prefixed with its breakpoint (``default`` emits unprefixed classes).\n\n    Usage::\n\n        Grid(columns=Responsive(default=1, md=2, lg=3))\n        Row(gap=Responsive(default=2, md=4))\n        Button(\"Go\", css_class=Responsive(default=\"w-full\", md=\"w-auto\"))\n    \"\"\"\n\n    __slots__ = (\"_values\",)\n\n    def __init__(self, **kwargs: Any) -> None:\n        invalid = set(kwargs) - set(_BREAKPOINTS)\n        if invalid:\n            raise ValueError(\n                f\"Invalid breakpoint(s): {', '.join(sorted(invalid))}. \"\n                f\"Valid breakpoints: {', '.join(_BREAKPOINTS)}\"\n            )\n        if not kwargs:\n            raise ValueError(\"Responsive() requires at least one breakpoint value\")\n        self._values: dict[str, Any] = kwargs\n\n    def __repr__(self) -> str:\n        inner = \", \".join(f\"{k}={v!r}\" for k, v in self._values.items())\n        return f\"Responsive({inner})\"\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, Responsive):\n            return self._values == other._values\n        return NotImplemented\n\n    @property\n    def values(self) -> dict[str, Any]:\n        return dict(self._values)\n\n    def compile_css(self, formatter: _BreakpointFormatter) -> str:\n        \"\"\"Compile to a space-separated Tailwind class string.\n\n        The *formatter* is called once per breakpoint entry and should\n        return one or more CSS utility classes for the given value.\n        \"\"\"\n        parts: list[str] = []\n        for bp in _BREAKPOINTS:\n            if bp not in self._values:\n                continue\n            classes = formatter(self._values[bp])\n            if not classes:\n                continue\n            if bp == \"default\":\n                parts.append(classes)\n            else:\n                for cls in classes.split():\n                    parts.append(f\"{bp}:{cls}\")\n        return \" \".join(parts)\n\n\n# ── Variant helpers ───────────────────────────────────────────────────\n\n\ndef _prefixed(prefix: str, classes: str) -> str:\n    \"\"\"Prefix each space-separated class with a Tailwind variant.\"\"\"\n    return \" \".join(f\"{prefix}:{cls}\" for cls in classes.split())\n\n\ndef Hover(classes: str) -> str:\n    \"\"\"Prefix classes with ``hover:``.\n\n    Example::\n\n        css_class=[\"p-4\", Hover(\"bg-blue-500 scale-105\")]\n        # → \"p-4 hover:bg-blue-500 hover:scale-105\"\n    \"\"\"\n    return _prefixed(\"hover\", classes)\n\n\ndef Focus(classes: str) -> str:\n    \"\"\"Prefix classes with ``focus:``.\"\"\"\n    return _prefixed(\"focus\", classes)\n\n\ndef FocusVisible(classes: str) -> str:\n    \"\"\"Prefix classes with ``focus-visible:``.\"\"\"\n    return _prefixed(\"focus-visible\", classes)\n\n\ndef FocusWithin(classes: str) -> str:\n    \"\"\"Prefix classes with ``focus-within:``.\"\"\"\n    return _prefixed(\"focus-within\", classes)\n\n\ndef Active(classes: str) -> str:\n    \"\"\"Prefix classes with ``active:``.\"\"\"\n    return _prefixed(\"active\", classes)\n\n\ndef Disabled(classes: str) -> str:\n    \"\"\"Prefix classes with ``disabled:``.\"\"\"\n    return _prefixed(\"disabled\", classes)\n\n\n# ── Breakpoint helpers ────────────────────────────────────────────────\n\n\ndef Sm(classes: str) -> str:\n    \"\"\"Prefix classes with ``sm:`` (≥640px).\"\"\"\n    return _prefixed(\"sm\", classes)\n\n\ndef Md(classes: str) -> str:\n    \"\"\"Prefix classes with ``md:`` (≥768px).\"\"\"\n    return _prefixed(\"md\", classes)\n\n\ndef Lg(classes: str) -> str:\n    \"\"\"Prefix classes with ``lg:`` (≥1024px).\"\"\"\n    return _prefixed(\"lg\", classes)\n\n\ndef Xl(classes: str) -> str:\n    \"\"\"Prefix classes with ``xl:`` (≥1280px).\"\"\"\n    return _prefixed(\"xl\", classes)\n\n\ndef Xxl(classes: str) -> str:\n    \"\"\"Prefix classes with ``2xl:`` (≥1536px).\"\"\"\n    return _prefixed(\"2xl\", classes)\n",
  "prefab_ui/define.py": "\"\"\"Define — named reusable component templates.\n\nA ``Define`` captures a component subtree as a named template that can be\nreferenced with :class:`~prefab_ui.use.Use`. Definitions live outside the\ncomponent tree and are passed to :class:`~prefab_ui.app.PrefabApp`\nvia the ``defs`` parameter.\n\nExample::\n\n    from prefab_ui.define import Define\n    from prefab_ui.use import Use\n    from prefab_ui.app import PrefabApp\n    from prefab_ui.components import Card, Column, Heading, Badge\n\n    with Define(\"user-card\") as user_card:\n        with Card():\n            Heading(\"{{ name }}\")\n            Badge(\"{{ role }}\")\n\n    with Column() as layout:\n        Use(\"user-card\", name=\"Alice\", role=\"Engineer\")\n        Use(\"user-card\", name=\"Bob\", role=\"Designer\")\n\n    PrefabApp(view=layout, defs=[user_card])\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Define(ContainerComponent):\n    \"\"\"Create a named, reusable component template.\n\n    Define captures children via the context manager but does **not**\n    attach itself to any parent container. Pass Define instances to\n    ``PrefabApp(defs=[...])`` to include them in the wire format.\n\n    Args:\n        name: Template name, referenced by :class:`~prefab_ui.use.Use`.\n    \"\"\"\n\n    type: Literal[\"Define\"] = \"Define\"\n    name: str = Field(description=\"Template name for $ref lookup\")\n\n    def model_post_init(self, __context: Any) -> None:\n        # Skip auto-append — Define lives outside the component tree.\n        pass\n\n    def __init__(self, name: str, /, **kwargs: Any) -> None:\n        kwargs[\"name\"] = name\n        super().__init__(**kwargs)\n\n    def to_json(self) -> dict[str, Any]:\n        \"\"\"Return the template body, not a Define wrapper.\n\n        Single child returns that child's JSON directly. Multiple\n        children are wrapped in an implicit Column.\n        \"\"\"\n        if len(self.children) == 1:\n            return self.children[0].to_json()\n        return {\n            \"type\": \"Column\",\n            \"children\": [c.to_json() for c in self.children],\n        }\n",
  "prefab_ui/rx.py": "\"\"\"Reactive references for Prefab components.\n\nThe ``Rx`` class provides type-safe reactive references that serialize to\n``{{ }}`` template expressions.  Components with state bindings expose an\n``.rx`` property returning an ``Rx`` object, which can be passed directly\nto any string-typed component field or embedded in f-strings::\n\n    slider = Slider(min=0, max=100)\n\n    # Bare ref — Pydantic coerces Rx to str automatically\n    Metric(value=slider.rx)\n\n    # f-string — mixes reactive value with literal text\n    Text(f\"Value: {slider.rx}\")\n\nRx objects support Python operators and pipe methods, each of which\nreturns a new Rx with the compiled ``{{ }}`` expression::\n\n    price = Rx(\"price\")\n    quantity = Rx(\"quantity\")\n\n    price * quantity              # {{ price * quantity }}\n    (price * quantity).currency() # {{ price * quantity | currency }}\n    quantity > 0                  # {{ quantity > 0 }}\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom contextvars import ContextVar\n\n# ── Auto-name counter ────────────────────────────────────────────────\n\n_counter: ContextVar[dict[str, int]] = ContextVar(\"_rx_counter\")\n\n\ndef _generate_key(prefix: str) -> str:\n    \"\"\"Return a deterministic sequential key like ``slider_1``.\"\"\"\n    counters = _counter.get(None)\n    if counters is None:\n        counters = {}\n        _counter.set(counters)\n    n = counters.get(prefix, 0) + 1\n    counters[prefix] = n\n    return f\"{prefix}_{n}\"\n\n\ndef reset_counter() -> None:\n    \"\"\"Reset the auto-name counter.  Call in test fixtures for isolation.\"\"\"\n    _counter.set({})\n\n\n# ── Precedence levels (higher = tighter binding) ─────────────────────\n\n_PREC_PIPE = 1\n_PREC_TERNARY = 2\n_PREC_OR = 3\n_PREC_AND = 4\n_PREC_NOT = 5\n_PREC_COMP = 6\n_PREC_ADD = 7\n_PREC_MUL = 8\n_PREC_UNARY = 9\n_PREC_ATOM = 10\n\n\n# ── Helpers ──────────────────────────────────────────────────────────\n\n\ndef _format_value(value: object, min_prec: int = 0) -> str:\n    \"\"\"Format a Python value as an expression token.\n\n    Strings → single-quoted, numbers → bare, bools → true/false,\n    None → null, Rx → raw key (wrapped in parens if below min_prec).\n    \"\"\"\n    if isinstance(value, Rx):\n        return value._wrap(min_prec)\n    if isinstance(value, bool):\n        return \"true\" if value else \"false\"\n    if isinstance(value, (int, float)):\n        return str(value)\n    if value is None:\n        return \"null\"\n    if isinstance(value, str):\n        return f\"'{value}'\"\n    return str(value)\n\n\ndef _format_pipe_arg(value: object) -> str:\n    \"\"\"Format a pipe argument (after the colon).\n\n    Unlike expression tokens, pipe args are bare tokens — strings are\n    NOT quoted unless they contain spaces (then use single quotes).\n    \"\"\"\n    if isinstance(value, (int, float)):\n        return str(value)\n    s = str(value)\n    if \" \" in s:\n        return f\"'{s}'\"\n    return s\n\n\n# ── Rx ────────────────────────────────────────────────────────────────\n\n\nclass Rx:\n    \"\"\"A reactive reference to a client-side state key.\n\n    Serializes to ``{{ key }}`` via ``__str__`` / ``__format__``.\n\n    Supports Python operators that compile to template expressions::\n\n        count = Rx(\"count\")\n        count + 1              # → {{ count + 1 }}\n        count > 0              # → {{ count > 0 }}\n        (count > 0).then(\"yes\", \"no\")  # → {{ count > 0 ? 'yes' : 'no' }}\n\n    Pipe methods format values for display::\n\n        Rx(\"revenue\").currency()       # → {{ revenue | currency }}\n        Rx(\"name\").upper().truncate(20) # → {{ name | upper | truncate:20 }}\n    \"\"\"\n\n    __slots__ = (\"_key\", \"_prec\")\n\n    def __init__(self, key: str, _prec: int = _PREC_ATOM) -> None:\n        object.__setattr__(self, \"_key\", key)\n        object.__setattr__(self, \"_prec\", _prec)\n\n    def __setattr__(self, name: str, value: object) -> None:\n        raise AttributeError(\"Rx objects are immutable\")\n\n    @property\n    def key(self) -> str:\n        \"\"\"The raw state key string.\"\"\"\n        return object.__getattribute__(self, \"_key\")\n\n    @property\n    def prec(self) -> int:\n        \"\"\"Operator precedence level.\"\"\"\n        return object.__getattribute__(self, \"_prec\")\n\n    def _wrap(self, min_prec: int) -> str:\n        \"\"\"Return key, wrapped in parens if precedence is too low.\"\"\"\n        if self.prec < min_prec:\n            return f\"({self.key})\"\n        return self.key\n\n    # ── String conversion ────────────────────────────────────────────\n\n    def __str__(self) -> str:\n        return \"{{ \" + self.key + \" }}\"\n\n    def __repr__(self) -> str:\n        return f\"Rx({self.key!r})\"\n\n    def __format__(self, format_spec: str) -> str:\n        return str(self)\n\n    # ── Dot-path access ──────────────────────────────────────────────\n\n    def __getattr__(self, name: str) -> Rx:\n        if name.startswith(\"_\"):\n            raise AttributeError(name)\n        return Rx(f\"{self.key}.{name}\")\n\n    # ── Arithmetic ───────────────────────────────────────────────────\n\n    def __add__(self, other: object) -> Rx:\n        return Rx(f\"{self._wrap(_PREC_ADD)} + {_format_value(other)}\", _PREC_ADD)\n\n    def __radd__(self, other: object) -> Rx:\n        return Rx(f\"{_format_value(other)} + {self._wrap(_PREC_ADD)}\", _PREC_ADD)\n\n    def __sub__(self, other: object) -> Rx:\n        return Rx(f\"{self._wrap(_PREC_ADD)} - {_rhs(other, _PREC_ADD)}\", _PREC_ADD)\n\n    def __rsub__(self, other: object) -> Rx:\n        return Rx(f\"{_format_value(other)} - {self._wrap(_PREC_ADD)}\", _PREC_ADD)\n\n    def __mul__(self, other: object) -> Rx:\n        return Rx(f\"{self._wrap(_PREC_MUL)} * {_format_value(other)}\", _PREC_MUL)\n\n    def __rmul__(self, other: object) -> Rx:\n        return Rx(f\"{_format_value(other)} * {self._wrap(_PREC_MUL)}\", _PREC_MUL)\n\n    def __truediv__(self, other: object) -> Rx:\n        return Rx(f\"{self._wrap(_PREC_MUL)} / {_rhs(other, _PREC_MUL)}\", _PREC_MUL)\n\n    def __rtruediv__(self, other: object) -> Rx:\n        return Rx(f\"{_format_value(other)} / {self._wrap(_PREC_MUL)}\", _PREC_MUL)\n\n    def __neg__(self) -> Rx:\n        return Rx(f\"-{self._wrap(_PREC_UNARY)}\", _PREC_UNARY)\n\n    def __pos__(self) -> Rx:\n        return Rx(f\"+{self._wrap(_PREC_UNARY)}\", _PREC_UNARY)\n\n    # ── Comparison ───────────────────────────────────────────────────\n\n    def __eq__(self, other: object) -> Rx:  # type: ignore[override]\n        return Rx(f\"{self._wrap(_PREC_COMP)} == {_format_value(other)}\", _PREC_COMP)\n\n    def __ne__(self, other: object) -> Rx:  # type: ignore[override]\n        return Rx(f\"{self._wrap(_PREC_COMP)} != {_format_value(other)}\", _PREC_COMP)\n\n    def __gt__(self, other: object) -> Rx:\n        return Rx(f\"{self._wrap(_PREC_COMP)} > {_format_value(other)}\", _PREC_COMP)\n\n    def __ge__(self, other: object) -> Rx:\n        return Rx(f\"{self._wrap(_PREC_COMP)} >= {_format_value(other)}\", _PREC_COMP)\n\n    def __lt__(self, other: object) -> Rx:\n        return Rx(f\"{self._wrap(_PREC_COMP)} < {_format_value(other)}\", _PREC_COMP)\n\n    def __le__(self, other: object) -> Rx:\n        return Rx(f\"{self._wrap(_PREC_COMP)} <= {_format_value(other)}\", _PREC_COMP)\n\n    # ── Logical ──────────────────────────────────────────────────────\n\n    def __and__(self, other: object) -> Rx:\n        return Rx(f\"{self._wrap(_PREC_AND)} && {_rhs(other, _PREC_AND)}\", _PREC_AND)\n\n    def __rand__(self, other: object) -> Rx:\n        return Rx(f\"{_format_value(other)} && {self._wrap(_PREC_AND)}\", _PREC_AND)\n\n    def __or__(self, other: object) -> Rx:\n        return Rx(f\"{self._wrap(_PREC_OR)} || {_rhs(other, _PREC_OR)}\", _PREC_OR)\n\n    def __ror__(self, other: object) -> Rx:\n        return Rx(f\"{_format_value(other)} || {self._wrap(_PREC_OR)}\", _PREC_OR)\n\n    def __invert__(self) -> Rx:\n        # Wrap anything that isn't a simple atom for readability\n        return Rx(f\"!{self._wrap(_PREC_ATOM)}\", _PREC_NOT)\n\n    # ── Ternary ──────────────────────────────────────────────────────\n\n    def then(self, if_true: object, if_false: object) -> Rx:\n        \"\"\"Ternary conditional: ``condition ? if_true : if_false``.\"\"\"\n        # Use _PREC_TERNARY + 1 so nested ternaries in branches get wrapped\n        branch_prec = _PREC_TERNARY + 1\n        return Rx(\n            f\"{self._wrap(_PREC_TERNARY)} ? \"\n            f\"{_format_value(if_true, branch_prec)} : \"\n            f\"{_format_value(if_false, branch_prec)}\",\n            _PREC_TERNARY,\n        )\n\n    # ── Pipes ────────────────────────────────────────────────────────\n\n    def _pipe(self, name: str, arg: object = None) -> Rx:\n        \"\"\"Apply a pipe: ``key | name`` or ``key | name:arg``.\"\"\"\n        if arg is not None:\n            return Rx(f\"{self.key} | {name}:{_format_pipe_arg(arg)}\", _PREC_PIPE)\n        return Rx(f\"{self.key} | {name}\", _PREC_PIPE)\n\n    # Number pipes\n    def currency(self, code: str | None = None) -> Rx:\n        return self._pipe(\"currency\", code)\n\n    def percent(self, decimals: int | None = None) -> Rx:\n        return self._pipe(\"percent\", decimals)\n\n    def number(self, decimals: int | None = None) -> Rx:\n        return self._pipe(\"number\", decimals)\n\n    def round(self, decimals: int) -> Rx:\n        return self._pipe(\"round\", decimals)\n\n    def abs(self) -> Rx:\n        return self._pipe(\"abs\")\n\n    # Date pipes\n    def date(self, format: str | None = None) -> Rx:\n        return self._pipe(\"date\", format)\n\n    def time(self) -> Rx:\n        return self._pipe(\"time\")\n\n    def datetime(self) -> Rx:\n        return self._pipe(\"datetime\")\n\n    # String pipes\n    def upper(self) -> Rx:\n        return self._pipe(\"upper\")\n\n    def lower(self) -> Rx:\n        return self._pipe(\"lower\")\n\n    def truncate(self, max_length: int) -> Rx:\n        return self._pipe(\"truncate\", max_length)\n\n    def pluralize(self, word: str | None = None) -> Rx:\n        return self._pipe(\"pluralize\", word)\n\n    # Array pipes\n    def length(self) -> Rx:\n        return self._pipe(\"length\")\n\n    def join(self, separator: str | None = None) -> Rx:\n        return self._pipe(\"join\", separator)\n\n    def first(self) -> Rx:\n        return self._pipe(\"first\")\n\n    def last(self) -> Rx:\n        return self._pipe(\"last\")\n\n    def selectattr(self, attr: str) -> Rx:\n        return self._pipe(\"selectattr\", attr)\n\n    def rejectattr(self, attr: str) -> Rx:\n        return self._pipe(\"rejectattr\", attr)\n\n    # Default\n    def default(self, value: object) -> Rx:\n        return self._pipe(\"default\", value)\n\n\ndef _rhs(value: object, min_prec: int) -> str:\n    \"\"\"Format a right-hand operand, wrapping in parens if needed.\n\n    For non-commutative operators (-, /), the RHS needs parens if it's\n    an expression at the same precedence level to avoid ambiguity:\n    ``a - (b - c)`` vs ``a - b - c``.\n    \"\"\"\n    if isinstance(value, Rx):\n        if value.prec <= min_prec:\n            return f\"({value.key})\"\n        return value.key\n    return _format_value(value)\n\n\ndef _coerce_rx(value: object) -> object:\n    \"\"\"Recursively convert Rx instances to their string form.\"\"\"\n    if isinstance(value, Rx):\n        return str(value)\n    if isinstance(value, dict):\n        return {k: _coerce_rx(v) for k, v in value.items()}\n    if isinstance(value, list):\n        return [_coerce_rx(v) for v in value]\n    return value\n",
  "prefab_ui/use.py": "\"\"\"Use — reference a defined component template.\n\nA ``Use`` node references a :class:`~prefab_ui.define.Define` template by\nname. On the wire it desugars to ``{\"$ref\": \"name\"}``, with optional ``let``\nbindings for scoped overrides and ``cssClass`` for styling.\n\nExample::\n\n    from prefab_ui.define import Define\n    from prefab_ui.use import Use\n    from prefab_ui.components import Card, Column, Heading, Badge\n\n    with Define(\"user-card\") as user_card:\n        with Card():\n            Heading(\"{{ name }}\")\n            Badge(\"{{ role }}\")\n\n    with Column() as layout:\n        Use(\"user-card\", name=\"Alice\", role=\"Engineer\")\n        Use(\"user-card\", name=\"Bob\", role=\"Designer\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\n\n# Component base fields that should NOT be treated as state overrides.\n_BASE_FIELDS = frozenset(Component.model_fields)\n\n\nclass Use(Component):\n    \"\"\"Reference a defined component template by name.\n\n    Kwargs that aren't base component fields (``css_class``)\n    become scoped ``let`` bindings on the ``$ref`` node.\n\n    Args:\n        name: The template name (must match a ``Define`` name).\n        **kwargs: Scoped bindings and/or base component fields.\n    \"\"\"\n\n    # Use has a type field for Pydantic, but to_json() never emits it.\n    type: str = \"Use\"\n    name: str = Field(description=\"Template name to reference\")\n    overrides: dict[str, Any] = Field(default_factory=dict)\n\n    def __init__(self, name: str, /, **kwargs: Any) -> None:\n        init_kwargs: dict[str, Any] = {}\n        override_kwargs: dict[str, Any] = {}\n        for k, v in kwargs.items():\n            if k in _BASE_FIELDS:\n                init_kwargs[k] = v\n            else:\n                override_kwargs[k] = v\n        init_kwargs[\"name\"] = name\n        init_kwargs[\"overrides\"] = override_kwargs\n        super().__init__(**init_kwargs)\n\n    def to_json(self) -> dict[str, Any]:\n        \"\"\"Desugar to ``$ref`` with optional ``let`` and ``cssClass``.\"\"\"\n        ref: dict[str, Any] = {\"$ref\": self.name}\n\n        if self.overrides:\n            ref[\"let\"] = self.overrides\n        if self.css_class:\n            ref[\"cssClass\"] = self.css_class\n\n        return ref\n",
  "prefab_ui/components/__init__.py": "\"\"\"Prefab component library.\n\nUI and layout components are importable from this package directly::\n\n    from prefab_ui.components import Card, Badge, H1, Grid\n\nCharts and control flow have dedicated submodules::\n\n    from prefab_ui.components.charts import BarChart, ChartSeries\n    from prefab_ui.components.control_flow import ForEach, If, Else\n\"\"\"\n\nfrom prefab_ui.components.alert import Alert, AlertDescription, AlertTitle\nfrom prefab_ui.components.badge import Badge\nfrom prefab_ui.components.base import (\n    Component,\n    ContainerComponent,\n    StatefulMixin,\n    defer,\n    insert,\n)\nfrom prefab_ui.rx import Rx\nfrom prefab_ui.components.button import Button\nfrom prefab_ui.components.calendar import Calendar\nfrom prefab_ui.components.button_group import ButtonGroup\nfrom prefab_ui.components.card import (\n    Card,\n    CardContent,\n    CardDescription,\n    CardFooter,\n    CardHeader,\n    CardTitle,\n)\nfrom prefab_ui.components.checkbox import Checkbox\nfrom prefab_ui.components.combobox import Combobox, ComboboxOption\nfrom prefab_ui.components.code import Code\nfrom prefab_ui.components.column import Column\nfrom prefab_ui.components.container import Container\nfrom prefab_ui.components.dashboard import Dashboard, DashboardItem\nfrom prefab_ui.components.data_table import DataTable, DataTableColumn\nfrom prefab_ui.components.date_picker import DatePicker\nfrom prefab_ui.components.dialog import Dialog\nfrom prefab_ui.components.div import Div, Span\nfrom prefab_ui.components.drop_zone import DropZone\nfrom prefab_ui.components.accordion import Accordion, AccordionItem\nfrom prefab_ui.components.field import Field\nfrom prefab_ui.components.form import Form\nfrom prefab_ui.components.grid import Grid\nfrom prefab_ui.components.heading import Heading\nfrom prefab_ui.components.histogram import Histogram\nfrom prefab_ui.components.hover_card import HoverCard\nfrom prefab_ui.components.icon import Icon\nfrom prefab_ui.components.image import Image\nfrom prefab_ui.components.input import Input\nfrom prefab_ui.components.label import Label\nfrom prefab_ui.components.markdown import Markdown\nfrom prefab_ui.components.metric import Metric\nfrom prefab_ui.components.pages import Page, Pages\nfrom prefab_ui.components.popover import Popover\nfrom prefab_ui.components.progress import Progress\nfrom prefab_ui.components.radio import Radio, RadioGroup\nfrom prefab_ui.components.ring import Ring\nfrom prefab_ui.components.row import Row\nfrom prefab_ui.components.select import Select, SelectOption\nfrom prefab_ui.components.separator import Separator\nfrom prefab_ui.components.slot import Slot\nfrom prefab_ui.components.slider import Slider\nfrom prefab_ui.components.loader import Loader\nfrom prefab_ui.components.switch import Switch\nfrom prefab_ui.components.tabs import Tab, Tabs\nfrom prefab_ui.components.tooltip import Tooltip\nfrom prefab_ui.components.table import (\n    Table,\n    TableBody,\n    TableCaption,\n    TableCell,\n    TableFooter,\n    TableHead,\n    TableHeader,\n    TableRow,\n)\nfrom prefab_ui.components.text import Text\nfrom prefab_ui.components.textarea import Textarea\nfrom prefab_ui.components.typography import (\n    H1,\n    H2,\n    H3,\n    H4,\n    BlockQuote,\n    InlineCode,\n    Large,\n    Lead,\n    Muted,\n    P,\n    Small,\n)\n\n__all__ = [\n    \"H1\",\n    \"H2\",\n    \"H3\",\n    \"H4\",\n    \"Accordion\",\n    \"AccordionItem\",\n    \"Alert\",\n    \"AlertDescription\",\n    \"AlertTitle\",\n    \"Badge\",\n    \"BlockQuote\",\n    \"Button\",\n    \"ButtonGroup\",\n    \"Calendar\",\n    \"Card\",\n    \"CardContent\",\n    \"CardDescription\",\n    \"CardFooter\",\n    \"CardHeader\",\n    \"CardTitle\",\n    \"Checkbox\",\n    \"Code\",\n    \"Column\",\n    \"Combobox\",\n    \"ComboboxOption\",\n    \"Component\",\n    \"Container\",\n    \"ContainerComponent\",\n    \"Dashboard\",\n    \"DashboardItem\",\n    \"DataTable\",\n    \"DataTableColumn\",\n    \"DatePicker\",\n    \"Dialog\",\n    \"Div\",\n    \"DropZone\",\n    \"Field\",\n    \"Form\",\n    \"Grid\",\n    \"Heading\",\n    \"Histogram\",\n    \"HoverCard\",\n    \"Icon\",\n    \"Image\",\n    \"InlineCode\",\n    \"Input\",\n    \"Label\",\n    \"Large\",\n    \"Lead\",\n    \"Loader\",\n    \"Markdown\",\n    \"Metric\",\n    \"Muted\",\n    \"P\",\n    \"Page\",\n    \"Pages\",\n    \"Popover\",\n    \"Progress\",\n    \"Radio\",\n    \"RadioGroup\",\n    \"Ring\",\n    \"Row\",\n    \"Rx\",\n    \"Select\",\n    \"SelectOption\",\n    \"Separator\",\n    \"Slider\",\n    \"Slot\",\n    \"Small\",\n    \"Span\",\n    \"StatefulMixin\",\n    \"Switch\",\n    \"Tab\",\n    \"Table\",\n    \"TableBody\",\n    \"TableCaption\",\n    \"TableCell\",\n    \"TableFooter\",\n    \"TableHead\",\n    \"TableHeader\",\n    \"TableRow\",\n    \"Tabs\",\n    \"Text\",\n    \"Textarea\",\n    \"Tooltip\",\n    \"defer\",\n    \"insert\",\n]\n",
  "prefab_ui/components/accordion.py": "\"\"\"Accordion component for collapsible content sections.\n\nExample::\n\n    from prefab_ui.components import Accordion, AccordionItem, Text\n\n    with Accordion(default_open_items=0):\n        with AccordionItem(\"Getting Started\"):\n            Text(\"Install with pip install fastmcp\")\n        with AccordionItem(\"Configuration\"):\n            Text(\"Edit config.toml to customize settings.\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass AccordionItem(ContainerComponent):\n    \"\"\"A single collapsible section within an Accordion.\n\n    The ``title`` appears in the trigger; children are revealed on expand.\n\n    Example::\n\n        with AccordionItem(\"Details\"):\n            Text(\"Hidden content revealed on click.\")\n    \"\"\"\n\n    type: Literal[\"AccordionItem\"] = \"AccordionItem\"\n    title: str = Field(description=\"Accordion trigger label\")\n    value: str | None = Field(\n        default=None,\n        description=\"Unique value (defaults to title)\",\n    )\n\n    @overload\n    def __init__(self, title: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, title: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, title: str | None = None, **kwargs: Any) -> None:\n        if title is not None and \"title\" not in kwargs:\n            kwargs[\"title\"] = title\n        super().__init__(**kwargs)\n\n\nclass Accordion(ContainerComponent):\n    \"\"\"Accordion container — children must be ``AccordionItem`` components.\n\n    Example::\n\n        with Accordion(multiple=True, default_open_items=[0, 1]):\n            with AccordionItem(\"Section 1\"):\n                Text(\"Content 1\")\n            with AccordionItem(\"Section 2\"):\n                Text(\"Content 2\")\n    \"\"\"\n\n    type: Literal[\"Accordion\"] = \"Accordion\"\n    multiple: bool = Field(\n        default=False,\n        description=\"Allow multiple items to be open simultaneously\",\n    )\n    collapsible: bool = Field(\n        default=True,\n        description=\"Whether items can be fully collapsed (single mode)\",\n    )\n    default_open_items: int | str | list[int | str] | None = Field(\n        default=None,\n        exclude=True,\n        description=(\n            \"Initially expanded item(s). Pass an int for index-based \"\n            \"selection, or a str to match by value/title.\"\n        ),\n    )\n    default_values: list[str] | None = Field(\n        default=None,\n        alias=\"defaultValues\",\n        description=\"Wire format for default_open_items (always an array).\",\n    )\n\n    def _resolve_item(self, item: int | str) -> str:\n        if isinstance(item, int):\n            child = self.children[item]\n            if not isinstance(child, AccordionItem):\n                raise TypeError(\n                    f\"Child at index {item} is {type(child).__name__}, \"\n                    f\"not AccordionItem\"\n                )\n            return child.value or child.title\n        return item\n\n    def to_json(self) -> dict[str, Any]:\n        if self.default_open_items is not None and self.default_values is None:\n            items = (\n                self.default_open_items\n                if isinstance(self.default_open_items, list)\n                else [self.default_open_items]\n            )\n            self.default_values = [self._resolve_item(i) for i in items]\n        return super().to_json()\n",
  "prefab_ui/components/alert.py": "\"\"\"Alert components following shadcn/ui conventions.\n\nAlerts display important messages to users.\n\nExample::\n\n    from prefab_ui.components import Alert, AlertTitle, AlertDescription\n\n    # Default alert\n    with Alert():\n        AlertTitle(\"Heads up!\")\n        AlertDescription(\"You can add components to your app using the CLI.\")\n\n    # Destructive alert for errors\n    with Alert(variant=\"destructive\"):\n        AlertTitle(\"Error\")\n        AlertDescription(\"Your session has expired. Please log in again.\")\n\n    # Simple alert without title\n    with Alert():\n        AlertDescription(\"Your changes have been saved.\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component, ContainerComponent\n\nAlertVariant = Literal[\"default\", \"destructive\", \"success\", \"warning\", \"info\"]\n\n\nclass Alert(ContainerComponent):\n    \"\"\"An alert container for important messages.\n\n    Args:\n        variant: Visual style - \"default\", \"destructive\"\n        css_class: Additional CSS classes to apply\n\n    Example::\n\n        with Alert():\n            AlertTitle(\"Note\")\n            AlertDescription(\"This is an informational message.\")\n\n        with Alert(variant=\"destructive\"):\n            AlertTitle(\"Error\")\n            AlertDescription(\"Something went wrong.\")\n    \"\"\"\n\n    type: Literal[\"Alert\"] = \"Alert\"\n    variant: AlertVariant = Field(\n        default=\"default\",\n        description=\"Visual variant: default or destructive\",\n    )\n    icon: str | None = Field(\n        default=None,\n        description=\"Lucide icon name (kebab-case, e.g. 'circle-alert')\",\n    )\n\n\nclass AlertTitle(Component):\n    \"\"\"Alert title text.\n\n    Example::\n\n        AlertTitle(\"Important!\")\n        AlertTitle(\"{{ alert_type }}\")\n    \"\"\"\n\n    type: Literal[\"AlertTitle\"] = \"AlertTitle\"\n    content: str = Field(description=\"Title text\")\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept content as positional or keyword argument.\"\"\"\n        if content is not None:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n\n\nclass AlertDescription(Component):\n    \"\"\"Alert description text.\n\n    Example::\n\n        AlertDescription(\"Your changes have been saved successfully.\")\n        AlertDescription(\"{{ message }}\")\n    \"\"\"\n\n    type: Literal[\"AlertDescription\"] = \"AlertDescription\"\n    content: str = Field(description=\"Description text\")\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept content as positional or keyword argument.\"\"\"\n        if content is not None:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/badge.py": "\"\"\"Badge component following shadcn/ui conventions.\n\nBadges display short status indicators or labels.\n\nExample::\n\n    from prefab_ui.components import Badge\n\n    Badge(\"New\")\n    Badge(\"{{ status }}\")\n    Badge(\"Error\", variant=\"destructive\")\n    Badge(\"Draft\", variant=\"secondary\")\n    Badge(\"Custom\", variant=\"outline\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\nBadgeVariant = Literal[\n    \"default\",\n    \"secondary\",\n    \"destructive\",\n    \"success\",\n    \"warning\",\n    \"info\",\n    \"outline\",\n    \"ghost\",\n]\n\n\nclass Badge(ContainerComponent):\n    \"\"\"A badge component for displaying status or labels.\n\n    Args:\n        label: Badge text\n        variant: Visual style - \"default\", \"secondary\", \"destructive\", \"outline\",\n            \"ghost\", \"success\", \"warning\", \"info\"\n        css_class: Additional CSS classes to apply\n\n    Example::\n\n        Badge(\"Active\")\n        Badge(\"{{ user.role }}\")\n        Badge(\"Error\", variant=\"destructive\")\n        Badge(\"Draft\", variant=\"secondary\")\n        Badge(\"Custom\", variant=\"outline\")\n        Badge(\"Ghost\", variant=\"ghost\")\n    \"\"\"\n\n    type: Literal[\"Badge\"] = \"Badge\"\n    label: str | None = Field(default=None, description=\"Badge text\")\n    variant: BadgeVariant = Field(\n        default=\"default\",\n        description=\"Visual variant: default, secondary, destructive, outline, ghost, success, warning, or info\",\n    )\n\n    @overload\n    def __init__(self, label: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, label: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, label: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept label as positional or keyword argument.\"\"\"\n        if label is not None:\n            kwargs[\"label\"] = label\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/base.py": "\"\"\"Base classes for MCP Apps UI components.\"\"\"\n\nfrom __future__ import annotations\n\nimport contextlib\nimport re\nfrom collections.abc import Generator\nfrom contextlib import contextmanager\nfrom contextvars import ContextVar\nfrom typing import Annotated, Any, ClassVar, Literal\n\nfrom pydantic import BaseModel, BeforeValidator, Field, model_validator\nfrom typing_extensions import Self\n\nfrom prefab_ui.css import Responsive\nfrom prefab_ui.rx import Rx, _coerce_rx, _generate_key\n\n_component_stack: ContextVar[list[ContainerComponent] | None] = ContextVar(\n    \"_component_stack\", default=None\n)\n_defer_next_component: ContextVar[bool] = ContextVar(\n    \"_defer_next_component\", default=False\n)\n\n\n@contextmanager\ndef defer() -> Generator[None, None, None]:\n    \"\"\"Create components without attaching them to the current parent.\n\n    Components created inside a ``defer()`` block are **not** automatically\n    appended as children to any enclosing context manager.  Use\n    :func:`insert` later to place them in the tree::\n\n        with Column() as outer:\n            with defer():\n                sidebar = Column()\n                with sidebar:\n                    Text(\"child of sidebar, not outer\")\n            insert(sidebar)\n\n        assert len(outer.children) == 2\n    \"\"\"\n    saved = _component_stack.get()\n    _component_stack.set(None)\n    try:\n        yield\n    finally:\n        _component_stack.set(saved)\n\n\ndef insert(component: Component) -> Component:\n    \"\"\"Insert a deferred component into the current parent context.\n\n    Use this to place a component that was created outside the tree\n    (either before any ``with`` block or inside a ``defer()`` block)\n    as a child of the current container::\n\n        volume = Slider(value=75, defer=True)\n\n        with Column():\n            Text(f\"{volume.rx.number()}%\")\n            insert(volume)  # volume becomes a child of Column here\n\n    Raises :class:`RuntimeError` if called outside a container context\n    or if the component is already a child of another container.\n    \"\"\"\n    stack = _component_stack.get() or []\n    if not stack:\n        raise RuntimeError(\n            \"insert() must be called inside a container context manager \"\n            \"(e.g. inside a `with Column():` block)\"\n        )\n\n    # Check if already attached to a parent\n    for parent in stack:\n        if any(c is component for c in parent.children):\n            raise RuntimeError(\n                \"This component is already a child of a container. \"\n                \"Use model_copy() to create an independent copy.\"\n            )\n\n    stack[-1].children.append(component)\n    return component\n\n\n# ── Gap / Align / Justify ──────────────────────────────────────────────\n\n\ndef _coerce_gap(v: Any) -> int | tuple[int | None, int | None] | Responsive | None:\n    \"\"\"Normalize gap values: None, int, (int,), (x, y), or Responsive.\"\"\"\n    if v is None or isinstance(v, Responsive):\n        return v\n    if isinstance(v, (list, tuple)):\n        if len(v) == 1:\n            return int(v[0])\n        if len(v) == 2:\n            x = int(v[0]) if v[0] is not None else None\n            y = int(v[1]) if v[1] is not None else None\n            return (x, y)\n        raise ValueError(\"gap must have 1 or 2 values\")\n    return int(v)\n\n\nGap = Annotated[\n    int | tuple[int | None, int | None] | Responsive | None,\n    BeforeValidator(_coerce_gap),\n]\n\nAlign = Literal[\"start\", \"center\", \"end\", \"stretch\", \"baseline\"] | None\n\nJustify = (\n    Literal[\"start\", \"center\", \"end\", \"between\", \"around\", \"evenly\", \"stretch\"] | None\n)\n\n\n# ── Layout class compilation ───────────────────────────────────────────\n\n\ndef _gap_classes(gap: int | tuple[int | None, int | None]) -> str:\n    \"\"\"Return Tailwind gap classes for a plain gap value.\"\"\"\n    if isinstance(gap, tuple):\n        parts: list[str] = []\n        x, y = gap\n        if x is not None:\n            parts.append(f\"gap-x-{x}\")\n        if y is not None:\n            parts.append(f\"gap-y-{y}\")\n        return \" \".join(parts)\n    return f\"gap-{gap}\"\n\n\ndef _compile_layout_classes(\n    *,\n    gap: int | tuple[int | None, int | None] | Responsive | None = None,\n    columns: int | dict[str, int] | Responsive | None = None,\n    align: str | None = None,\n    justify: str | None = None,\n) -> str | None:\n    \"\"\"Compile layout kwargs to a Tailwind class string.\"\"\"\n    parts: list[str] = []\n\n    # Gap\n    if gap is not None:\n        if isinstance(gap, Responsive):\n            parts.append(gap.compile_css(_gap_classes))\n        else:\n            parts.append(_gap_classes(gap))\n\n    # Columns\n    if columns is not None:\n        if isinstance(columns, Responsive):\n            parts.append(columns.compile_css(lambda n: f\"grid-cols-{n}\"))\n        elif isinstance(columns, dict):\n            parts.append(Responsive(**columns).compile_css(lambda n: f\"grid-cols-{n}\"))\n        else:\n            parts.append(f\"grid-cols-{columns}\")\n\n    if align is not None:\n        parts.append(f\"items-{align}\")\n    if justify is not None:\n        parts.append(f\"justify-{justify}\")\n    return \" \".join(parts) if parts else None\n\n\ndef _merge_css_classes(*classes: str | None) -> str | None:\n    \"\"\"Merge multiple class strings, returning None if empty.\"\"\"\n    merged = \" \".join(c for c in classes if c)\n    return merged or None\n\n\ndef _coerce_css_class(v: Any) -> str | None:\n    \"\"\"Compile css_class to a flat string.\n\n    Accepts a plain string, a Responsive object, or a list mixing both.\n    \"\"\"\n    if v is None:\n        return None\n    if isinstance(v, list):\n        parts: list[str] = []\n        for item in v:\n            if isinstance(item, Responsive):\n                compiled = item.compile_css(lambda s: str(s))\n                if compiled:\n                    parts.append(compiled)\n            elif item:\n                parts.append(str(item))\n        return \" \".join(parts) or None\n    if isinstance(v, Responsive):\n        compiled = v.compile_css(lambda s: str(s))\n        return compiled or None\n    return str(v)\n\n\n_VALID_STATE_KEY = re.compile(r\"^[a-zA-Z_$][a-zA-Z0-9_$]*$\")\n\n\nclass StatefulMixin:\n    \"\"\"Mixin for components that support reactive state binding via ``.rx``.\n\n    Stateful components (Slider, Input, Checkbox, etc.) inherit from this\n    mixin to gain the ``.rx`` property, which returns an ``Rx`` object\n    serializing to ``{{ name }}`` for template expressions.\n    \"\"\"\n\n    _auto_name: ClassVar[str]\n\n    def __init_subclass__(cls, **kwargs: Any) -> None:\n        super().__init_subclass__(**kwargs)\n\n    def _validate_state_key_name(self) -> None:\n        \"\"\"Raise ValueError if name is not a valid expression identifier.\"\"\"\n        name: str | None = getattr(self, \"name\", None)\n        if name is not None and not _VALID_STATE_KEY.match(name):\n            raise ValueError(\n                f\"Invalid state key name {name!r}: must be a valid identifier \"\n                f\"(letters, digits, underscores — no hyphens). \"\n                f\"'{{{{ {name} }}}}' would be parsed as arithmetic.\"\n            )\n\n    @property\n    def rx(self) -> Rx:\n        \"\"\"Reactive reference to this component's state value.\n\n        Returns an ``Rx`` object that serializes to ``{{ key }}`` and can\n        be passed to any string-typed component field or used in f-strings.\n        \"\"\"\n        name: str | None = getattr(self, \"name\", None)\n        if name is None:\n            raise ValueError(\n                f\"{type(self).__name__}.rx requires a name — \"\n                f\"set _auto_name on the class or pass name= explicitly\"\n            )\n        return Rx(name)\n\n\nclass Component(BaseModel):\n    \"\"\"Base class for all UI components.\n\n    Components serialize to JSON via ``to_json()`` for the React renderer.\n    When created inside a ``ContainerComponent`` context manager, they\n    automatically append themselves to the parent's children list.\n    \"\"\"\n\n    model_config = {\"populate_by_name\": True, \"arbitrary_types_allowed\": True}\n\n    _auto_name: ClassVar[str | None] = None\n    \"\"\"Subclasses set this to a prefix string (e.g. ``\"slider\"``) to opt in\n    to automatic name generation.  When set, components without an explicit\n    ``name`` receive a deterministic sequential key like ``slider-1``.\"\"\"\n\n    css_class: Annotated[str | None, BeforeValidator(_coerce_css_class)] = Field(\n        default=None,\n        alias=\"cssClass\",\n        description=\"CSS/Tailwind classes for styling. Accepts a Responsive() for breakpoint-aware classes.\",\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _coerce_rx_values(cls, data: Any) -> Any:\n        \"\"\"Recursively convert any Rx values in the input dict to strings.\n\n        Also extracts the ``defer`` kwarg (not a model field) and stores it\n        in ``_deferred`` for :meth:`model_post_init` to check.\n        \"\"\"\n        if isinstance(data, dict):\n            data = {k: _coerce_rx(v) for k, v in data.items()}\n            if data.pop(\"defer\", False):\n                _defer_next_component.set(True)\n        return data\n\n    def model_post_init(self, __context: Any) -> None:\n        # Auto-generate name for stateful components when not provided\n        if self._auto_name is not None and \"name\" in type(self).model_fields:\n            if getattr(self, \"name\", None) is None:\n                object.__setattr__(self, \"name\", _generate_key(self._auto_name))\n\n        # Validate state key names on stateful components\n        if isinstance(self, StatefulMixin):\n            self._validate_state_key_name()\n\n        # Skip auto-attach when defer=True was passed\n        if _defer_next_component.get():\n            _defer_next_component.set(False)\n            return\n\n        stack = _component_stack.get() or []\n        if stack:\n            stack[-1].children.append(self)\n\n    def to_json(self) -> dict[str, Any]:\n        \"\"\"Serialize to JSON format for the React renderer.\n\n        Produces ``{\"type\": \"ClassName\", ...props}`` with ``None`` values\n        excluded. Children are serialized recursively.\n        \"\"\"\n        return self.model_dump(by_alias=True, exclude_none=True)\n\n\nclass ContainerComponent(Component):\n    \"\"\"Component that can contain child components.\n\n    Use as a context manager to build nested layouts::\n\n        with Column():\n            Text(\"hello\")\n            Text(\"world\")\n    \"\"\"\n\n    children: list[Component] = Field(default_factory=list)\n    let: dict[str, Any] | None = Field(\n        default=None,\n        description=\"Scoped bindings available to children. Values are template strings.\",\n    )\n\n    def model_post_init(self, __context: Any) -> None:\n        # When children= is passed explicitly, those children were already\n        # auto-attached to the *outer* stack parent during their own __init__.\n        # Remove them from that parent so they only belong to this component.\n        stack = _component_stack.get() or []\n        if stack and self.children:\n            parent_children = stack[-1].children\n            for child in self.children:\n                with contextlib.suppress(ValueError):\n                    parent_children.remove(child)\n        super().model_post_init(__context)\n\n    def __enter__(self) -> Self:\n        stack = _component_stack.get() or []\n        _component_stack.set([*stack, self])\n        return self\n\n    def __exit__(self, *args: Any) -> None:\n        stack = _component_stack.get() or []\n        _component_stack.set(stack[:-1])\n\n    def to_json(self) -> dict[str, Any]:\n        d = super().to_json()\n        # model_dump includes children=[] (not None), so always replace with\n        # recursive serialization or remove the key when empty.\n        d.pop(\"children\", None)\n        if self.children:\n            d[\"children\"] = _serialize_children(self.children)\n        return d\n\n\ndef _to_case(node: Component) -> dict[str, Any]:\n    \"\"\"Convert an If or Elif node to a Condition case entry.\"\"\"\n    condition = getattr(node, \"condition\", \"\")\n    stripped = condition.strip()\n    if not (stripped.startswith(\"{{\") and stripped.endswith(\"}}\")):\n        condition = f\"{{{{ {condition} }}}}\"\n    case: dict[str, Any] = {\"when\": condition}\n    children = getattr(node, \"children\", [])\n    if children:\n        case[\"children\"] = _serialize_children(children)\n    return case\n\n\ndef _serialize_children(children: list[Component]) -> list[dict[str, Any]]:\n    \"\"\"Serialize children, grouping If/Elif/Else chains into Condition nodes.\"\"\"\n    result: list[dict[str, Any]] = []\n    i = 0\n    while i < len(children):\n        child = children[i]\n        child_type = getattr(child, \"type\", None)\n\n        if child_type == \"If\":\n            cases: list[dict[str, Any]] = [_to_case(child)]\n            else_children: list[dict[str, Any]] | None = None\n            i += 1\n            while i < len(children):\n                t = getattr(children[i], \"type\", None)\n                if t == \"Elif\":\n                    cases.append(_to_case(children[i]))\n                    i += 1\n                elif t == \"Else\":\n                    inner = getattr(children[i], \"children\", [])\n                    else_children = _serialize_children(inner)\n                    i += 1\n                    break\n                else:\n                    break\n            node: dict[str, Any] = {\"type\": \"Condition\", \"cases\": cases}\n            if else_children:\n                node[\"else\"] = else_children\n            result.append(node)\n\n        elif child_type in (\"Elif\", \"Else\"):\n            raise ValueError(\n                f\"{child_type} without preceding If — \"\n                f\"Elif and Else must immediately follow an If or Elif\"\n            )\n\n        else:\n            result.append(child.to_json())\n            i += 1\n\n    return result\n",
  "prefab_ui/components/button.py": "\"\"\"Button component following shadcn/ui conventions.\n\nButtons support multiple variants and sizes, with automatic dark mode styling.\n\nExample::\n\n    from prefab_ui.components import Button\n\n    Button(\"Click me\")\n    Button(\"Save\", variant=\"default\")\n    Button(\"Delete\", variant=\"destructive\")\n    Button(\"Cancel\", variant=\"outline\")\n    Button(\"More options\", variant=\"ghost\")\n    Button(\"Learn more\", variant=\"link\")\n\n    # Sizes\n    Button(\"Small\", size=\"sm\")\n    Button(\"Large\", size=\"lg\")\n    Button(\"Icon\", size=\"icon\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component\n\nButtonVariant = Literal[\n    \"default\",\n    \"destructive\",\n    \"outline\",\n    \"secondary\",\n    \"ghost\",\n    \"link\",\n    \"success\",\n    \"warning\",\n    \"info\",\n]\nButtonSize = Literal[\n    \"default\", \"xs\", \"sm\", \"lg\", \"icon\", \"icon-xs\", \"icon-sm\", \"icon-lg\"\n]\n\n\nclass Button(Component):\n    \"\"\"A button component with multiple variants and sizes.\n\n    Args:\n        label: Button text\n        variant: Visual style - \"default\", \"destructive\", \"outline\", \"secondary\", \"ghost\", \"link\"\n        size: Button size - \"default\", \"sm\", \"lg\", \"icon\"\n        disabled: Whether the button is disabled\n        css_class: Additional CSS classes to apply\n\n    Example::\n\n        Button(\"Save Changes\")\n        Button(\"Delete\", variant=\"destructive\")\n        Button(\"Cancel\", variant=\"outline\", size=\"sm\")\n    \"\"\"\n\n    type: Literal[\"Button\"] = \"Button\"\n    label: str = Field(description=\"Button text\")\n    icon: str | None = Field(\n        default=None,\n        description=\"Lucide icon name (kebab-case, e.g. 'arrow-right')\",\n    )\n    variant: ButtonVariant = Field(\n        default=\"default\",\n        description=\"Visual variant: default, destructive, outline, secondary, ghost, link\",\n    )\n    size: ButtonSize = Field(\n        default=\"default\",\n        description=\"Size: default, sm, lg, icon\",\n    )\n    disabled: bool | str = Field(\n        default=False, description=\"Whether the button is disabled\"\n    )\n    on_click: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onClick\",\n        description=\"Action(s) to execute when clicked\",\n    )\n\n    @overload\n    def __init__(self, label: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, label: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, label: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept label as positional or keyword argument.\"\"\"\n        if label is not None:\n            kwargs[\"label\"] = label\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/button_group.py": "\"\"\"ButtonGroup component following shadcn/ui v4 conventions.\n\nGroups buttons together with merged borders and adjusted corners.\n\nExample::\n\n    from prefab_ui.components import Button, ButtonGroup\n\n    with ButtonGroup():\n        Button(\"Previous\")\n        Button(\"Next\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass ButtonGroup(ContainerComponent):\n    \"\"\"A container that groups buttons with merged borders.\n\n    Args:\n        orientation: Layout direction - \"horizontal\" or \"vertical\"\n        css_class: Additional CSS classes to apply\n\n    Example::\n\n        from prefab_ui.components import Button, ButtonGroup\n\n        with ButtonGroup():\n            Button(\"Save\")\n            Button(\"Cancel\", variant=\"outline\")\n\n        with ButtonGroup(orientation=\"vertical\"):\n            Button(\"Top\")\n            Button(\"Middle\")\n            Button(\"Bottom\")\n    \"\"\"\n\n    type: Literal[\"ButtonGroup\"] = \"ButtonGroup\"\n    orientation: Literal[\"horizontal\", \"vertical\"] = Field(\n        default=\"horizontal\",\n        description=\"Layout direction: horizontal or vertical\",\n    )\n",
  "prefab_ui/components/calendar.py": "\"\"\"Calendar component for date selection.\n\nExample::\n\n    from prefab_ui.components import Calendar\n\n    Calendar(name=\"selectedDate\")\n    Calendar(mode=\"range\", name=\"dateRange\")\n\n    # Access reactive value\n    cal = Calendar()\n    Text(f\"Selected: {cal.rx}\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import ClassVar, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component, StatefulMixin\n\n\nclass Calendar(StatefulMixin, Component):\n    \"\"\"Date picker calendar.\n\n    Selected date(s) stored in state as ISO strings.\n\n    Example::\n\n        Calendar(name=\"selectedDate\")\n        Calendar(mode=\"range\", name=\"dateRange\")\n    \"\"\"\n\n    _auto_name: ClassVar[str] = \"calendar\"\n    type: Literal[\"Calendar\"] = \"Calendar\"\n    mode: Literal[\"single\", \"multiple\", \"range\"] = Field(\n        default=\"single\",\n        description=\"Selection mode: single date, multiple dates, or date range\",\n    )\n    name: str | None = Field(\n        default=None,\n        description=\"State key for reactive binding. Auto-generated if omitted.\",\n    )\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) when selection changes\",\n    )\n",
  "prefab_ui/components/card.py": "\"\"\"Card components following shadcn/ui conventions.\n\nCards provide a contained surface for grouping related content.\n\nExample::\n\n    from prefab_ui.components import (\n        Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter\n    )\n    from prefab_ui.components import Button, P\n\n    with Card():\n        with CardHeader():\n            CardTitle(\"Create project\")\n            CardDescription(\"Deploy your new project in one-click.\")\n        with CardContent():\n            P(\"Your project will be created with default settings.\")\n        with CardFooter():\n            Button(\"Cancel\", variant=\"outline\")\n            Button(\"Deploy\")\n\n    # Simple card\n    with Card(css_class=\"p-6\"):\n        H3(\"Quick Stats\")\n        P(\"{{ summary }}\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Card(ContainerComponent):\n    \"\"\"A card container with border and shadow.\n\n    Cards group related content and actions. Use CardHeader, CardContent,\n    and CardFooter for structured layouts.\n\n    Example::\n\n        with Card():\n            CardTitle(\"Title\")\n            P(\"Content\")\n    \"\"\"\n\n    type: Literal[\"Card\"] = \"Card\"\n\n\nclass CardHeader(ContainerComponent):\n    \"\"\"Card header section for title and description.\n\n    Example::\n\n        with CardHeader():\n            CardTitle(\"Account\")\n            CardDescription(\"Manage your account settings.\")\n    \"\"\"\n\n    type: Literal[\"CardHeader\"] = \"CardHeader\"\n\n\nclass CardTitle(ContainerComponent):\n    \"\"\"Card title text.\n\n    Can contain a string or child components.\n\n    Example::\n\n        CardTitle(\"Settings\")\n        CardTitle(\"{{ project_name }}\")\n    \"\"\"\n\n    type: Literal[\"CardTitle\"] = \"CardTitle\"\n    content: str | None = Field(\n        default=None,\n        description=\"Title text (alternative to children)\",\n    )\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str | None = None, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept content as positional or keyword argument.\"\"\"\n        if content is not None and \"content\" not in kwargs:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n\n\nclass CardDescription(ContainerComponent):\n    \"\"\"Card description text, typically below the title.\n\n    Example::\n\n        CardDescription(\"Make changes to your account here.\")\n    \"\"\"\n\n    type: Literal[\"CardDescription\"] = \"CardDescription\"\n    content: str | None = Field(\n        default=None,\n        description=\"Description text (alternative to children)\",\n    )\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str | None = None, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept content as positional or keyword argument.\"\"\"\n        if content is not None and \"content\" not in kwargs:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n\n\nclass CardContent(ContainerComponent):\n    \"\"\"Card content section for the main body.\n\n    Example::\n\n        with CardContent():\n            P(\"Your content here.\")\n    \"\"\"\n\n    type: Literal[\"CardContent\"] = \"CardContent\"\n\n\nclass CardFooter(ContainerComponent):\n    \"\"\"Card footer section, typically for actions.\n\n    Example::\n\n        with CardFooter():\n            Button(\"Cancel\", variant=\"outline\")\n            Button(\"Save\")\n    \"\"\"\n\n    type: Literal[\"CardFooter\"] = \"CardFooter\"\n",
  "prefab_ui/components/checkbox.py": "\"\"\"Checkbox component for binary choices.\n\nCheckboxes let users select one or more options from a set.\n\nExample::\n\n    from prefab_ui.components import Checkbox, Label\n\n    Checkbox(checked=True, label=\"Accept terms\")\n    Checkbox(label=\"Subscribe to newsletter\")\n\n    # Access reactive value\n    agree = Checkbox(label=\"I agree\")\n    Text(f\"Agreed: {agree.rx}\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import ClassVar, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component, StatefulMixin\n\n\nclass Checkbox(StatefulMixin, Component):\n    \"\"\"Checkbox input component.\n\n    Args:\n        label: Label text to display next to checkbox\n        checked: Whether checkbox is checked\n        name: Form field name\n        value: Form value when checked\n        disabled: Whether checkbox is disabled\n        required: Whether checkbox is required\n        css_class: Additional CSS classes\n\n    Example::\n\n        Checkbox(label=\"Remember me\")\n        Checkbox(checked=True, label=\"Agreed\")\n        Checkbox(label=\"Enable {{ feature_name }}\", checked=\"{{ is_enabled }}\")\n    \"\"\"\n\n    _auto_name: ClassVar[str] = \"checkbox\"\n    type: Literal[\"Checkbox\"] = \"Checkbox\"\n    label: str | None = Field(default=None, description=\"Label text\")\n    checked: bool = Field(default=False, description=\"Whether checkbox is checked\")\n    name: str | None = Field(\n        default=None,\n        description=\"State key for reactive binding. Auto-generated if omitted.\",\n    )\n    value: str | None = Field(default=None, description=\"Form value\")\n    disabled: bool = Field(default=False, description=\"Whether checkbox is disabled\")\n    required: bool = Field(default=False, description=\"Whether checkbox is required\")\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) to execute when checked state changes\",\n    )\n",
  "prefab_ui/components/code.py": "\"\"\"Code block display component.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\n\n\nclass Code(Component):\n    \"\"\"Code block with optional syntax highlighting.\n\n    Example::\n\n        Code(\"{{ source_code }}\", language=\"python\")\n    \"\"\"\n\n    type: Literal[\"Code\"] = \"Code\"\n    content: str = Field(description=\"Code content\")\n    language: str | None = Field(\n        default=None, description=\"Syntax highlighting language\"\n    )\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept content as positional or keyword argument.\"\"\"\n        if content is not None:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/column.py": "\"\"\"Column layout container.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import (\n    Align,\n    ContainerComponent,\n    Gap,\n    Justify,\n    _compile_layout_classes,\n    _merge_css_classes,\n)\n\n\nclass Column(ContainerComponent):\n    \"\"\"Vertical flex container.\n\n    Example::\n\n        with Column():\n            Heading(\"Title\")\n            Text(\"Body\")\n\n        with Column(gap=4):\n            Heading(\"Title\")\n            Text(\"Body\")\n    \"\"\"\n\n    type: Literal[\"Column\"] = \"Column\"\n    gap: Gap = Field(default=None, exclude=True)\n    align: Align = Field(default=None, exclude=True)\n    justify: Justify = Field(default=None, exclude=True)\n\n    def model_post_init(self, __context: Any) -> None:\n        layout = _compile_layout_classes(\n            gap=self.gap, align=self.align, justify=self.justify\n        )\n        self.css_class = _merge_css_classes(layout, self.css_class)\n        super().model_post_init(__context)\n",
  "prefab_ui/components/combobox.py": "\"\"\"Combobox — searchable select dropdown.\n\nA filterable dropdown for selecting from large option lists. Options are\ndefined as ``ComboboxOption`` children, similar to ``Select``/``SelectOption``.\n\nExample::\n\n    from prefab_ui.components import Combobox, ComboboxOption\n\n    with Combobox(placeholder=\"Select a framework...\", name=\"framework\"):\n        ComboboxOption(\"Next.js\", value=\"nextjs\")\n        ComboboxOption(\"Remix\", value=\"remix\")\n        ComboboxOption(\"Astro\", value=\"astro\")\n        ComboboxOption(\"SvelteKit\", value=\"sveltekit\")\n\n    # Access reactive value\n    combo = Combobox(placeholder=\"Choose framework...\")\n    Text(f\"Selected: {combo.rx}\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, ClassVar, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component, ContainerComponent, StatefulMixin\n\n\nclass ComboboxOption(Component):\n    \"\"\"A single option within a Combobox.\n\n    Example::\n\n        ComboboxOption(\"Next.js\", value=\"nextjs\")\n    \"\"\"\n\n    type: Literal[\"ComboboxOption\"] = \"ComboboxOption\"\n    value: str = Field(description=\"Option value\")\n    label: str = Field(description=\"Display label\")\n    disabled: bool = Field(default=False, description=\"Whether option is disabled\")\n\n    @overload\n    def __init__(self, label: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, label: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, label: str | None = None, **kwargs: Any) -> None:\n        if label is not None and \"label\" not in kwargs:\n            kwargs[\"label\"] = label\n        if \"value\" not in kwargs and label is not None:\n            kwargs[\"value\"] = label.lower().replace(\" \", \"-\")\n        super().__init__(**kwargs)\n\n\nclass Combobox(StatefulMixin, ContainerComponent):\n    \"\"\"Searchable select dropdown.\n\n    Children must be ``ComboboxOption`` components.\n\n    Args:\n        placeholder: Placeholder text when no value selected\n        search_placeholder: Placeholder text in the search input\n        name: State key for the selected value\n        disabled: Whether the combobox is disabled\n\n    Example::\n\n        with Combobox(placeholder=\"Pick a language...\", name=\"lang\"):\n            ComboboxOption(\"Python\", value=\"python\")\n            ComboboxOption(\"TypeScript\", value=\"typescript\")\n            ComboboxOption(\"Rust\", value=\"rust\")\n    \"\"\"\n\n    _auto_name: ClassVar[str] = \"combobox\"\n    type: Literal[\"Combobox\"] = \"Combobox\"\n    placeholder: str | None = Field(\n        default=None,\n        description=\"Placeholder text shown when no value is selected\",\n    )\n    search_placeholder: str | None = Field(\n        default=None,\n        alias=\"searchPlaceholder\",\n        description=\"Placeholder text in the search input\",\n    )\n    name: str | None = Field(\n        default=None,\n        description=\"State key for reactive binding. Auto-generated if omitted.\",\n    )\n    disabled: bool = Field(default=False, description=\"Whether combobox is disabled\")\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) when the selected value changes\",\n    )\n",
  "prefab_ui/components/container.py": "\"\"\"Responsive container with sensible defaults.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Container(ContainerComponent):\n    \"\"\"A centered, max-width container with responsive padding.\n\n    Wraps content in Tailwind's ``container`` with automatic horizontal\n    centering and padding that scales with the viewport.\n\n    Example::\n\n        with Container():\n            H1(\"Dashboard\")\n            Grid(columns=3):\n                ...\n    \"\"\"\n\n    type: Literal[\"Container\"] = \"Container\"\n",
  "prefab_ui/components/dashboard.py": "\"\"\"Dashboard layout for explicit cell placement.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import (\n    ContainerComponent,\n    Gap,\n    _compile_layout_classes,\n    _merge_css_classes,\n)\n\n\nclass Dashboard(ContainerComponent):\n    \"\"\"Explicit-placement grid for dashboard layouts.\n\n    Unlike ``Grid`` (auto-flow), ``Dashboard`` places children at\n    specific grid coordinates using ``DashboardItem`` wrappers::\n\n        with Dashboard(columns=12, row_height=120, gap=4):\n            with DashboardItem(col=1, row=1, col_span=8, row_span=3):\n                LineChart(...)\n            with DashboardItem(col=9, row=1, col_span=4, row_span=1):\n                Text(\"Revenue: $42M\")\n\n    Positions are **1-indexed** (matching CSS Grid conventions).\n    \"\"\"\n\n    type: Literal[\"Dashboard\"] = \"Dashboard\"\n    columns: int = Field(default=12, description=\"Number of grid columns.\")\n    row_height: int | str = Field(\n        default=120,\n        alias=\"rowHeight\",\n        description=\"Height of each auto-generated row. Integer for pixels, string for any CSS value.\",\n    )\n    rows: int | None = Field(\n        default=None,\n        description=\"Fixed number of rows. Omit for auto-expanding rows.\",\n    )\n    gap: Gap = Field(default=None, exclude=True)\n\n    def model_post_init(self, __context: Any) -> None:\n        layout = _compile_layout_classes(gap=self.gap)\n        self.css_class = _merge_css_classes(layout, self.css_class)\n        super().model_post_init(__context)\n\n\nclass DashboardItem(ContainerComponent):\n    \"\"\"A positioned cell within a ``Dashboard``.\n\n    Specifies where this item sits and how many columns/rows it spans::\n\n        DashboardItem(col=1, row=1, col_span=4, row_span=2)\n\n    Positions are **1-indexed**.\n    \"\"\"\n\n    type: Literal[\"DashboardItem\"] = \"DashboardItem\"\n    col: int = Field(default=1, description=\"Starting column (1-indexed).\")\n    row: int = Field(default=1, description=\"Starting row (1-indexed).\")\n    col_span: int = Field(\n        default=1, alias=\"colSpan\", description=\"Number of columns to span.\"\n    )\n    row_span: int = Field(\n        default=1, alias=\"rowSpan\", description=\"Number of rows to span.\"\n    )\n    z_index: int | None = Field(\n        default=None, alias=\"zIndex\", description=\"CSS z-index for layering.\"\n    )\n",
  "prefab_ui/components/data_table.py": "\"\"\"DataTable — a high-level table with built-in sorting, filtering, pagination.\n\nBuilt on @tanstack/react-table in the renderer.\n\nExample::\n\n    from prefab_ui.components import DataTable, DataTableColumn\n\n    DataTable(\n        columns=[\n            DataTableColumn(key=\"name\", header=\"Name\", sortable=True),\n            DataTableColumn(key=\"email\", header=\"Email\"),\n            DataTableColumn(key=\"role\", header=\"Role\"),\n        ],\n        rows=\"{{ users }}\",\n        searchable=True,\n        paginated=True,\n    )\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import BaseModel, Field\n\nfrom prefab_ui.components.base import Component\n\n\nclass DataTableColumn(BaseModel):\n    \"\"\"Column definition for DataTable.\"\"\"\n\n    model_config = {\"populate_by_name\": True}\n\n    key: str = Field(description=\"Data key to display in this column\")\n    header: str = Field(description=\"Column header text\")\n    sortable: bool = Field(default=False, description=\"Enable sorting for this column\")\n\n\nclass DataTable(Component):\n    \"\"\"High-level data table with sorting, filtering, and pagination.\n\n    Accepts flat ``columns`` and ``rows`` — the renderer handles the rest.\n\n    Example::\n\n        DataTable(\n            columns=[\n                DataTableColumn(key=\"name\", header=\"Name\", sortable=True),\n                DataTableColumn(key=\"email\", header=\"Email\"),\n            ],\n            rows=data[\"users\"],\n            searchable=True,\n            paginated=True,\n        )\n    \"\"\"\n\n    type: Literal[\"DataTable\"] = \"DataTable\"\n    columns: list[DataTableColumn] = Field(description=\"Column definitions\")\n    rows: list[dict[str, Any]] | str = Field(\n        default_factory=list,\n        description=\"Row data or {{ interpolation }} reference\",\n    )\n    searchable: bool = Field(default=False, description=\"Show search/filter input\")\n    paginated: bool = Field(default=False, description=\"Show pagination controls\")\n    page_size: int = Field(\n        default=10, alias=\"pageSize\", description=\"Rows per page when paginated\"\n    )\n    caption: str | None = Field(default=None, description=\"Optional table caption\")\n",
  "prefab_ui/components/date_picker.py": "\"\"\"DatePicker — popover with a calendar for selecting dates.\n\nExample::\n\n    from prefab_ui.components import DatePicker\n\n    DatePicker(placeholder=\"Select deadline\", name=\"deadline\")\n\n    # Access reactive value\n    picker = DatePicker(placeholder=\"Choose date...\")\n    Text(f\"Date: {picker.rx}\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import ClassVar, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component, StatefulMixin\n\n\nclass DatePicker(StatefulMixin, Component):\n    \"\"\"Date picker with a popover calendar.\n\n    A button trigger shows the selected date; clicking opens a calendar.\n\n    Example::\n\n        DatePicker(placeholder=\"Pick a date\", name=\"deadline\")\n    \"\"\"\n\n    _auto_name: ClassVar[str] = \"datepicker\"\n    type: Literal[\"DatePicker\"] = \"DatePicker\"\n    placeholder: str = Field(\n        default=\"Pick a date\",\n        description=\"Button text when no date is selected\",\n    )\n    name: str | None = Field(\n        default=None,\n        description=\"State key for reactive binding. Auto-generated if omitted.\",\n    )\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) when date changes\",\n    )\n",
  "prefab_ui/components/dialog.py": "\"\"\"Dialog (modal) — overlay with a trigger and content.\n\nThe first child becomes the trigger; remaining children become the dialog body.\n\nExample::\n\n    from prefab_ui.components import Dialog, Button, Text, Row\n    from prefab_ui.actions.mcp import CallTool\n\n    with Dialog(title=\"Confirm Delete\", description=\"This action cannot be undone.\"):\n        Button(\"Delete\", variant=\"destructive\")  # trigger\n        Text(\"Are you sure you want to delete this item?\")\n        with Row(gap=2):\n            Button(\"Cancel\", variant=\"outline\")\n            Button(\"Confirm\", on_click=CallTool(\"delete_item\"))\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Dialog(ContainerComponent):\n    \"\"\"Modal dialog overlay.\n\n    First child = trigger, remaining children = dialog body.\n\n    Example::\n\n        with Dialog(title=\"Edit Profile\"):\n            Button(\"Edit\")\n            with Column(gap=3):\n                Input(name=\"displayName\", placeholder=\"Display name\")\n                Button(\"Save\", on_click=CallTool(\"update_profile\"))\n    \"\"\"\n\n    type: Literal[\"Dialog\"] = \"Dialog\"\n    title: str | None = Field(default=None, description=\"Dialog header title\")\n    description: str | None = Field(\n        default=None, description=\"Dialog header description\"\n    )\n",
  "prefab_ui/components/div.py": "\"\"\"Generic div and span containers with no default styling.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component, ContainerComponent\n\n\nclass Div(ContainerComponent):\n    \"\"\"A bare container with no default styling.\n\n    This is the Python equivalent of ``<div className=\"...\">`` in React.\n    Use when you need a wrapper with custom Tailwind classes that\n    Column/Row/Grid don't naturally express.\n\n    Example::\n\n        with Div(css_class=\"flex items-center gap-4 px-6 py-4\"):\n            Badge(\"deploy\", variant=\"outline\")\n            P(\"Deployed v2.4.1\")\n\n    For CSS that Tailwind can't express (vendor prefixes, ``clamp()``,\n    ``mask-image``, etc.), use the *style* escape hatch::\n\n        Div(style={\"mask-image\": \"linear-gradient(to bottom, black 70%, transparent)\"})\n    \"\"\"\n\n    type: Literal[\"Div\"] = \"Div\"\n    style: dict[str, str] | None = Field(\n        default=None, description=\"Inline CSS styles as a dict of property/value pairs.\"\n    )\n\n\nclass Span(Component):\n    \"\"\"An inline text element with no default styling.\n\n    Example::\n\n        Span(\"14m ago\", css_class=\"text-sm text-muted-foreground\")\n    \"\"\"\n\n    type: Literal[\"Span\"] = \"Span\"\n    content: str = Field(description=\"Text content\")\n    style: dict[str, str] | None = Field(\n        default=None, description=\"Inline CSS styles as a dict of property/value pairs.\"\n    )\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        if content is not None:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/drop_zone.py": "\"\"\"DropZone component for drag-and-drop file uploads.\n\nA styled drag-and-drop area where users can drop files or click to browse.\nReads selected files to base64 and fires ``onChange`` with structured file data.\n\nExample::\n\n    from prefab_ui.components import DropZone\n    from prefab_ui.actions.mcp import CallTool\n\n    DropZone(\n        label=\"Drop files here\",\n        accept=\"image/*\",\n        multiple=True,\n        on_change=CallTool(\"process_images\", arguments={\"files\": \"{{ $event }}\"}),\n    )\n\n    # Access reactive value\n    zone = DropZone(label=\"Drop files\", accept=\"image/*\")\n    Text(f\"Files: {zone.rx}\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import ClassVar, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component, StatefulMixin\n\n\nclass DropZone(StatefulMixin, Component):\n    \"\"\"Drag-and-drop file upload area.\n\n    Fires ``onChange`` with file data as ``$event``:\n    - Single file mode: ``{name, size, type, data}`` (data = raw base64)\n    - Multiple file mode: ``[{name, size, type, data}, ...]``\n\n    Args:\n        label: Primary prompt text shown in the drop zone.\n        description: Secondary text below the label (e.g. file type hints).\n        accept: File type filter (e.g. ``\"image/*\"``, ``\".csv,.xlsx\"``).\n        multiple: Allow dropping multiple files.\n        max_size: Maximum file size in bytes per file.\n        disabled: Whether the drop zone is disabled.\n        name: State key for auto-state binding.\n        on_change: Action(s) to execute when files are selected.\n    \"\"\"\n\n    _auto_name: ClassVar[str] = \"dropzone\"\n    type: Literal[\"DropZone\"] = \"DropZone\"\n    icon: str | None = Field(\n        default=None,\n        description=\"Lucide icon name (kebab-case, e.g. 'cloud-upload'). \"\n        \"Defaults to an upload icon when not specified.\",\n    )\n    label: str | None = Field(\n        default=None,\n        description=\"Primary prompt text (e.g. 'Drop files here')\",\n    )\n    description: str | None = Field(\n        default=None,\n        description=\"Secondary helper text (e.g. 'PNG, JPG up to 10MB')\",\n    )\n    accept: str | None = Field(\n        default=None,\n        description=\"File type filter (e.g. 'image/*', '.csv,.xlsx')\",\n    )\n    multiple: bool = Field(\n        default=False,\n        description=\"Allow selecting multiple files\",\n    )\n    max_size: int | None = Field(\n        default=None,\n        alias=\"maxSize\",\n        description=\"Maximum file size in bytes per file\",\n    )\n    disabled: bool = Field(\n        default=False,\n        description=\"Whether the drop zone is disabled\",\n    )\n    name: str | None = Field(\n        default=None,\n        description=\"State key for reactive binding. Auto-generated if omitted.\",\n    )\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) to execute when files are selected\",\n    )\n",
  "prefab_ui/components/field.py": "\"\"\"Field component for choice card layouts.\n\nField wraps a form control (Switch, Checkbox, etc.) in a bordered card\nwith a title and optional description. Clicking anywhere on the card\nactivates the wrapped control.\n\nExample::\n\n    from prefab_ui.components import Field, Switch\n\n    with Field(title=\"Dark mode\", description=\"Use dark theme\"):\n        Switch(name=\"dark_mode\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field as PydanticField\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Field(ContainerComponent):\n    \"\"\"Choice card container for form controls.\n\n    Renders a bordered card with title/description on the left and\n    the child control on the right. The entire card is clickable.\n\n    Args:\n        title: Card heading text (required).\n        description: Secondary text below the title.\n        disabled: Whether the field is dimmed and non-interactive.\n\n    Example::\n\n        with Field(title=\"Notifications\", description=\"Get notified\"):\n            Switch(name=\"notifications\")\n    \"\"\"\n\n    type: Literal[\"Field\"] = \"Field\"\n    title: str = PydanticField(description=\"Card heading text\")\n    description: str | None = PydanticField(\n        default=None, description=\"Secondary text below the title\"\n    )\n    disabled: bool = PydanticField(\n        default=False, description=\"Whether the field is dimmed and non-interactive\"\n    )\n",
  "prefab_ui/components/form.py": "\"\"\"Form component with Pydantic model integration.\n\nForms group inputs with labels. The ``from_model()`` classmethod generates\na complete form from a Pydantic model's field definitions, using Pydantic\n``Field()`` metadata for labels, descriptions, constraints, and UI hints.\n\nExample::\n\n    from pydantic import BaseModel, Field\n    from prefab_ui.components import Form\n\n    class UserProfile(BaseModel):\n        name: str = Field(title=\"Full Name\", min_length=1)\n        email: str\n        age: int = Field(ge=0, le=150)\n        active: bool = True\n\n    Form.from_model(UserProfile, on_submit=CallTool(\"save_profile\"))\n\"\"\"\n\nfrom __future__ import annotations\n\nimport datetime\nimport types\nfrom typing import Any, Literal, Union, get_args, get_origin, overload\n\nimport annotated_types\nfrom pydantic import BaseModel, Field, SecretStr\nfrom pydantic.fields import FieldInfo\nfrom pydantic_core import PydanticUndefined\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.actions.mcp import CallTool\nfrom prefab_ui.actions.ui import ShowToast\nfrom prefab_ui.components.base import (\n    ContainerComponent,\n    _compile_layout_classes,\n    _merge_css_classes,\n    defer,\n)\n\n\nclass Form(ContainerComponent):\n    \"\"\"Form container that groups labeled inputs.\n\n    Use ``Form.from_model()`` to auto-generate a form from a Pydantic model,\n    or build forms manually with context-manager syntax.\n\n    Example::\n\n        with Form():\n            Label(\"Name\")\n            Input(name=\"name\", placeholder=\"Your name\")\n            Button(\"Submit\", on_click=CallTool(\"save\"))\n    \"\"\"\n\n    type: Literal[\"Form\"] = \"Form\"\n    gap: int = Field(default=4, exclude=True)\n    on_submit: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onSubmit\",\n        description=\"Action(s) to execute when the form is submitted\",\n    )\n\n    def model_post_init(self, __context: Any) -> None:\n        layout = _compile_layout_classes(gap=self.gap)\n        self.css_class = _merge_css_classes(layout, self.css_class)\n        super().model_post_init(__context)\n\n    @overload\n    @classmethod\n    def from_model(\n        cls,\n        model: type[BaseModel],\n        *,\n        fields_only: Literal[True],\n        submit_label: str = \"Submit\",\n        on_submit: Action | list[Action] | None = None,\n        css_class: str | None = None,\n    ) -> list[Any]: ...\n\n    @overload\n    @classmethod\n    def from_model(\n        cls,\n        model: type[BaseModel],\n        *,\n        fields_only: Literal[False] = ...,\n        submit_label: str = \"Submit\",\n        on_submit: Action | list[Action] | None = None,\n        css_class: str | None = None,\n    ) -> Form: ...\n\n    @classmethod\n    def from_model(\n        cls,\n        model: type[BaseModel],\n        *,\n        fields_only: bool = False,\n        submit_label: str = \"Submit\",\n        on_submit: Action | list[Action] | None = None,\n        css_class: str | None = None,\n    ) -> Form | list[Any]:\n        \"\"\"Generate a form from a Pydantic model.\n\n        Introspects the model's fields and creates appropriate input\n        components for each, using Pydantic ``Field()`` metadata:\n\n        - ``title`` → label text (falls back to humanized field name)\n        - ``description`` → placeholder / help text\n        - ``min_length`` / ``max_length`` → HTML input constraints\n        - ``ge`` / ``le`` / ``gt`` / ``lt`` → number min/max\n        - ``json_schema_extra={\"ui\": {\"type\": \"textarea\"}}`` → textarea\n        - ``SecretStr`` → password input\n        - ``exclude=True`` → skip field\n\n        Type mapping:\n\n        - ``str`` → text input (email/password/tel/url detected by name)\n        - ``int`` / ``float`` → number input\n        - ``bool`` → checkbox\n        - ``datetime.date`` → date input\n        - ``datetime.time`` → time input\n        - ``datetime.datetime`` → datetime-local input\n        - ``Literal[...]`` → select dropdown\n        - ``SecretStr`` → password input\n\n        When ``on_submit`` is a single ``CallTool`` with no ``arguments``,\n        arguments are auto-filled from the model's fields under a ``data``\n        key. This enables the self-calling tool pattern::\n\n            Form.from_model(Contact, on_submit=CallTool(\"create_contact\"))\n            # auto-generates: arguments={\"data\": {\"name\": \"{{ name }}\", ...}}\n\n        A default ``on_error`` toast is added if not already specified.\n\n        When ``fields_only=True``, only the field components (labeled\n        inputs) are created — no ``Form`` wrapper and no submit button.\n        The fields auto-parent to whatever context manager is active,\n        letting you compose them into custom layouts::\n\n            with Form(on_submit=CallTool(\"save\")):\n                with CardContent():\n                    Form.from_model(Contact, fields_only=True)\n                with CardFooter():\n                    Button(\"Submit\")\n\n        Args:\n            model: Pydantic model class to generate from.\n            fields_only: If True, generate only field components without\n                a Form wrapper or submit button. Returns a list of the\n                created components.\n            submit_label: Text for the submit button.\n            on_submit: Action(s) fired on submit. A ``CallTool`` with no\n                arguments gets auto-filled from model fields.\n            css_class: Additional CSS classes on the form container.\n        \"\"\"\n        from prefab_ui.components.base import _component_stack\n        from prefab_ui.components.button import Button\n\n        if fields_only:\n            # Suppress auto-parenting during creation to avoid duplicates\n            # (Labels/Inputs would otherwise auto-parent to both the\n            # Column AND the outer context). Then manually add the\n            # top-level field components to the active context.\n            saved_stack = _component_stack.get()\n            with defer():\n                children: list[Any] = []\n                for name, field_info in model.model_fields.items():\n                    component = _field_to_component(name, field_info)\n                    if component is not None:\n                        children.append(component)\n\n            if saved_stack:\n                for child in children:\n                    saved_stack[-1].children.append(child)\n\n            return children\n\n        on_submit = _maybe_enrich_tool_call(on_submit, model)\n\n        # Form is created with the stack active so it auto-parents to any\n        # outer context manager (e.g. ``with Card(): Form.from_model(...)``).\n        form = cls(on_submit=on_submit, css_class=css_class)\n\n        # Suppress auto-parenting while building internal components so\n        # they don't also get auto-added to the outer container.\n        with defer():\n            children = []\n\n            for name, field_info in model.model_fields.items():\n                component = _field_to_component(name, field_info)\n                if component is not None:\n                    children.append(component)\n\n            if on_submit is not None:\n                children.append(Button(submit_label, on_click=on_submit))\n\n        form.children = children\n        return form\n\n\ndef _maybe_enrich_tool_call(\n    on_submit: Action | list[Action] | None,\n    model: type[BaseModel],\n) -> Action | list[Action] | None:\n    \"\"\"Auto-fill CallTool arguments from model fields when empty.\n\n    Only triggers when on_submit is a single CallTool with no arguments.\n    Wraps field templates under a ``data`` key so the receiving tool gets\n    ``data: Model`` as a single parameter.\n    \"\"\"\n    if not isinstance(on_submit, CallTool):\n        return on_submit\n    if on_submit.arguments:\n        return on_submit\n\n    field_templates = {\n        name: \"{{ \" + name + \" }}\"\n        for name in model.model_fields\n        if not (model.model_fields[name].exclude)\n    }\n\n    kwargs: dict[str, Any] = {\n        \"tool\": on_submit.tool,\n        \"arguments\": {\"data\": field_templates},\n    }\n    if on_submit.result_key is not None:\n        kwargs[\"result_key\"] = on_submit.result_key\n    if on_submit.on_success is not None:\n        kwargs[\"on_success\"] = on_submit.on_success\n    if on_submit.on_error is not None:\n        kwargs[\"on_error\"] = on_submit.on_error\n    else:\n        kwargs[\"on_error\"] = ShowToast(\"{{ $error }}\", variant=\"error\")\n\n    return CallTool(**kwargs)\n\n\ndef _humanize(name: str) -> str:\n    \"\"\"Convert snake_case field name to Title Case label.\"\"\"\n    return name.replace(\"_\", \" \").title()\n\n\ndef _unwrap_optional(annotation: Any) -> tuple[Any, bool]:\n    \"\"\"Strip Optional/Union[X, None] wrapper, returning (inner_type, is_optional).\"\"\"\n    origin = get_origin(annotation)\n    if origin is Union or origin is types.UnionType:\n        args = [a for a in get_args(annotation) if a is not type(None)]\n        if len(args) == 1:\n            return args[0], True\n    return annotation, False\n\n\ndef _is_literal(annotation: Any) -> bool:\n    return get_origin(annotation) is Literal\n\n\ndef _extract_constraints(field_info: FieldInfo) -> dict[str, Any]:\n    \"\"\"Extract numeric and string constraints from Pydantic field metadata.\"\"\"\n    constraints: dict[str, Any] = {}\n    for meta in field_info.metadata:\n        if isinstance(meta, annotated_types.MinLen):\n            constraints[\"min_length\"] = meta.min_length\n        elif isinstance(meta, annotated_types.MaxLen):\n            constraints[\"max_length\"] = meta.max_length\n        elif isinstance(meta, annotated_types.Ge):\n            constraints[\"min\"] = meta.ge\n        elif isinstance(meta, annotated_types.Le):\n            constraints[\"max\"] = meta.le\n        elif isinstance(meta, annotated_types.Gt):\n            constraints[\"min\"] = meta.gt\n        elif isinstance(meta, annotated_types.Lt):\n            constraints[\"max\"] = meta.lt\n        elif isinstance(meta, annotated_types.MultipleOf):\n            constraints[\"step\"] = meta.multiple_of\n        elif hasattr(meta, \"pattern\") and not isinstance(meta, type):\n            constraints[\"pattern\"] = meta.pattern\n    return constraints\n\n\ndef _get_ui_hints(field_info: FieldInfo) -> dict[str, Any]:\n    \"\"\"Extract UI hints from json_schema_extra.\"\"\"\n    extra = field_info.json_schema_extra\n    if isinstance(extra, dict):\n        ui = extra.get(\"ui\")  # type: ignore[union-attr]\n        if isinstance(ui, dict):\n            return ui\n    return {}\n\n\ndef _field_to_component(name: str, field_info: FieldInfo) -> Any:\n    \"\"\"Map a single Pydantic field to the appropriate form component(s).\"\"\"\n    from prefab_ui.components.checkbox import Checkbox\n    from prefab_ui.components.column import Column\n    from prefab_ui.components.input import Input\n    from prefab_ui.components.label import Label\n    from prefab_ui.components.select import Select, SelectOption\n    from prefab_ui.components.textarea import Textarea\n\n    annotation = field_info.annotation\n    if annotation is None:\n        return None\n\n    if field_info.exclude:\n        return None\n\n    inner, is_optional = _unwrap_optional(annotation)\n    required = not is_optional and field_info.is_required()\n\n    label_text = field_info.title or _humanize(name)\n    placeholder = field_info.description or label_text\n    default = (\n        field_info.default if field_info.default is not PydanticUndefined else None\n    )\n    constraints = _extract_constraints(field_info)\n    ui_hints = _get_ui_hints(field_info)\n\n    # UI hint override: textarea\n    if ui_hints.get(\"type\") == \"textarea\":\n        rows = ui_hints.get(\"rows\")\n        value = str(default) if isinstance(default, str) else None\n        col = Column(gap=2)\n        col.children = [\n            Label(label_text),\n            Textarea(\n                name=name,\n                placeholder=placeholder,\n                value=value,\n                rows=rows,\n                required=required,\n                min_length=constraints.get(\"min_length\"),\n                max_length=constraints.get(\"max_length\"),\n            ),\n        ]\n        return col\n\n    # Literal → Select dropdown\n    if _is_literal(inner):\n        options = get_args(inner)\n        select = Select(name=name, placeholder=placeholder, required=required)\n        for opt in options:\n            opt_str = str(opt)\n            select.children.append(\n                SelectOption(\n                    value=opt_str,\n                    label=_humanize(opt_str),\n                    selected=default == opt,\n                )\n            )\n        col = Column(gap=2)\n        col.children = [Label(label_text), select]\n        return col\n\n    # bool → Checkbox\n    if inner is bool:\n        checked = bool(default) if default is not None else False\n        return Checkbox(label=label_text, name=name, checked=checked)\n\n    # SecretStr → password input\n    if inner is SecretStr:\n        col = Column(gap=2)\n        col.children = [\n            Label(label_text),\n            Input(\n                input_type=\"password\",\n                name=name,\n                placeholder=placeholder,\n                required=required,\n                min_length=constraints.get(\"min_length\"),\n                max_length=constraints.get(\"max_length\"),\n            ),\n        ]\n        return col\n\n    # date/time types → specialized input\n    if inner is datetime.date:\n        col = Column(gap=2)\n        col.children = [\n            Label(label_text),\n            Input(input_type=\"date\", name=name, required=required),\n        ]\n        return col\n\n    if inner is datetime.time:\n        col = Column(gap=2)\n        col.children = [\n            Label(label_text),\n            Input(input_type=\"time\", name=name, required=required),\n        ]\n        return col\n\n    if inner is datetime.datetime:\n        col = Column(gap=2)\n        col.children = [\n            Label(label_text),\n            Input(input_type=\"datetime-local\", name=name, required=required),\n        ]\n        return col\n\n    # int / float → number input\n    if inner in (int, float):\n        value = str(default) if default is not None else None\n        col = Column(gap=2)\n        col.children = [\n            Label(label_text),\n            Input(\n                input_type=\"number\",\n                name=name,\n                placeholder=placeholder,\n                value=value,\n                required=required,\n                min=constraints.get(\"min\"),\n                max=constraints.get(\"max\"),\n                step=constraints.get(\"step\"),\n            ),\n        ]\n        return col\n\n    # Skip unsupported complex types (lists, dicts, nested models)\n    origin = get_origin(inner)\n    if origin in (list, dict, set, frozenset, tuple):\n        return None\n    if isinstance(inner, type) and issubclass(inner, BaseModel):\n        return None\n\n    # str (default) → text input, detect email by field name\n    input_type = \"text\"\n    if \"email\" in name.lower():\n        input_type = \"email\"\n    elif \"password\" in name.lower():\n        input_type = \"password\"\n    elif \"phone\" in name.lower() or \"tel\" in name.lower():\n        input_type = \"tel\"\n    elif \"url\" in name.lower() or \"website\" in name.lower():\n        input_type = \"url\"\n\n    value = str(default) if isinstance(default, str) else None\n    col = Column(gap=2)\n    col.children = [\n        Label(label_text),\n        Input(\n            input_type=input_type,\n            name=name,\n            placeholder=placeholder,\n            value=value,\n            required=required,\n            min_length=constraints.get(\"min_length\"),\n            max_length=constraints.get(\"max_length\"),\n            pattern=constraints.get(\"pattern\"),\n        ),\n    ]\n    return col\n",
  "prefab_ui/components/grid.py": "\"\"\"Grid layout container.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import (\n    Align,\n    ContainerComponent,\n    Gap,\n    Justify,\n    Responsive,\n    _compile_layout_classes,\n    _merge_css_classes,\n)\n\n\ndef _compile_column_template(columns: list[int | str]) -> str:\n    \"\"\"Compile a column list to a CSS grid-template-columns value.\n\n    Integers become ``Nfr`` (fractional units); strings pass through as-is.\n\n        [1, \"auto\", 1]  → \"1fr auto 1fr\"\n        [2, 1]          → \"2fr 1fr\"\n        [\"200px\", 1, 1] → \"200px 1fr 1fr\"\n    \"\"\"\n    parts: list[str] = []\n    for v in columns:\n        if isinstance(v, int):\n            parts.append(f\"{v}fr\")\n        else:\n            parts.append(v)\n    return \" \".join(parts)\n\n\nclass Grid(ContainerComponent):\n    \"\"\"Responsive CSS grid container.\n\n    Args:\n        columns: Number of columns (1-12), a list of column widths, a\n            Responsive mapping, or a dict of breakpoint→column-count.\n            Defaults to 3 equal columns. Pass a list for custom widths::\n\n                Grid(columns=[1, \"auto\", 1])  # 1fr auto 1fr\n\n            In a list, integers become fractional units (``1`` → ``1fr``)\n            and strings pass through (``\"auto\"``, ``\"200px\"``).\n        min_column_width: Minimum column width for auto-fill responsive\n            grids (e.g. ``\"16rem\"``). Mutually exclusive with *columns*.\n        gap: Gap between children: int, (x, y) tuple, or Responsive.\n        css_class: Additional CSS classes to apply.\n\n    Example::\n\n        with Grid(columns=3):\n            Card(...)\n            Card(...)\n            Card(...)\n\n        # Custom widths: sidebar + content\n        with Grid(columns=[1, 3]):\n            Sidebar(...)\n            MainContent(...)\n\n        # Responsive: 1 col on mobile, 2 on md, 3 on lg\n        with Grid(columns={\"default\": 1, \"md\": 2, \"lg\": 3}):\n            Card(...)\n\n        # Auto-fill: as many columns as fit, each ≥ 16rem\n        with Grid(min_column_width=\"16rem\"):\n            Card(...)\n    \"\"\"\n\n    type: Literal[\"Grid\"] = \"Grid\"\n    columns: int | list[int | str] | dict[str, int] | Responsive | None = Field(\n        default=None,\n        exclude=True,\n    )\n    column_template: str | None = Field(\n        default=None,\n        alias=\"columnTemplate\",\n        description=\"CSS grid-template-columns value for custom column widths.\",\n    )\n    min_column_width: str | None = Field(default=None, alias=\"minColumnWidth\")\n    gap: Gap = Field(default=None, exclude=True)\n    align: Align = Field(default=None, exclude=True)\n    justify: Justify = Field(default=None, exclude=True)\n\n    @overload\n    def __init__(self, columns: int, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(\n        self,\n        *,\n        columns: int | list[int | str] | dict[str, int] | Responsive,\n        **kwargs: Any,\n    ) -> None: ...\n\n    @overload\n    def __init__(self, *, min_column_width: str, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, **kwargs: Any) -> None: ...\n\n    def __init__(\n        self,\n        columns: int | list[int | str] | dict[str, int] | Responsive | None = None,\n        **kwargs: Any,\n    ) -> None:\n        if columns is not None:\n            kwargs[\"columns\"] = columns\n        # Default to 3 columns when neither columns nor min_column_width given\n        if columns is None and \"min_column_width\" not in kwargs:\n            kwargs.setdefault(\"columns\", 3)\n        super().__init__(**kwargs)\n\n    def model_post_init(self, __context: Any) -> None:\n        # List columns → inline style via column_template (not a Tailwind class)\n        columns_for_layout: int | dict[str, int] | Responsive | None\n        if isinstance(self.columns, list):\n            self.column_template = _compile_column_template(self.columns)\n            columns_for_layout = None\n        else:\n            columns_for_layout = self.columns\n\n        layout = _compile_layout_classes(\n            gap=self.gap,\n            columns=columns_for_layout,\n            align=self.align,\n            justify=self.justify,\n        )\n        self.css_class = _merge_css_classes(layout, self.css_class)\n        super().model_post_init(__context)\n",
  "prefab_ui/components/heading.py": "\"\"\"Heading display component.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.typography import _text_init, _TextComponent\n\n\nclass Heading(_TextComponent):\n    \"\"\"Section heading (h1-h4).\n\n    Example::\n\n        Heading(\"{{ name }}\", level=2)\n    \"\"\"\n\n    type: Literal[\"Heading\"] = \"Heading\"\n    level: Literal[1, 2, 3, 4] = Field(\n        default=1, description=\"Heading level (1=h1, 4=h4)\"\n    )\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n",
  "prefab_ui/components/histogram.py": "\"\"\"Histogram component — auto-bins raw values and renders as a BarChart.\n\nBinning happens in Python at construction time. The renderer receives a\nstandard BarChart payload with pre-computed bin labels and counts, so no\nnew React component or Zod schema is needed.\n\nExample::\n\n    from prefab_ui.components import Histogram\n\n    Histogram(values=[1, 2, 2, 3, 3, 3, 4, 4, 5])\n\n    Histogram(\n        values=[10.5, 20.3, 15.7, 30.1, 25.0],\n        bins=5,\n        color=\"#4f46e5\",\n    )\n\n    Histogram(\n        values=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n        bin_edges=[0, 3, 7, 10],\n    )\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\nfrom prefab_ui.components.charts import ChartSeries\n\n\ndef _format_edge(value: float) -> str:\n    \"\"\"Format a bin edge as a human-readable string.\n\n    Integers render without decimals; floats keep up to 2 decimal places.\n    \"\"\"\n    if value == int(value) and math.isfinite(value):\n        return str(int(value))\n    return f\"{value:.2g}\"\n\n\ndef _compute_bins(\n    values: list[int | float],\n    bins: int,\n    bin_edges: list[float] | None,\n) -> list[dict[str, Any]]:\n    \"\"\"Compute histogram bin counts from raw values.\n\n    Returns a list of ``{\"bin\": \"lo-hi\", \"count\": n}`` dicts suitable for\n    BarChart data.\n    \"\"\"\n    if not values:\n        return []\n\n    if bin_edges is not None:\n        edges = sorted(bin_edges)\n    else:\n        lo = float(min(values))\n        hi = float(max(values))\n        if lo == hi:\n            edges = [lo, hi + 1]\n            bins = 1\n        else:\n            step = (hi - lo) / bins\n            edges = [lo + i * step for i in range(bins)] + [hi]\n\n    n_bins = len(edges) - 1\n    counts = [0] * n_bins\n\n    for v in values:\n        for i in range(n_bins):\n            lower = edges[i]\n            upper = edges[i + 1]\n            if i == n_bins - 1:\n                if lower <= v <= upper:\n                    counts[i] += 1\n                    break\n            else:\n                if lower <= v < upper:\n                    counts[i] += 1\n                    break\n\n    data: list[dict[str, Any]] = []\n    for i in range(n_bins):\n        label = f\"{_format_edge(edges[i])}\\u2013{_format_edge(edges[i + 1])}\"\n        data.append({\"bin\": label, \"count\": counts[i]})\n\n    return data\n\n\nclass Histogram(Component):\n    \"\"\"Histogram that auto-bins raw values and renders as a BarChart.\n\n    The ``values``, ``bins``, and ``bin_edges`` fields are consumed during\n    construction and excluded from the serialized output. The renderer\n    receives a standard BarChart payload.\n\n    Args:\n        values: Raw numeric values to bin.\n        bins: Number of equal-width bins (ignored when *bin_edges* is set).\n        bin_edges: Explicit bin boundaries. Overrides *bins* when provided.\n        height: Chart height in pixels.\n        show_tooltip: Show tooltip on hover.\n        show_legend: Show legend.\n        show_grid: Show cartesian grid.\n        color: Bar fill color (CSS color string).\n        bar_radius: Corner radius on bars.\n\n    Example::\n\n        Histogram(values=[1, 2, 2, 3, 3, 3, 4, 4, 5])\n    \"\"\"\n\n    type: Literal[\"BarChart\"] = \"BarChart\"\n\n    values: list[int | float] = Field(exclude=True)\n    bins: int = Field(default=10, exclude=True)\n    bin_edges: list[float] | None = Field(default=None, exclude=True)\n\n    data: list[dict[str, Any]] = Field(default_factory=list)\n    series: list[ChartSeries] = Field(default_factory=list)\n    x_axis: str | None = Field(default=None, alias=\"xAxis\")\n\n    height: int = Field(default=300, description=\"Chart height in pixels\")\n    show_tooltip: bool = Field(\n        default=True, alias=\"showTooltip\", description=\"Show tooltip on hover\"\n    )\n    show_legend: bool = Field(\n        default=False, alias=\"showLegend\", description=\"Show legend\"\n    )\n    show_grid: bool = Field(\n        default=True, alias=\"showGrid\", description=\"Show cartesian grid\"\n    )\n    color: str | None = Field(default=None, exclude=True)\n    bar_radius: int = Field(\n        default=4, alias=\"barRadius\", description=\"Corner radius on bars\"\n    )\n\n    def model_post_init(self, __context: Any) -> None:\n        self.data = _compute_bins(self.values, self.bins, self.bin_edges)\n        series_kwargs: dict[str, Any] = {\"data_key\": \"count\"}\n        if self.color is not None:\n            series_kwargs[\"color\"] = self.color\n        self.series = [ChartSeries(**series_kwargs)]\n        self.x_axis = \"bin\"\n        super().model_post_init(__context)\n",
  "prefab_ui/components/hover_card.py": "\"\"\"HoverCard — rich content panel that appears on hover.\n\nThe first child becomes the trigger; remaining children become the content.\n\nExample::\n\n    from prefab_ui.components import HoverCard, Badge, Column, Text, Progress\n\n    with HoverCard(open_delay=0):\n        Badge(\"In Orbit\")          # trigger\n        with Column(gap=2):        # content\n            Text(\"heart-of-gold\")\n            Progress(value=100, indicator_class=\"bg-green-500\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass HoverCard(ContainerComponent):\n    \"\"\"Hover card with rich content.\n\n    First child = trigger, remaining children = content.\n    Appears on hover and auto-dismisses on mouse leave.\n\n    Example::\n\n        with HoverCard(open_delay=0):\n            Badge(\"Healthy\")\n            with Column(gap=2):\n                Text(\"weather-api\")\n                Muted(\"Uptime: 99.97%\")\n    \"\"\"\n\n    type: Literal[\"HoverCard\"] = \"HoverCard\"\n    side: Literal[\"top\", \"right\", \"bottom\", \"left\"] | None = Field(\n        default=None, description=\"Which side to show the hover card\"\n    )\n    open_delay: int | None = Field(\n        default=None,\n        alias=\"openDelay\",\n        description=\"Delay in milliseconds before opening\",\n    )\n    close_delay: int | None = Field(\n        default=None,\n        alias=\"closeDelay\",\n        description=\"Delay in milliseconds before closing\",\n    )\n",
  "prefab_ui/components/icon.py": "\"\"\"Icon component for rendering lucide icons by name.\n\nUses the lucide-react icon library. Pass any icon name in kebab-case.\nBrowse available icons at https://lucide.dev/icons.\n\nExample::\n\n    from prefab_ui.components import Icon, Button\n\n    # Standalone icon\n    Icon(\"circle-alert\")\n\n    # Inside a button (renders inline)\n    with Button():\n        Icon(\"download\")\n        \"Download file\"\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\n\n\nclass Icon(Component):\n    \"\"\"Renders a lucide icon by name.\n\n    Args:\n        name: Lucide icon name in kebab-case (e.g., \"arrow-right\", \"circle-alert\")\n        size: Icon size — \"sm\" (16px), \"default\" (16px with standard spacing),\n            or \"lg\" (24px)\n\n    Example::\n\n        Icon(\"check\")\n        Icon(\"arrow-right\", size=\"lg\")\n    \"\"\"\n\n    type: Literal[\"Icon\"] = \"Icon\"\n    name: str = Field(description=\"Lucide icon name in kebab-case\")\n    size: Literal[\"sm\", \"default\", \"lg\"] = Field(\n        default=\"default\",\n        description=\"Icon size variant\",\n    )\n\n    @overload\n    def __init__(self, name: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, name: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, name: str | None = None, **kwargs: Any) -> None:\n        if name is not None and \"name\" not in kwargs:\n            kwargs[\"name\"] = name\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/image.py": "\"\"\"Image display component.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\n\n\nclass Image(Component):\n    \"\"\"Image element.\n\n    Example::\n\n        Image(src=\"{{ avatar_url }}\", alt=\"{{ name }}\")\n    \"\"\"\n\n    type: Literal[\"Image\"] = \"Image\"\n    src: str = Field(description=\"Image URL\")\n    alt: str = Field(default=\"\", description=\"Alt text\")\n    width: str | None = Field(default=None, description=\"CSS width\")\n    height: str | None = Field(default=None, description=\"CSS height\")\n",
  "prefab_ui/components/input.py": "\"\"\"Input component for text entry.\n\nText inputs with full form validation styling and dark mode support.\n\nExample::\n\n    from prefab_ui.components import Input, Label\n\n    Input(placeholder=\"Enter your name\")\n    Input(input_type=\"email\", placeholder=\"you@example.com\")\n    Input(input_type=\"password\", placeholder=\"••••••••\")\n\n    # Access reactive value\n    input_field = Input(placeholder=\"Type something...\")\n    Text(f\"Value: {input_field.rx}\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import ClassVar, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component, StatefulMixin\n\nInputType = Literal[\n    \"text\",\n    \"email\",\n    \"password\",\n    \"number\",\n    \"tel\",\n    \"url\",\n    \"search\",\n    \"date\",\n    \"time\",\n    \"datetime-local\",\n    \"file\",\n]\n\n\nclass Input(StatefulMixin, Component):\n    \"\"\"Text input field component.\n\n    Args:\n        input_type: Input type (text, email, password, etc.)\n        placeholder: Placeholder text\n        value: Initial value\n        name: Form field name\n        disabled: Whether input is disabled\n        required: Whether input is required\n        css_class: Additional CSS classes\n\n    Example::\n\n        Input(placeholder=\"Search...\")\n        Input(input_type=\"email\", placeholder=\"Email\", required=True)\n        Input(input_type=\"password\", value=\"{{ user_password }}\")\n    \"\"\"\n\n    _auto_name: ClassVar[str] = \"input\"\n    type: Literal[\"Input\"] = \"Input\"\n    input_type: InputType = Field(\n        default=\"text\",\n        alias=\"inputType\",\n        description=\"Input type (text, email, password, etc.)\",\n    )\n    placeholder: str | None = Field(\n        default=None,\n        description=\"Placeholder text\",\n    )\n    value: str | None = Field(default=None, description=\"Input value\")\n    name: str | None = Field(\n        default=None,\n        description=\"State key for reactive binding. Auto-generated if omitted.\",\n    )\n    disabled: bool = Field(default=False, description=\"Whether input is disabled\")\n    required: bool = Field(default=False, description=\"Whether input is required\")\n    min_length: int | None = Field(\n        default=None,\n        alias=\"minLength\",\n        description=\"Minimum character length\",\n    )\n    max_length: int | None = Field(\n        default=None,\n        alias=\"maxLength\",\n        description=\"Maximum character length\",\n    )\n    min: float | None = Field(\n        default=None, description=\"Minimum value (for number inputs)\"\n    )\n    max: float | None = Field(\n        default=None, description=\"Maximum value (for number inputs)\"\n    )\n    step: float | None = Field(\n        default=None, description=\"Step increment (for number inputs)\"\n    )\n    pattern: str | None = Field(\n        default=None, description=\"Regex pattern for validation\"\n    )\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) to execute when value changes\",\n    )\n",
  "prefab_ui/components/label.py": "\"\"\"Label component for form fields.\n\nLabels identify form inputs and provide accessible descriptions.\n\nExample::\n\n    from prefab_ui.components import Label, Input\n\n    with Label(\"Email address\"):\n        Input(placeholder=\"you@example.com\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Label(ContainerComponent):\n    \"\"\"Label element for form fields.\n\n    Args:\n        text: Label text (optional if using children)\n        for_id: ID of the associated input element\n        css_class: Additional CSS classes\n\n    Example::\n\n        Label(\"Username\")\n        Label(\"Email\", for_id=\"email-input\")\n\n        # With children\n        with Label():\n            Text(\"Password\")\n            Input(input_type=\"password\")\n    \"\"\"\n\n    type: Literal[\"Label\"] = \"Label\"\n    text: str | None = Field(default=None, description=\"Label text\")\n    for_id: str | None = Field(\n        default=None,\n        alias=\"forId\",\n        description=\"ID of the associated form field\",\n    )\n\n    @overload\n    def __init__(self, text: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, text: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, text: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept text as positional or keyword argument.\"\"\"\n        if text is not None:\n            kwargs[\"text\"] = text\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/loader.py": "\"\"\"Loader activity indicator.\n\nLoaders communicate that something is happening — a request in flight,\ncontent loading, or a background process running.\n\nExample::\n\n    from prefab_ui.components import Loader\n\n    Loader()\n    Loader(variant=\"dots\")\n    Loader(variant=\"pulse\")\n    Loader(size=\"lg\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\n\n\nclass Loader(Component):\n    \"\"\"Animated activity indicator.\n\n    Three visual variants convey \"something is happening\":\n\n    - ``\"spin\"`` — a rotating arc (default, classic loading spinner)\n    - ``\"dots\"`` — three dots bouncing in sequence (typing / processing)\n    - ``\"pulse\"`` — a pulsing dot (background activity / heartbeat)\n    - ``\"bars\"`` — three vertical bars oscillating (equalizer / processing)\n    - ``\"ios\"`` — segmented circle with chasing opacity (iOS-style)\n\n    Args:\n        variant: Animation style — \"spin\", \"dots\", \"pulse\", \"bars\", or \"ios\"\n        size: Indicator size — \"sm\", \"default\", or \"lg\"\n\n    Example::\n\n        Loader()\n        Loader(variant=\"dots\")\n        Loader(variant=\"pulse\", size=\"lg\")\n        Loader(variant=\"bars\")\n        Loader(variant=\"ios\")\n    \"\"\"\n\n    type: Literal[\"Loader\"] = \"Loader\"\n    variant: Literal[\"spin\", \"dots\", \"pulse\", \"bars\", \"ios\"] = Field(\n        default=\"spin\",\n        description=\"Animation style: spin (rotating arc), dots (bouncing dots), pulse (pulsing dot), bars (oscillating bars), or ios (segmented circle)\",\n    )\n    size: Literal[\"sm\", \"default\", \"lg\"] = Field(\n        default=\"default\",\n        description=\"Indicator size variant\",\n    )\n",
  "prefab_ui/components/markdown.py": "\"\"\"Markdown display component.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\n\n\nclass Markdown(Component):\n    \"\"\"Rendered markdown component.\n\n    Example::\n\n        Markdown(\"**Name:** {{ name }}\\\\n\\\\n{{ bio }}\")\n    \"\"\"\n\n    type: Literal[\"Markdown\"] = \"Markdown\"\n    content: str = Field(description=\"Markdown content\")\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        if content is not None:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/metric.py": "\"\"\"Metric/KPI card component for displaying headline numbers with optional deltas.\n\nExample::\n\n    from prefab_ui.components import Metric\n\n    Metric(label=\"Revenue\", value=\"$42M\")\n    Metric(label=\"Active Users\", value=1842, delta=\"+23.4%\", trend=\"up\")\n    Metric(label=\"Costs\", value=\"$1.2M\", delta=\"-15%\", trend=\"down\", trend_sentiment=\"positive\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\n\nTrendDirection = Literal[\"up\", \"down\", \"neutral\"]\nTrendSentiment = Literal[\"positive\", \"negative\", \"neutral\"]\n\n\nclass Metric(Component):\n    \"\"\"A metric/KPI display showing a headline number with optional change indicator.\n\n    Args:\n        label: The metric name (e.g. \"Revenue\", \"Active Users\").\n        value: The headline number (e.g. \"$42M\", 1842, \"99.9%\").\n        description: Optional description text shown below the value.\n        delta: Optional change indicator (e.g. \"+23.4%\", -15, \"+$2.3M\").\n        trend: Arrow direction — \"up\", \"down\", or \"neutral\". If None,\n            inferred from delta (positive=up, negative=down, zero=neutral).\n        trend_sentiment: Color control — \"positive\" (green), \"negative\" (red),\n            or \"neutral\" (muted). If None, inferred: up=positive, down=negative.\n\n    Example::\n\n        Metric(label=\"Revenue\", value=\"$42M\", delta=\"+12%\")\n        Metric(label=\"Costs\", value=\"$1.2M\", delta=\"-15%\", trend=\"down\", trend_sentiment=\"positive\")\n    \"\"\"\n\n    type: Literal[\"Metric\"] = \"Metric\"\n    label: str = Field(description=\"The metric name\")\n    value: str | int | float = Field(description=\"The headline number\")\n    description: str | None = Field(\n        default=None,\n        description=\"Optional description text\",\n    )\n    delta: str | int | float | None = Field(\n        default=None,\n        description=\"Change indicator (e.g. '+23.4%', -15)\",\n    )\n    trend: TrendDirection | None = Field(\n        default=None,\n        description=\"Arrow direction: 'up', 'down', or 'neutral'. Inferred from delta if None.\",\n    )\n    trend_sentiment: TrendSentiment | None = Field(\n        default=None,\n        alias=\"trendSentiment\",\n        description=\"Color: 'positive' (green), 'negative' (red), 'neutral' (muted). Inferred from trend if None.\",\n    )\n",
  "prefab_ui/components/pages.py": "\"\"\"Pages component — multi-page layout driven by state.\n\nOnly the active page renders. Navigate by setting state.\n\nExample::\n\n    from prefab_ui.components import Pages, Page, Text, Button\n    from prefab_ui.actions import SetState\n\n    with Pages(name=\"page\", default_value=\"home\"):\n        with Page(\"Home\"):\n            Text(\"Welcome!\")\n            Button(\"Go to Settings\", on_click=SetState(\"page\", \"settings\"))\n        with Page(\"Settings\"):\n            Text(\"Settings go here.\")\n            Button(\"Back\", on_click=SetState(\"page\", \"home\"))\n\n    # Access reactive value\n    pages = Pages()\n    Text(f\"Current page: {pages.rx}\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, ClassVar, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent, StatefulMixin\n\n\nclass Page(ContainerComponent):\n    \"\"\"A single page within a Pages container.\n\n    Example::\n\n        with Page(\"Settings\"):\n            Text(\"Settings content.\")\n    \"\"\"\n\n    type: Literal[\"Page\"] = \"Page\"\n    title: str = Field(description=\"Page identifier / label\")\n    value: str | None = Field(\n        default=None,\n        description=\"Unique value for this page (defaults to title)\",\n    )\n\n    @overload\n    def __init__(self, title: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, title: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, title: str | None = None, **kwargs: Any) -> None:\n        if title is not None and \"title\" not in kwargs:\n            kwargs[\"title\"] = title\n        super().__init__(**kwargs)\n\n\nclass Pages(StatefulMixin, ContainerComponent):\n    \"\"\"Multi-page layout — only the active Page renders.\n\n    Control which page shows via the state key matching ``name``.\n\n    Example::\n\n        with Pages(name=\"currentPage\", default_value=\"home\"):\n            with Page(\"Home\"):\n                Text(\"Home content\")\n            with Page(\"Settings\"):\n                Text(\"Settings content\")\n    \"\"\"\n\n    _auto_name: ClassVar[str] = \"pages\"\n    type: Literal[\"Pages\"] = \"Pages\"\n    default_value: str | None = Field(\n        default=None,\n        alias=\"defaultValue\",\n        description=\"Initially active page value\",\n    )\n    name: str | None = Field(\n        default=None,\n        description=\"State key for reactive binding. Auto-generated if omitted.\",\n    )\n",
  "prefab_ui/components/popover.py": "\"\"\"Popover — floating content panel triggered by a child element.\n\nThe first child becomes the trigger; remaining children become the content.\n\nExample::\n\n    from prefab_ui.components import Popover, Button, Column, Label, Slider\n\n    with Popover(title=\"Settings\"):\n        Button(\"Open\")          # trigger\n        with Column(gap=3):     # content\n            Label(\"Volume\")\n            Slider(name=\"volume\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Popover(ContainerComponent):\n    \"\"\"Popover floating panel.\n\n    First child = trigger, remaining children = content.\n\n    Example::\n\n        with Popover(title=\"Options\"):\n            Button(\"Configure\")\n            with Column(gap=2):\n                Label(\"Setting\")\n                Input(name=\"value\")\n    \"\"\"\n\n    type: Literal[\"Popover\"] = \"Popover\"\n    title: str | None = Field(default=None, description=\"Optional popover header title\")\n    description: str | None = Field(\n        default=None, description=\"Optional popover description\"\n    )\n    side: Literal[\"top\", \"right\", \"bottom\", \"left\"] | None = Field(\n        default=None, description=\"Which side to show the popover\"\n    )\n",
  "prefab_ui/components/progress.py": "\"\"\"Progress bar component.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component\n\nProgressVariant = Literal[\n    \"default\", \"success\", \"warning\", \"destructive\", \"info\", \"muted\"\n]\n\n\nclass Progress(Component):\n    \"\"\"A progress bar showing completion status.\n\n    Example::\n\n        Progress(value=75)\n        Progress(value=3, max=10)\n        Progress(value=80, variant=\"success\")\n        Progress(value=80, indicator_class=\"bg-green-500\")\n    \"\"\"\n\n    type: Literal[\"Progress\"] = \"Progress\"\n    value: float | str = Field(\n        default=0,\n        description=\"Current progress value\",\n    )\n    min: float = Field(default=0, description=\"Minimum value\")\n    max: float = Field(default=100, description=\"Maximum value (progress is value/max)\")\n    variant: ProgressVariant = Field(\n        default=\"default\",\n        description=\"Visual variant: default, success, warning, destructive, info, muted\",\n    )\n    indicator_class: str | None = Field(\n        default=None,\n        alias=\"indicatorClass\",\n        description=\"Tailwind classes for the indicator bar (e.g. 'bg-green-500')\",\n    )\n",
  "prefab_ui/components/radio.py": "\"\"\"Radio button components for mutually exclusive choices.\n\nRadio buttons let users select exactly one option from a set.\n\nExample::\n\n    from prefab_ui.components import RadioGroup, Radio\n\n    with RadioGroup(name=\"size\"):\n        Radio(value=\"sm\", label=\"Small\")\n        Radio(value=\"md\", label=\"Medium\", checked=True)\n        Radio(value=\"lg\", label=\"Large\")\n\n    # Access reactive value\n    group = RadioGroup()\n    Text(f\"Selected: {group.rx}\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import ClassVar, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component, ContainerComponent, StatefulMixin\n\n\nclass RadioGroup(StatefulMixin, ContainerComponent):\n    \"\"\"Container for radio button options.\n\n    Args:\n        name: Form field name (shared by all radios in group)\n        css_class: Additional CSS classes\n\n    Example::\n\n        with RadioGroup(name=\"theme\"):\n            Radio(value=\"light\", label=\"Light\")\n            Radio(value=\"dark\", label=\"Dark\")\n    \"\"\"\n\n    _auto_name: ClassVar[str] = \"radiogroup\"\n    type: Literal[\"RadioGroup\"] = \"RadioGroup\"\n    name: str | None = Field(\n        default=None,\n        description=\"State key for reactive binding. Auto-generated if omitted.\",\n    )\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) to execute when selection changes\",\n    )\n\n\nclass Radio(StatefulMixin, Component):\n    \"\"\"Radio button input component.\n\n    Args:\n        value: Form value for this option\n        label: Label text to display\n        checked: Whether radio is initially selected\n        name: Form field name (usually set by RadioGroup)\n        disabled: Whether radio is disabled\n        required: Whether radio is required\n        css_class: Additional CSS classes\n\n    Example::\n\n        Radio(value=\"yes\", label=\"Yes\")\n        Radio(value=\"no\", label=\"No\", checked=True)\n    \"\"\"\n\n    _auto_name: ClassVar[str] = \"radio\"\n    type: Literal[\"Radio\"] = \"Radio\"\n    value: str = Field(description=\"Form value\")\n    label: str | None = Field(default=None, description=\"Label text\")\n    checked: bool = Field(default=False, description=\"Whether radio is selected\")\n    name: str | None = Field(\n        default=None,\n        description=\"State key for reactive binding. Auto-generated if omitted.\",\n    )\n    disabled: bool = Field(default=False, description=\"Whether radio is disabled\")\n    required: bool = Field(default=False, description=\"Whether radio is required\")\n",
  "prefab_ui/components/ring.py": "\"\"\"Circular progress ring component.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\nRingVariant = Literal[\"default\", \"success\", \"warning\", \"destructive\", \"info\", \"muted\"]\nRingSize = Literal[\"sm\", \"default\", \"lg\"]\n\n\nclass Ring(ContainerComponent):\n    \"\"\"A circular progress indicator with an optional centered label.\n\n    Renders an SVG ring that fills clockwise from 12 o'clock based on the\n    current value within the min/max range. Accepts children for custom\n    center content; when no children are present, ``label`` is shown.\n\n    Example::\n\n        Ring(value=75, label=\"75%\", variant=\"success\")\n        Ring(value=3, max=5, label=\"3/5\", variant=\"info\", size=\"lg\")\n\n        with Ring(value=75, variant=\"success\", size=\"lg\"):\n            H1(\"75%\")\n    \"\"\"\n\n    type: Literal[\"Ring\"] = \"Ring\"\n    value: float | str = Field(\n        default=0,\n        description=\"Current value (number or template expression)\",\n    )\n    min: float = Field(default=0, description=\"Minimum value\")\n    max: float = Field(default=100, description=\"Maximum value\")\n    label: str | None = Field(\n        default=None,\n        description=\"Text displayed in the center of the ring\",\n    )\n    variant: RingVariant = Field(\n        default=\"default\",\n        description=\"Visual variant: default, success, warning, destructive, info, muted\",\n    )\n    size: RingSize = Field(\n        default=\"default\",\n        description=\"Ring size: sm (64px), default (96px), lg (128px)\",\n    )\n    thickness: float = Field(\n        default=6,\n        description=\"Stroke width of the ring in pixels\",\n    )\n",
  "prefab_ui/components/row.py": "\"\"\"Row layout container.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import (\n    Align,\n    ContainerComponent,\n    Gap,\n    Justify,\n    _compile_layout_classes,\n    _merge_css_classes,\n)\n\n\nclass Row(ContainerComponent):\n    \"\"\"Horizontal flex container.\n\n    Example::\n\n        with Row():\n            Text(\"Left\")\n            Text(\"Right\")\n\n        with Row(gap=4, align=\"center\"):\n            Icon(\"check\")\n            Text(\"Confirmed\")\n    \"\"\"\n\n    type: Literal[\"Row\"] = \"Row\"\n    gap: Gap = Field(default=None, exclude=True)\n    align: Align = Field(default=None, exclude=True)\n    justify: Justify = Field(default=None, exclude=True)\n\n    def model_post_init(self, __context: Any) -> None:\n        layout = _compile_layout_classes(\n            gap=self.gap, align=self.align, justify=self.justify\n        )\n        self.css_class = _merge_css_classes(layout, self.css_class)\n        super().model_post_init(__context)\n",
  "prefab_ui/components/select.py": "\"\"\"Select component for dropdown choices.\n\nSelect dropdowns let users pick from a list of options.\n\nExample::\n\n    from prefab_ui.components import Select, SelectOption\n\n    with Select(placeholder=\"Choose size...\"):\n        SelectOption(value=\"sm\", label=\"Small\")\n        SelectOption(value=\"md\", label=\"Medium\")\n        SelectOption(value=\"lg\", label=\"Large\")\n\n    # Access reactive value\n    size_select = Select(placeholder=\"Pick size...\")\n    Text(f\"Selected: {size_select.rx}\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, ClassVar, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component, ContainerComponent, StatefulMixin\n\nSelectSize = Literal[\"sm\", \"default\"]\n\n\nclass Select(StatefulMixin, ContainerComponent):\n    \"\"\"Select dropdown container.\n\n    Args:\n        placeholder: Placeholder text when no option selected\n        name: Form field name\n        size: Select size (\"sm\" or \"default\")\n        disabled: Whether select is disabled\n        required: Whether select is required\n        css_class: Additional CSS classes\n\n    Example::\n\n        with Select(placeholder=\"Pick one...\", name=\"choice\"):\n            SelectOption(value=\"a\", label=\"Option A\")\n            SelectOption(value=\"b\", label=\"Option B\")\n    \"\"\"\n\n    _auto_name: ClassVar[str] = \"select\"\n    type: Literal[\"Select\"] = \"Select\"\n    placeholder: str | None = Field(\n        default=None,\n        description=\"Placeholder text\",\n    )\n    name: str | None = Field(\n        default=None,\n        description=\"State key for reactive binding. Auto-generated if omitted.\",\n    )\n    size: SelectSize = Field(default=\"default\", description=\"Select size (sm, default)\")\n    disabled: bool = Field(default=False, description=\"Whether select is disabled\")\n    required: bool = Field(default=False, description=\"Whether select is required\")\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) to execute when selection changes\",\n    )\n\n\nclass SelectOption(Component):\n    \"\"\"Select dropdown option.\n\n    Args:\n        value: Option value\n        label: Display text\n        selected: Whether option is initially selected\n        disabled: Whether option is disabled\n        css_class: Additional CSS classes\n\n    Example::\n\n        SelectOption(value=\"yes\", label=\"Yes\")\n        SelectOption(value=\"no\", label=\"No\", selected=True)\n    \"\"\"\n\n    type: Literal[\"SelectOption\"] = \"SelectOption\"\n    value: str = Field(description=\"Option value\")\n    label: str = Field(description=\"Display text\")\n    selected: bool = Field(default=False, description=\"Whether option is selected\")\n    disabled: bool = Field(default=False, description=\"Whether option is disabled\")\n\n    @overload\n    def __init__(self, label: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, label: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, label: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept label as positional or keyword argument.\"\"\"\n        if label is not None:\n            kwargs[\"label\"] = label\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/separator.py": "\"\"\"Separator component for visual dividers.\n\nSeparators create visual divisions between content sections.\n\nExample::\n\n    from prefab_ui.components import Separator\n\n    Separator()\n    Separator(orientation=\"vertical\")\n    Separator(spacing=4)\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component, _merge_css_classes\n\nSeparatorOrientation = Literal[\"horizontal\", \"vertical\"]\n\n\nclass Separator(Component):\n    \"\"\"Visual divider component.\n\n    Args:\n        orientation: Separator direction (horizontal or vertical)\n        spacing: Space around the separator (Tailwind spacing scale).\n            Adds vertical margin for horizontal separators and horizontal\n            margin for vertical separators.\n        css_class: Additional CSS classes\n\n    Example::\n\n        Separator()  # Horizontal by default\n        Separator(orientation=\"vertical\")\n        Separator(spacing=4)  # Extra breathing room\n    \"\"\"\n\n    type: Literal[\"Separator\"] = \"Separator\"\n    orientation: SeparatorOrientation = Field(\n        default=\"horizontal\", description=\"Separator orientation\"\n    )\n    spacing: int | None = Field(\n        default=None,\n        exclude=True,\n        description=\"Space around the separator (Tailwind spacing scale)\",\n    )\n\n    def model_post_init(self, __context: Any) -> None:\n        if self.spacing is not None:\n            direction = \"mx\" if self.orientation == \"vertical\" else \"my\"\n            self.css_class = _merge_css_classes(\n                f\"{direction}-{self.spacing}\", self.css_class\n            )\n        super().model_post_init(__context)\n",
  "prefab_ui/components/slider.py": "\"\"\"Slider component for range input.\n\nSliders let users select a numeric value from a range. Set ``range=True``\nfor a two-thumb range slider that emits ``[min, max]`` values.\n\nExample::\n\n    from prefab_ui.components import Slider\n\n    Slider(min=0, max=100, value=50)\n    Slider(min=0, max=10, step=0.5, value=5)\n    Slider(min=0, max=100, value=[20, 80], range=True)\n\n    # Access reactive value\n    slider = Slider(min=0, max=100, value=50)\n    Text(f\"Value: {slider.rx}\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, ClassVar, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component, StatefulMixin\n\n\nclass Slider(StatefulMixin, Component):\n    \"\"\"Range slider input component.\n\n    When ``range=True``, renders two thumbs for selecting a range. The\n    ``value`` field accepts a ``[low, high]`` list and ``on_change``\n    emits the pair as ``[low, high]``.\n\n    Args:\n        min: Minimum value\n        max: Maximum value\n        value: Initial value (number, or [low, high] list when range=True)\n        step: Step increment\n        range: Enable two-thumb range selection\n        name: Form field name\n        disabled: Whether slider is disabled\n        css_class: Additional CSS classes\n\n    Example::\n\n        Slider(min=0, max=100, value=50)\n        Slider(min=0, max=1, step=0.1, value=0.5)\n        Slider(min=0, max=100, value=[20, 80], range=True)\n    \"\"\"\n\n    _auto_name: ClassVar[str] = \"slider\"\n    type: Literal[\"Slider\"] = \"Slider\"\n    min: float = Field(default=0, description=\"Minimum value\")\n    max: float = Field(default=100, description=\"Maximum value\")\n    value: float | list[float] | None = Field(\n        default=None,\n        description=\"Initial value (number, or [low, high] list when range=True)\",\n    )\n    step: float | None = Field(default=None, description=\"Step increment\")\n    range: bool = Field(default=False, description=\"Enable two-thumb range selection\")\n    name: str | None = Field(\n        default=None,\n        description=\"State key for reactive binding. Auto-generated if omitted.\",\n    )\n    disabled: bool = Field(default=False, description=\"Whether slider is disabled\")\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) to execute when value changes\",\n    )\n\n    def to_json(self) -> dict[str, Any]:\n        d = super().to_json()\n        if not self.range:\n            d.pop(\"range\", None)\n        return d\n",
  "prefab_ui/components/slot.py": "\"\"\"Dynamic view slot — renders a component tree from state.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Slot(ContainerComponent):\n    \"\"\"Render a component tree stored in state.\n\n    ``Slot`` is a named placeholder in your layout. When the state key\n    contains a component tree, Slot renders it. When the state key is\n    empty, Slot renders its children as fallback content::\n\n        with Slot(\"detail_view\"):\n            Text(\"Select an item to see details\")\n\n    The slot content is typically populated by an action with\n    ``result_key``::\n\n        Button(\n            \"Load Details\",\n            on_click=CallTool(\"get_detail\", result_key=\"detail_view\"),\n        )\n    \"\"\"\n\n    type: Literal[\"Slot\"] = \"Slot\"\n    name: str = Field(description=\"State key containing the component tree to render.\")\n\n    def __init__(self, name: str, **kwargs: Any) -> None:\n        kwargs[\"name\"] = name\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/switch.py": "\"\"\"Switch component for toggle controls.\n\nSwitches provide an alternative to checkboxes for on/off states.\n\nExample::\n\n    from prefab_ui.components import Switch\n\n    Switch(label=\"Enable notifications\", checked=True)\n    Switch(label=\"Dark mode\", size=\"sm\")\n\n    # Access reactive value\n    toggle = Switch(label=\"Enable feature\")\n    Text(f\"Enabled: {toggle.rx}\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import ClassVar, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component, StatefulMixin\n\nSwitchSize = Literal[\"sm\", \"default\"]\n\n\nclass Switch(StatefulMixin, Component):\n    \"\"\"Toggle switch component.\n\n    Args:\n        label: Label text to display next to switch\n        checked: Whether switch is on\n        size: Switch size (\"sm\" or \"default\")\n        name: Form field name\n        disabled: Whether switch is disabled\n        required: Whether switch is required\n        css_class: Additional CSS classes\n\n    Example::\n\n        Switch(label=\"Enabled\")\n        Switch(checked=True, label=\"Active\", size=\"sm\")\n    \"\"\"\n\n    _auto_name: ClassVar[str] = \"switch\"\n    type: Literal[\"Switch\"] = \"Switch\"\n    label: str | None = Field(default=None, description=\"Label text\")\n    checked: bool = Field(default=False, description=\"Whether switch is on\")\n    size: SwitchSize = Field(default=\"default\", description=\"Switch size (sm, default)\")\n    name: str | None = Field(\n        default=None,\n        description=\"State key for reactive binding. Auto-generated if omitted.\",\n    )\n    disabled: bool = Field(default=False, description=\"Whether switch is disabled\")\n    required: bool = Field(default=False, description=\"Whether switch is required\")\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) to execute when toggled\",\n    )\n",
  "prefab_ui/components/table.py": "\"\"\"Table components following shadcn/ui conventions.\n\nTables display structured data in rows and columns.\n\nExample::\n\n    from prefab_ui.components import (\n        Table, TableHeader, TableBody, TableRow, TableHead, TableCell, TableCaption\n    )\n\n    with Table():\n        TableCaption(\"Recent orders\")\n        with TableHeader():\n            with TableRow():\n                TableHead(\"Order\")\n                TableHead(\"Status\")\n                TableHead(\"Amount\")\n        with TableBody():\n            with TableRow():\n                TableCell(\"ORD-001\")\n                TableCell(\"Shipped\")\n                TableCell(\"$250.00\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component, ContainerComponent\n\n\nclass Table(ContainerComponent):\n    \"\"\"Table container.\n\n    Use TableHeader, TableBody, TableRow, TableHead, and TableCell to build\n    structured table layouts.\n    \"\"\"\n\n    type: Literal[\"Table\"] = \"Table\"\n\n\nclass TableHeader(ContainerComponent):\n    \"\"\"Table header section containing header rows.\"\"\"\n\n    type: Literal[\"TableHeader\"] = \"TableHeader\"\n\n\nclass TableBody(ContainerComponent):\n    \"\"\"Table body section containing data rows.\"\"\"\n\n    type: Literal[\"TableBody\"] = \"TableBody\"\n\n\nclass TableFooter(ContainerComponent):\n    \"\"\"Table footer section.\"\"\"\n\n    type: Literal[\"TableFooter\"] = \"TableFooter\"\n\n\nclass TableRow(ContainerComponent):\n    \"\"\"A single table row containing cells.\"\"\"\n\n    type: Literal[\"TableRow\"] = \"TableRow\"\n\n\nclass TableHead(ContainerComponent):\n    \"\"\"A header cell within a TableRow.\n\n    Example::\n\n        TableHead(\"Name\")\n    \"\"\"\n\n    type: Literal[\"TableHead\"] = \"TableHead\"\n    content: str | None = Field(\n        default=None,\n        description=\"Header text (alternative to children)\",\n    )\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str | None = None, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        if content is not None and \"content\" not in kwargs:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n\n\nclass TableCell(ContainerComponent):\n    \"\"\"A data cell within a TableRow.\n\n    Can contain text or arbitrary child components.\n\n    Example::\n\n        TableCell(\"$250.00\")\n        # or with children:\n        with TableCell():\n            Badge(\"Active\", variant=\"success\")\n    \"\"\"\n\n    type: Literal[\"TableCell\"] = \"TableCell\"\n    content: str | None = Field(\n        default=None,\n        description=\"Cell text (alternative to children)\",\n    )\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str | None = None, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        if content is not None and \"content\" not in kwargs:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n\n\nclass TableCaption(Component):\n    \"\"\"Table caption text.\n\n    Example::\n\n        TableCaption(\"A list of recent invoices\")\n    \"\"\"\n\n    type: Literal[\"TableCaption\"] = \"TableCaption\"\n    content: str = Field(description=\"Caption text\")\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        if content is not None and \"content\" not in kwargs:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/tabs.py": "\"\"\"Tabs component for switching between panels of content.\n\nExample::\n\n    from prefab_ui.components import Tabs, Tab, Text\n\n    with Tabs(default_value=\"general\"):\n        with Tab(\"General\"):\n            Text(\"General settings here.\")\n        with Tab(\"Advanced\"):\n            Text(\"Advanced settings here.\")\n\n    # Access reactive value\n    tabs = Tabs()\n    Text(f\"Active tab: {tabs.rx}\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, ClassVar, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import ContainerComponent, StatefulMixin\n\nTabsVariant = Literal[\"default\", \"line\"]\n\n\nclass Tab(ContainerComponent):\n    \"\"\"A single tab panel within a Tabs container.\n\n    The ``title`` appears in the tab trigger; children are the panel content.\n\n    Example::\n\n        with Tab(\"Settings\"):\n            Text(\"Content shown when this tab is active.\")\n    \"\"\"\n\n    type: Literal[\"Tab\"] = \"Tab\"\n    title: str = Field(description=\"Tab trigger label\")\n    value: str | None = Field(\n        default=None,\n        description=\"Unique value for this tab (defaults to title)\",\n    )\n    disabled: bool = Field(default=False, description=\"Disable this tab\")\n\n    @overload\n    def __init__(self, title: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, title: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, title: str | None = None, **kwargs: Any) -> None:\n        if title is not None and \"title\" not in kwargs:\n            kwargs[\"title\"] = title\n        super().__init__(**kwargs)\n\n\nclass Tabs(StatefulMixin, ContainerComponent):\n    \"\"\"Tab container — children must be ``Tab`` components.\n\n    Example::\n\n        with Tabs(default_value=\"general\"):\n            with Tab(\"General\"):\n                Text(\"General settings\")\n            with Tab(\"Advanced\"):\n                Text(\"Advanced settings\")\n    \"\"\"\n\n    _auto_name: ClassVar[str] = \"tabs\"\n    type: Literal[\"Tabs\"] = \"Tabs\"\n    variant: TabsVariant = Field(\n        default=\"default\",\n        description=\"Visual style — 'default' (pill) or 'line' (underline)\",\n    )\n    default_value: str | None = Field(\n        default=None,\n        alias=\"defaultValue\",\n        description=\"Value of the initially active tab\",\n    )\n    name: str | None = Field(\n        default=None,\n        description=\"State key for reactive binding. Auto-generated if omitted.\",\n    )\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) when the active tab changes\",\n    )\n",
  "prefab_ui/components/text.py": "\"\"\"Text display component.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom prefab_ui.components.typography import _text_init, _TextComponent\n\n\nclass Text(_TextComponent):\n    \"\"\"Body text component.\n\n    Example::\n\n        Text(\"Hello, {{ name }}!\")\n    \"\"\"\n\n    type: Literal[\"Text\"] = \"Text\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n",
  "prefab_ui/components/textarea.py": "\"\"\"Textarea component for multi-line text entry.\n\nMulti-line text inputs with auto-sizing and form validation styling.\n\nExample::\n\n    from prefab_ui.components import Textarea, Label\n\n    Textarea(placeholder=\"Enter your message...\")\n    Textarea(rows=5, placeholder=\"Feedback\")\n\n    # Access reactive value\n    textarea = Textarea(placeholder=\"Your feedback...\")\n    Text(f\"Comment: {textarea.rx}\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import ClassVar, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions import Action\nfrom prefab_ui.components.base import Component, StatefulMixin\n\n\nclass Textarea(StatefulMixin, Component):\n    \"\"\"Multi-line text input component.\n\n    Args:\n        placeholder: Placeholder text\n        value: Initial value\n        name: Form field name\n        rows: Number of visible text rows\n        disabled: Whether textarea is disabled\n        required: Whether textarea is required\n        css_class: Additional CSS classes\n\n    Example::\n\n        Textarea(placeholder=\"Write something...\")\n        Textarea(rows=10, value=\"{{ comment_text }}\")\n    \"\"\"\n\n    _auto_name: ClassVar[str] = \"textarea\"\n    type: Literal[\"Textarea\"] = \"Textarea\"\n    placeholder: str | None = Field(\n        default=None,\n        description=\"Placeholder text\",\n    )\n    value: str | None = Field(default=None, description=\"Textarea value\")\n    name: str | None = Field(\n        default=None,\n        description=\"State key for reactive binding. Auto-generated if omitted.\",\n    )\n    rows: int | None = Field(default=None, description=\"Number of visible text rows\")\n    disabled: bool = Field(default=False, description=\"Whether textarea is disabled\")\n    required: bool = Field(default=False, description=\"Whether textarea is required\")\n    min_length: int | None = Field(\n        default=None,\n        alias=\"minLength\",\n        description=\"Minimum character length\",\n    )\n    max_length: int | None = Field(\n        default=None,\n        alias=\"maxLength\",\n        description=\"Maximum character length\",\n    )\n    on_change: Action | list[Action] | None = Field(\n        default=None,\n        alias=\"onChange\",\n        description=\"Action(s) to execute when value changes\",\n    )\n",
  "prefab_ui/components/tooltip.py": "\"\"\"Tooltip — hover text on any component.\n\nExample::\n\n    from prefab_ui.components import Tooltip, Button\n\n    with Tooltip(\"Click to save your changes\"):\n        Button(\"Save\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import ContainerComponent\n\n\nclass Tooltip(ContainerComponent):\n    \"\"\"Tooltip that appears on hover over its child.\n\n    Wrap any single component to show tooltip text on hover.\n\n    Example::\n\n        with Tooltip(\"Saves the current document\"):\n            Button(\"Save\")\n    \"\"\"\n\n    type: Literal[\"Tooltip\"] = \"Tooltip\"\n    content: str = Field(description=\"Tooltip text\")\n    side: Literal[\"top\", \"right\", \"bottom\", \"left\"] | None = Field(\n        default=None, description=\"Which side to show the tooltip\"\n    )\n    delay: int | None = Field(\n        default=None, description=\"Delay in milliseconds before showing the tooltip\"\n    )\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        if content is not None and \"content\" not in kwargs:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n",
  "prefab_ui/components/typography.py": "\"\"\"Typography components following shadcn/ui conventions.\n\nThese components provide semantic text styling with automatic dark mode support.\nExample::\n\n    from prefab_ui.components import H1, H2, P, Muted, Lead\n\n    H1(\"Dashboard\")\n    H2(\"User Profile\")\n    P(\"Welcome to the application.\")\n    Muted(\"Last updated 5 minutes ago\")\n    Lead(\"A comprehensive guide to getting started.\")\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal, overload\n\nfrom pydantic import Field\n\nfrom prefab_ui.components.base import Component, _merge_css_classes\n\nTextAlign = Literal[\"left\", \"center\", \"right\", \"justify\"] | None\n\n\nclass _TextComponent(Component):\n    \"\"\"Base class for text components that accept positional content.\"\"\"\n\n    content: str = Field(description=\"Text content\")\n    bold: bool | None = Field(default=None, description=\"Render text in bold\")\n    italic: bool | None = Field(default=None, description=\"Render text in italic\")\n    align: TextAlign = Field(default=None, exclude=True)\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        \"\"\"Accept content as positional or keyword argument.\"\"\"\n        if content is not None:\n            kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n\n    def model_post_init(self, __context: Any) -> None:\n        if self.align is not None:\n            self.css_class = _merge_css_classes(f\"text-{self.align}\", self.css_class)\n        super().model_post_init(__context)\n\n\ndef _text_init(self: _TextComponent, content: str | None = None, **kwargs: Any) -> None:\n    \"\"\"Shared init implementation for text components.\"\"\"\n    if content is not None:\n        kwargs[\"content\"] = content\n    Component.__init__(self, **kwargs)\n\n\nclass H1(_TextComponent):\n    \"\"\"Large page heading (h1).\n\n    Example::\n\n        H1(\"Dashboard\")\n        H1(\"{{ title }}\")  # With interpolation\n    \"\"\"\n\n    type: Literal[\"H1\"] = \"H1\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass H2(_TextComponent):\n    \"\"\"Section heading (h2).\n\n    Example::\n\n        H2(\"User Settings\")\n        H2(\"{{ section_name }}\")\n    \"\"\"\n\n    type: Literal[\"H2\"] = \"H2\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass H3(_TextComponent):\n    \"\"\"Subsection heading (h3).\n\n    Example::\n\n        H3(\"Account Details\")\n    \"\"\"\n\n    type: Literal[\"H3\"] = \"H3\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass H4(_TextComponent):\n    \"\"\"Small heading (h4).\n\n    Example::\n\n        H4(\"Additional Options\")\n    \"\"\"\n\n    type: Literal[\"H4\"] = \"H4\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass P(_TextComponent):\n    \"\"\"Paragraph text.\n\n    Example::\n\n        P(\"Welcome to the application.\")\n        P(\"Hello, {{ name }}!\")\n    \"\"\"\n\n    type: Literal[\"P\"] = \"P\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass Lead(_TextComponent):\n    \"\"\"Lead paragraph with larger text for introductions.\n\n    Example::\n\n        Lead(\"A comprehensive guide to building MCP applications.\")\n    \"\"\"\n\n    type: Literal[\"Lead\"] = \"Lead\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass Large(_TextComponent):\n    \"\"\"Large text for emphasis.\n\n    Example::\n\n        Large(\"Important information\")\n    \"\"\"\n\n    type: Literal[\"Large\"] = \"Large\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass Small(_TextComponent):\n    \"\"\"Small text for fine print or metadata.\n\n    Example::\n\n        Small(\"Terms and conditions apply\")\n    \"\"\"\n\n    type: Literal[\"Small\"] = \"Small\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass Muted(_TextComponent):\n    \"\"\"Muted/secondary text for less prominent information.\n\n    Example::\n\n        Muted(\"Last updated 5 minutes ago\")\n        Muted(\"{{ subtitle }}\")\n    \"\"\"\n\n    type: Literal[\"Muted\"] = \"Muted\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass BlockQuote(_TextComponent):\n    \"\"\"Block quotation.\n\n    Example::\n\n        BlockQuote(\"The best way to predict the future is to invent it.\")\n    \"\"\"\n\n    type: Literal[\"BlockQuote\"] = \"BlockQuote\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n\n\nclass InlineCode(_TextComponent):\n    \"\"\"Inline code snippet.\n\n    Example::\n\n        InlineCode(\"npm install\")\n        InlineCode(\"{{ command }}\")\n    \"\"\"\n\n    type: Literal[\"InlineCode\"] = \"InlineCode\"\n\n    @overload\n    def __init__(self, content: str, /, **kwargs: Any) -> None: ...\n\n    @overload\n    def __init__(self, *, content: str, **kwargs: Any) -> None: ...\n\n    def __init__(self, content: str | None = None, **kwargs: Any) -> None:\n        _text_init(self, content, **kwargs)\n",
  "prefab_ui/actions/__init__.py": "\"\"\"Declarative actions for interactive Prefab components.\n\nActions define what happens when a user interacts with a component (clicks a\nbutton, changes a slider, etc.). They serialize to JSON and are executed by the\nclient-side renderer.\n\n**Transport-agnostic actions** — work with any backend:\n\n    Slider(on_change=SetState(\"brightness\"))\n    Button(\"Toggle\", on_click=ToggleState(\"showDetails\"))\n    Button(\"Open\", on_click=OpenLink(\"https://example.com\"))\n\n**MCP transport actions** — communicate with an MCP server:\n\n    from prefab_ui.actions.mcp import CallTool, SendMessage\n\n    Button(\"Refresh\", on_click=CallTool(\"get_data\"))\n    Button(\"Ask AI\", on_click=SendMessage(\"Summarize this\"))\n\nActions compose — pass a list for sequential execution::\n\n    Button(\"Submit\", on_click=[\n        SetState(\"loading\", True),\n        CallTool(\"process\", arguments={\"query\": \"{{ query }}\"}),\n    ])\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom prefab_ui.actions.base import Action\nfrom prefab_ui.actions.fetch import Fetch\nfrom prefab_ui.actions.file import FileUpload, OpenFilePicker\nfrom prefab_ui.actions.navigation import OpenLink\nfrom prefab_ui.actions.state import AppendState, PopState, SetState, ToggleState\nfrom prefab_ui.actions.timing import SetInterval\nfrom prefab_ui.actions.ui import CloseOverlay, ShowToast\n\n__all__ = [\n    \"Action\",\n    \"AppendState\",\n    \"CloseOverlay\",\n    \"Fetch\",\n    \"FileUpload\",\n    \"OpenFilePicker\",\n    \"OpenLink\",\n    \"PopState\",\n    \"SetInterval\",\n    \"SetState\",\n    \"ShowToast\",\n    \"ToggleState\",\n]\n",
  "prefab_ui/actions/base.py": "\"\"\"Base class for all Prefab actions.\n\nEvery action type inherits from ``Action``, which provides the\n``on_success`` and ``on_error`` lifecycle callbacks. These let you chain\nreactions to action outcomes without writing custom logic:\n\n    CallTool(\"save\",\n        on_success=ShowToast(\"Saved!\"),\n        on_error=ShowToast(\"Save failed\", variant=\"error\"),\n    )\n\nCallbacks can themselves have callbacks (recursive), and the renderer\nenforces a depth limit to prevent infinite loops. When actions compose\nas a list, the first error short-circuits the chain — the failing action's\n``on_error`` runs, then execution stops.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\nfrom pydantic import BaseModel, Field, SerializeAsAny, model_validator\n\nfrom prefab_ui.rx import _coerce_rx\n\n\nclass Action(BaseModel):\n    \"\"\"Base for all action types — provides lifecycle callbacks.\n\n    Subclasses add an ``action`` literal discriminator and their own fields.\n    The renderer serializes ``on_success``/``on_error`` recursively and\n    dispatches them after the parent action completes.\n\n    Uses ``SerializeAsAny`` so that Pydantic serializes callback values\n    using the concrete runtime type (e.g. ShowToast) rather than the\n    declared base type (Action), which would strip subclass fields.\n    \"\"\"\n\n    model_config = {\"populate_by_name\": True}\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _coerce_rx_values(cls, data: Any) -> Any:\n        \"\"\"Recursively convert any Rx values in the input dict to strings.\"\"\"\n        if isinstance(data, dict):\n            return {k: _coerce_rx(v) for k, v in data.items()}\n        return data\n\n    on_success: SerializeAsAny[Action] | list[SerializeAsAny[Action]] | None = Field(\n        default=None,\n        alias=\"onSuccess\",\n        description=\"Action(s) to run when this action succeeds\",\n    )\n    on_error: SerializeAsAny[Action] | list[SerializeAsAny[Action]] | None = Field(\n        default=None,\n        alias=\"onError\",\n        description=\"Action(s) to run when this action fails\",\n    )\n",
  "prefab_ui/actions/fetch.py": "\"\"\"Client-side HTTP fetch action.\n\nMakes HTTP requests directly from the browser using ``fetch()``. Use this\nfor REST API calls, loading external data, form submissions — anything\nthat talks HTTP without going through an MCP server.\n\nExample::\n\n    from prefab_ui.components import Button\n    from prefab_ui.actions import Fetch, ShowToast\n\n    Button(\"Load Users\", on_click=Fetch.get(\n        \"/api/users\",\n        result_key=\"users\",\n        on_error=ShowToast(\"{{ $error }}\", variant=\"error\"),\n    ))\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\nfrom urllib.parse import quote\n\nfrom pydantic import Field, field_validator\n\nfrom prefab_ui.actions.base import Action\nfrom prefab_ui.actions.state import _validate_path\n\nMethod = Literal[\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"]\n\n\nclass Fetch(Action):\n    \"\"\"Make an HTTP request from the browser.\n\n    Fires ``onSuccess`` with the parsed response body as ``$event``.\n    JSON responses are parsed automatically; other content types return\n    the raw text. Non-2xx responses trigger ``onError`` with the status\n    text as ``$error``.\n\n    If ``result_key`` is set, the response body is written into\n    client-side state at that key.\n    \"\"\"\n\n    action: Literal[\"fetch\"] = \"fetch\"\n    url: str = Field(description=\"URL to fetch. Supports {{ key }} interpolation.\")\n    method: Method = Field(default=\"GET\", description=\"HTTP method.\")\n    headers: dict[str, str] | None = Field(\n        default=None,\n        description=\"Request headers.\",\n    )\n    body: dict[str, Any] | str | None = Field(\n        default=None,\n        description=\"Request body. Dicts are JSON-serialized automatically.\",\n    )\n    result_key: str | None = Field(\n        default=None,\n        alias=\"resultKey\",\n        description=\"State key to store the response under.\",\n    )\n\n    @field_validator(\"result_key\")\n    @classmethod\n    def _validate_result_key(cls, v: str | None) -> str | None:\n        if v is not None:\n            _validate_path(v)\n        return v\n\n    def __init__(self, url: str, **kwargs: Any) -> None:\n        kwargs[\"url\"] = url\n        super().__init__(**kwargs)\n\n    @classmethod\n    def get(\n        cls,\n        url: str,\n        *,\n        params: dict[str, str] | None = None,\n        **kwargs: Any,\n    ) -> Fetch:\n        \"\"\"GET request. ``params`` are appended as a query string.\n\n        Values are kept raw so ``{{ key }}`` interpolation survives to the\n        renderer. Only param *names* are percent-encoded.\n        \"\"\"\n        if params:\n            sep = \"&\" if \"?\" in url else \"?\"\n            qs = \"&\".join(f\"{quote(k, safe='')}={v}\" for k, v in params.items())\n            url = f\"{url}{sep}{qs}\"\n        return cls(url, method=\"GET\", **kwargs)\n\n    @classmethod\n    def post(\n        cls, url: str, *, body: dict[str, Any] | str | None = None, **kwargs: Any\n    ) -> Fetch:\n        \"\"\"POST request with an optional body.\"\"\"\n        return cls(url, method=\"POST\", body=body, **kwargs)\n\n    @classmethod\n    def put(\n        cls, url: str, *, body: dict[str, Any] | str | None = None, **kwargs: Any\n    ) -> Fetch:\n        \"\"\"PUT request with an optional body.\"\"\"\n        return cls(url, method=\"PUT\", body=body, **kwargs)\n\n    @classmethod\n    def patch(\n        cls, url: str, *, body: dict[str, Any] | str | None = None, **kwargs: Any\n    ) -> Fetch:\n        \"\"\"PATCH request with an optional body.\"\"\"\n        return cls(url, method=\"PATCH\", body=body, **kwargs)\n\n    @classmethod\n    def delete(cls, url: str, **kwargs: Any) -> Fetch:\n        \"\"\"DELETE request.\"\"\"\n        return cls(url, method=\"DELETE\", **kwargs)\n",
  "prefab_ui/actions/file.py": "\"\"\"File upload actions and data types.\n\nProvides the :class:`OpenFilePicker` action (triggers the browser file\npicker from any clickable element) and the :class:`FileUpload` data type\n(describes the shape of uploaded file data in ``$event``).\n\nExample::\n\n    from prefab_ui.components import Button\n    from prefab_ui.actions import OpenFilePicker\n    from prefab_ui.actions.mcp import CallTool\n\n    Button(\"Upload CSV\", on_click=OpenFilePicker(\n        accept=\".csv\",\n        on_success=CallTool(\"process_csv\", arguments={\"file\": \"{{ $event }}\"}),\n    ))\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel, Field\n\nfrom prefab_ui.actions.base import Action\n\n\nclass FileUpload(BaseModel):\n    \"\"\"Data for a single uploaded file.\n\n    Produced by :class:`~prefab_ui.components.DropZone` and\n    :class:`OpenFilePicker` events.  Use this type to annotate MCP tool\n    parameters that receive file data::\n\n        from prefab_ui.actions import FileUpload\n\n        @server.tool()\n        def process_csv(file: FileUpload):\n            contents = base64.b64decode(file.data)\n            ...\n\n    For multiple-file uploads, annotate as ``list[FileUpload]``.\n    \"\"\"\n\n    name: str = Field(description=\"Original filename\")\n    size: int = Field(description=\"File size in bytes\")\n    type: str = Field(description=\"MIME type (e.g. 'image/png')\")\n    data: str = Field(description=\"Base64-encoded file content (no data: URL prefix)\")\n\n\nclass OpenFilePicker(Action):\n    \"\"\"Open the browser file picker and read selected files to base64.\n\n    Fires ``onSuccess`` with the file data as ``$event``:\n    - Single file mode: ``{name, size, type, data}``\n    - Multiple file mode: ``[{name, size, type, data}, ...]``\n\n    Must execute before any async server actions in the action chain\n    (CallTool, SendMessage) since those break the browser's\n    user-activation window needed to open the file picker.\n\n    Args:\n        accept: File type filter (e.g. ``\"image/*\"``, ``\".csv,.xlsx\"``).\n        multiple: Allow selecting multiple files.\n        max_size: Maximum file size in bytes. Files exceeding this are\n            rejected with an error toast.\n    \"\"\"\n\n    action: Literal[\"openFilePicker\"] = \"openFilePicker\"\n    accept: str | None = Field(\n        default=None,\n        description=\"File type filter (e.g. 'image/*', '.csv,.xlsx')\",\n    )\n    multiple: bool = Field(\n        default=False,\n        description=\"Allow selecting multiple files\",\n    )\n    max_size: int | None = Field(\n        default=None,\n        alias=\"maxSize\",\n        description=\"Maximum file size in bytes\",\n    )\n",
  "prefab_ui/actions/mcp.py": "\"\"\"MCP transport actions.\n\nThese actions communicate with an MCP server via the MCP Apps protocol.\nThey're only meaningful when the renderer is connected to an MCP host.\n\nFor transport-agnostic actions (state, navigation, toasts), see the parent\nmodule.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions.base import Action\n\n\nclass CallTool(Action):\n    \"\"\"Call an MCP server tool via ``app.callServerTool()``.\n\n    If ``result_key`` is set, the tool's return value is written into\n    client-side state at that key. The key supports interpolation:\n    ``result_key=\"detail_{{ selectedId }}\"``.\n    \"\"\"\n\n    action: Literal[\"toolCall\"] = \"toolCall\"\n    tool: str = Field(description=\"Name of the server tool to call\")\n    arguments: dict[str, Any] = Field(\n        default_factory=dict,\n        description=\"Arguments to pass. Supports {{ key }} interpolation.\",\n    )\n    result_key: str | None = Field(\n        default=None,\n        alias=\"resultKey\",\n        description=\"State key to store the tool result under\",\n    )\n\n    def __init__(self, tool: str, **kwargs: Any) -> None:\n        kwargs[\"tool\"] = tool\n        super().__init__(**kwargs)\n\n\nclass SendMessage(Action):\n    \"\"\"Send a message to the chat via ``app.sendMessage()``.\"\"\"\n\n    action: Literal[\"sendMessage\"] = \"sendMessage\"\n    content: str = Field(description=\"Message text to send\")\n\n    def __init__(self, content: str, **kwargs: Any) -> None:\n        kwargs[\"content\"] = content\n        super().__init__(**kwargs)\n\n\nclass UpdateContext(Action):\n    \"\"\"Update model context without triggering a response.\"\"\"\n\n    action: Literal[\"updateContext\"] = \"updateContext\"\n    content: str | None = Field(default=None, description=\"Text content to add\")\n    structured_content: dict[str, Any] | None = Field(\n        default=None,\n        alias=\"structuredContent\",\n        description=\"Structured content to add\",\n    )\n",
  "prefab_ui/actions/navigation.py": "\"\"\"Navigation actions.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions.base import Action\n\n\nclass OpenLink(Action):\n    \"\"\"Open a URL via the host.\"\"\"\n\n    action: Literal[\"openLink\"] = \"openLink\"\n    url: str = Field(description=\"URL to open\")\n\n    def __init__(self, url: str, **kwargs: Any) -> None:\n        kwargs[\"url\"] = url\n        super().__init__(**kwargs)\n",
  "prefab_ui/actions/state.py": "\"\"\"Client-side state management actions.\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom typing import Any, Literal\n\nfrom pydantic import Field, field_validator\n\nfrom prefab_ui.actions.base import Action\n\n_KEY_RE = re.compile(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\")\n\n\ndef _validate_path(path: str) -> str:\n    \"\"\"Validate a state key or dot-path.\n\n    Each segment must be either a valid identifier (``[a-zA-Z_][a-zA-Z0-9_]*``)\n    or a pure integer (array index). Periods delimit segments.\n    \"\"\"\n    for segment in path.split(\".\"):\n        if \"{{\" in segment:\n            continue\n        if segment.isdigit():\n            continue\n        if not _KEY_RE.match(segment):\n            raise ValueError(\n                f\"Invalid path segment: {segment!r}. \"\n                \"Segments must be identifiers ([a-zA-Z_][a-zA-Z0-9_]*) or integers.\"\n            )\n    return path\n\n\nclass SetState(Action):\n    \"\"\"Set a client-side state variable. No server round-trip.\n\n    The default ``value`` of ``{{ $event }}`` captures the event value\n    (slider position, input text, checkbox state, etc.).\n\n    The ``key`` supports dot-paths for nested updates::\n\n        SetState(\"todos.0.done\", True)   # deep-update into a list\n    \"\"\"\n\n    action: Literal[\"setState\"] = \"setState\"\n    key: str = Field(description=\"State key or dot-path to set\")\n    value: Any = Field(\n        default=\"{{ $event }}\",\n        description=\"Value to set. Use '{{ $event }}' for the event value.\",\n    )\n\n    @field_validator(\"key\")\n    @classmethod\n    def _validate_key(cls, v: str) -> str:\n        return _validate_path(v)\n\n    def __init__(self, key: str, value: Any = \"{{ $event }}\", **kwargs: Any) -> None:\n        kwargs[\"key\"] = key\n        kwargs[\"value\"] = value\n        super().__init__(**kwargs)\n\n\nclass ToggleState(Action):\n    \"\"\"Flip a boolean state variable. No server round-trip.\"\"\"\n\n    action: Literal[\"toggleState\"] = \"toggleState\"\n    key: str = Field(description=\"State key or dot-path to toggle\")\n\n    @field_validator(\"key\")\n    @classmethod\n    def _validate_key(cls, v: str) -> str:\n        return _validate_path(v)\n\n    def __init__(self, key: str, **kwargs: Any) -> None:\n        kwargs[\"key\"] = key\n        super().__init__(**kwargs)\n\n\nclass AppendState(Action):\n    \"\"\"Append a value to a state array.\n\n    Appends to the end by default. Pass ``index`` to insert at a specific\n    position (supports negative indices, e.g. ``index=0`` to prepend).\n\n    If the key doesn't exist yet, creates a new single-element array.\n    \"\"\"\n\n    action: Literal[\"appendState\"] = \"appendState\"\n    key: str = Field(description=\"State key or dot-path to the array\")\n    value: Any = Field(\n        default=\"{{ $event }}\",\n        description=\"Value to append.\",\n    )\n    index: int | str | None = Field(\n        default=None,\n        description=\"Insert position (int or template string). None to append at end.\",\n    )\n\n    @field_validator(\"key\")\n    @classmethod\n    def _validate_key(cls, v: str) -> str:\n        return _validate_path(v)\n\n    def __init__(\n        self,\n        key: str,\n        value: Any = \"{{ $event }}\",\n        *,\n        index: int | str | None = None,\n        **kwargs: Any,\n    ) -> None:\n        kwargs[\"key\"] = key\n        kwargs[\"value\"] = value\n        kwargs[\"index\"] = index\n        super().__init__(**kwargs)\n\n\nclass PopState(Action):\n    \"\"\"Remove an item by index from a state array.\n\n    Supports negative indices (e.g. ``-1`` for the last element).\n    \"\"\"\n\n    action: Literal[\"popState\"] = \"popState\"\n    key: str = Field(description=\"State key or dot-path to the array\")\n    index: int | str = Field(\n        description=\"Index to remove (int or template string like '{{ $index }}').\"\n    )\n\n    @field_validator(\"key\")\n    @classmethod\n    def _validate_key(cls, v: str) -> str:\n        return _validate_path(v)\n\n    def __init__(self, key: str, index: int | str, **kwargs: Any) -> None:\n        kwargs[\"key\"] = key\n        kwargs[\"index\"] = index\n        super().__init__(**kwargs)\n",
  "prefab_ui/actions/timing.py": "\"\"\"Timing actions — periodic and delayed execution.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field, SerializeAsAny\n\nfrom prefab_ui.actions.base import Action\n\n\nclass SetInterval(Action):\n    \"\"\"Execute actions on a repeating schedule.\n\n    Starts a client-side timer that fires ``on_tick`` every ``duration``\n    milliseconds.  The interval stops when ``while_`` evaluates to falsy\n    or ``count`` ticks have elapsed — whichever comes first.  When it\n    stops, ``on_complete`` fires.\n\n    Use ``count=1`` for a one-shot delay::\n\n        SetInterval(3000, count=1, on_complete=ShowToast(\"Still there?\"))\n    \"\"\"\n\n    action: Literal[\"setInterval\"] = \"setInterval\"\n    duration: int = Field(description=\"Interval between ticks, in milliseconds.\")\n    while_: str | None = Field(\n        default=None,\n        alias=\"while\",\n        description=(\n            \"Condition expression re-evaluated each tick. \"\n            \"When falsy, the interval stops.\"\n        ),\n    )\n    count: int | None = Field(\n        default=None,\n        description=\"Maximum number of ticks. The interval stops after this many.\",\n    )\n    on_tick: SerializeAsAny[Action] | list[SerializeAsAny[Action]] | None = Field(\n        default=None,\n        alias=\"onTick\",\n        description=\"Action(s) to run each tick. $event is the tick number (1, 2, …).\",\n    )\n    on_complete: SerializeAsAny[Action] | list[SerializeAsAny[Action]] | None = Field(\n        default=None,\n        alias=\"onComplete\",\n        description=\"Action(s) to run when the interval finishes.\",\n    )\n\n    def __init__(self, duration: int, **kwargs: Any) -> None:\n        kwargs[\"duration\"] = duration\n        super().__init__(**kwargs)\n",
  "prefab_ui/actions/ui.py": "\"\"\"UI-focused client-side actions.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom prefab_ui.actions.base import Action\n\n\nclass ShowToast(Action):\n    \"\"\"Display a toast notification. Client-side only, no server trip.\"\"\"\n\n    action: Literal[\"showToast\"] = \"showToast\"\n    message: str = Field(description=\"Toast message text\")\n    description: str | None = Field(default=None, description=\"Optional secondary text\")\n    variant: Literal[\"default\", \"success\", \"error\", \"warning\", \"info\"] | None = Field(\n        default=None, description=\"Toast style variant\"\n    )\n    duration: int | None = Field(\n        default=None, description=\"Auto-dismiss duration in milliseconds\"\n    )\n\n    def __init__(self, message: str, **kwargs: Any) -> None:\n        kwargs[\"message\"] = message\n        super().__init__(**kwargs)\n\n\nclass CloseOverlay(Action):\n    \"\"\"Close the nearest ancestor overlay (Dialog or Popover).\"\"\"\n\n    action: Literal[\"closeOverlay\"] = \"closeOverlay\"\n",
  "prefab_ui/renderer/__init__.py": "\"\"\"Renderer resource loader for Prefab.\n\nShips a pre-built, self-contained HTML file (all JS/CSS inlined) inside the\nPython package.  ``get_renderer_html()`` reads and returns it directly — no\nexternal server, CDN, or CSP domains required.\n\nSet ``PREFAB_RENDERER_URL`` to load renderer assets from an external origin\ninstead — useful for local development with ``npx vite preview`` or a CDN::\n\n    PREFAB_RENDERER_URL=http://localhost:4173 uv run python my_server.py\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\nfrom urllib.parse import urlparse\n\n_BUNDLED_HTML = Path(__file__).parent / \"app.html\"\n\n_EXTERNAL_HEAD = \"\"\"\\\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Prefab</title>\n  <link rel=\"stylesheet\" crossorigin href=\"{base_url}/assets/renderer.css\">\n  <script type=\"module\" crossorigin src=\"{base_url}/assets/renderer.js\"></script>\"\"\"\n\n_EXTERNAL_TEMPLATE = \"\"\"\\\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Prefab</title>\n  <link rel=\"stylesheet\" crossorigin href=\"{base_url}/assets/renderer.css\">\n</head>\n<body>\n  <div id=\"root\"></div>\n  <script type=\"module\" crossorigin src=\"{base_url}/assets/renderer.js\"></script>\n</body>\n</html>\n\"\"\"\n\n\ndef _get_origin(url: str) -> str:\n    \"\"\"Extract the origin (scheme + host + port) from a URL.\"\"\"\n    parsed = urlparse(url)\n    origin = f\"{parsed.scheme}://{parsed.hostname}\"\n    if parsed.port:\n        origin += f\":{parsed.port}\"\n    return origin\n\n\ndef get_renderer_head() -> str:\n    \"\"\"Return the renderer ``<head>`` content (JS, CSS, meta tags).\n\n    For bundled mode, extracts everything between ``<head>`` and\n    ``</head>`` from the self-contained HTML bundle.  For external mode,\n    returns ``<link>``/``<script>`` tags pointing at the external URL.\n    \"\"\"\n    override = os.environ.get(\"PREFAB_RENDERER_URL\")\n    if override:\n        return _EXTERNAL_HEAD.format(base_url=override.rstrip(\"/\"))\n    html = _BUNDLED_HTML.read_text(encoding=\"utf-8\")\n    head_start = html.index(\"<head>\") + len(\"<head>\")\n    head_end = html.index(\"</head>\")\n    return html[head_start:head_end].rstrip()\n\n\ndef get_renderer_html() -> str:\n    \"\"\"Return the renderer HTML.\n\n    By default, returns the bundled single-file HTML with all JS/CSS\n    inlined.  When ``PREFAB_RENDERER_URL`` is set, returns a lightweight\n    stub that loads assets from that external origin.\n    \"\"\"\n    override = os.environ.get(\"PREFAB_RENDERER_URL\")\n    if override:\n        return _EXTERNAL_TEMPLATE.format(base_url=override.rstrip(\"/\"))\n    return _BUNDLED_HTML.read_text(encoding=\"utf-8\")\n\n\ndef get_renderer_csp() -> dict[str, list[str]]:\n    \"\"\"Return CSP domains needed for the renderer to load.\n\n    The bundled renderer is fully self-contained, so no CSP domains are\n    needed.  When ``PREFAB_RENDERER_URL`` is set, returns the external\n    origin so the host sandbox allows loading those assets.\n    \"\"\"\n    override = os.environ.get(\"PREFAB_RENDERER_URL\")\n    if override:\n        return {\"resource_domains\": [_get_origin(override.rstrip(\"/\"))]}\n    return {\"resource_domains\": []}\n"
}