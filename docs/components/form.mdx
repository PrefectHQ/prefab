---
title: Form
description: Generate complete forms from Pydantic models with automatic labels, validation, and submission.
icon: file-lines
---

import { ComponentPreview } from '/snippets/component-preview.mdx'

`Form.from_model()` introspects a Pydantic model and generates a complete form — labels, typed inputs, validation constraints, and a submit button — from the model's field definitions. You can also build forms by hand for full control over layout and behavior.

## Generating Forms from Models

Pass a Pydantic model to `Form.from_model()` along with a submit action. Each field becomes a labeled input, with the field's type determining the input component and `Field()` metadata controlling labels, placeholders, and constraints.

<ComponentPreview json={{"view":{"cssClass":"gap-4","type":"Form","onSubmit":{"onError":{"action":"showToast","message":"{{ $error }}","variant":"error"},"action":"toolCall","tool":"submit_contact","arguments":{"data":{"name":"{{ name }}","email":"{{ email }}","message":"{{ message }}"}}},"children":[{"cssClass":"gap-2","type":"Column","children":[{"type":"Label","text":"Full Name"},{"type":"Input","inputType":"text","placeholder":"Full Name","name":"name","disabled":false,"required":true,"minLength":1}]},{"cssClass":"gap-2","type":"Column","children":[{"type":"Label","text":"Email"},{"type":"Input","inputType":"email","placeholder":"Email","name":"email","disabled":false,"required":true}]},{"cssClass":"gap-2","type":"Column","children":[{"type":"Label","text":"Message"},{"type":"Textarea","placeholder":"Your message","name":"message","rows":4,"disabled":false,"required":true}]},{"type":"Button","label":"Submit","variant":"default","size":"default","disabled":false,"onClick":{"onError":{"action":"showToast","message":"{{ $error }}","variant":"error"},"action":"toolCall","tool":"submit_contact","arguments":{"data":{"name":"{{ name }}","email":"{{ email }}","message":"{{ message }}"}}}}]}}}>
<CodeGroup>
```python Python icon="python"
from pydantic import BaseModel, Field
from prefab_ui.components import Form
from prefab_ui.actions import ToolCall

class ContactInfo(BaseModel):
    name: str = Field(title="Full Name", min_length=1)
    email: str
    message: str = Field(
        description="Your message",
        json_schema_extra={"ui": {"type": "textarea", "rows": 4}},
    )

Form.from_model(ContactInfo, on_submit=ToolCall("submit_contact"))
```
```json Protocol icon="brackets-curly"
{
  "view": {
    "cssClass": "gap-4",
    "type": "Form",
    "onSubmit": {
      "onError": {
        "action": "showToast",
        "message": "{{ $error }}",
        "variant": "error"
      },
      "action": "toolCall",
      "tool": "submit_contact",
      "arguments": {
        "data": {
          "name": "{{ name }}",
          "email": "{{ email }}",
          "message": "{{ message }}"
        }
      }
    },
    "children": [
      {
        "cssClass": "gap-2",
        "type": "Column",
        "children": [
          {
            "type": "Label",
            "text": "Full Name"
          },
          {
            "type": "Input",
            "inputType": "text",
            "placeholder": "Full Name",
            "name": "name",
            "disabled": false,
            "required": true,
            "minLength": 1
          }
        ]
      },
      {
        "cssClass": "gap-2",
        "type": "Column",
        "children": [
          {
            "type": "Label",
            "text": "Email"
          },
          {
            "type": "Input",
            "inputType": "email",
            "placeholder": "Email",
            "name": "email",
            "disabled": false,
            "required": true
          }
        ]
      },
      {
        "cssClass": "gap-2",
        "type": "Column",
        "children": [
          {
            "type": "Label",
            "text": "Message"
          },
          {
            "type": "Textarea",
            "placeholder": "Your message",
            "name": "message",
            "rows": 4,
            "disabled": false,
            "required": true
          }
        ]
      },
      {
        "type": "Button",
        "label": "Submit",
        "variant": "default",
        "size": "default",
        "disabled": false,
        "onClick": {
          "onError": {
            "action": "showToast",
            "message": "{{ $error }}",
            "variant": "error"
          },
          "action": "toolCall",
          "tool": "submit_contact",
          "arguments": {
            "data": {
              "name": "{{ name }}",
              "email": "{{ email }}",
              "message": "{{ message }}"
            }
          }
        }
      }
    ]
  }
}
```
</CodeGroup>
</ComponentPreview>

## Type Mapping

The field's Python type determines which input component is rendered:

| Python type | Input component |
|---|---|
| `str` | Text input (auto-detects `email`, `password`, `tel`, `url` from field name) |
| `int`, `float` | Number input |
| `bool` | Checkbox |
| `Literal["a", "b", "c"]` | Select dropdown |
| `SecretStr` | Password input |
| `datetime.date` | Date picker |
| `datetime.time` | Time picker |
| `datetime.datetime` | Datetime picker |

## Constraints and Metadata

Pydantic `Field()` parameters map directly to form behavior:

| Field metadata | Form effect |
|---|---|
| `Field(title="...")` | Label text (fallback: humanized field name) |
| `Field(description="...")` | Placeholder text |
| `Field(min_length=..., max_length=...)` | HTML input constraints |
| `Field(ge=..., le=...)` | Number input min/max |
| `Field(json_schema_extra={"ui": {"type": "textarea", "rows": 4}})` | Textarea override |
| `Field(exclude=True)` | Skip field entirely |

## Auto-Fill Arguments

When `on_submit` is a `ToolCall` with no `arguments`, `from_model()` auto-generates the arguments from the model's fields, wrapped under a `data` key.

```python Auto-Fill
from pydantic import BaseModel, Field
from prefab_ui.components import Form
from prefab_ui.actions import ToolCall

class ContactInfo(BaseModel):
    name: str = Field(title="Full Name", min_length=1)
    email: str
    message: str

Form.from_model(ContactInfo, on_submit=ToolCall("submit_contact"))
```

The generated `ToolCall` is equivalent to writing this explicitly:

```python
ToolCall("submit_contact", arguments={
    "data": {
        "name": "{{ name }}",
        "email": "{{ email }}",
        "message": "{{ message }}",
    }
})
```

This convention enables a powerful pattern: a tool that both displays the form and processes the submission.

## Self-Calling Tool Pattern

A single tool can serve as both the form renderer and the form handler. On the first call (no data), it returns the form. When the user submits, the auto-filled arguments pass the form values back to the same tool as a validated Pydantic model.

```python Self-Calling Tool
from pydantic import BaseModel, Field
from prefab_ui import FastMCP
from prefab_ui import AppResult
from prefab_ui.actions import ToolCall, ShowToast
from prefab_ui.components import Form, Text

mcp = FastMCP("Contacts")

class Contact(BaseModel):
    name: str = Field(min_length=1)
    email: str
    phone: str = ""

@mcp.tool(ui=True)
async def create_contact(data: Contact | None = None) -> AppResult:
    if data is None:
        return AppResult(
            view=Form.from_model(
                Contact,
                on_submit=ToolCall(
                    "create_contact",
                    on_success=ShowToast("Saved!"),
                ),
            ),
        )
    save_to_db(data)
    return AppResult(view=Text(f"Created contact: {data.name}"))
```

When `data` is `None` (the initial call), the tool returns a form. When the user fills in the fields and clicks submit, the renderer calls `create_contact` again with `data` populated from the form values. Pydantic validates the input automatically, so `data` arrives as a fully validated `Contact` instance.

## Error Handling

When `on_submit` is auto-filled and no `on_error` is specified, `from_model()` adds a default error toast:

```python
ShowToast("{{ $error }}", variant="error")
```

The `$error` variable captures the error message from a failed tool call, making validation errors visible to the user without any extra configuration.

You can override this with your own `on_error`:

```python Custom Error Handling
from pydantic import BaseModel, Field
from prefab_ui.components import Form
from prefab_ui.actions import ToolCall, ShowToast

class Contact(BaseModel):
    name: str = Field(min_length=1)
    email: str

Form.from_model(
    Contact,
    on_submit=ToolCall(
        "create_contact",
        on_error=ShowToast("Could not save: {{ $error }}", variant="error"),
    ),
)
```

## Building Forms by Hand

For full control over layout and behavior, combine individual input components directly. Named inputs automatically sync their values to client state, so `{{ name }}` references the current value of `Input(name="name")`.

<ComponentPreview json={{"view":{"cssClass":"gap-3","type":"Column","children":[{"type":"Label","text":"Name"},{"type":"Input","inputType":"text","placeholder":"Your name","name":"name","disabled":false,"required":false},{"type":"Label","text":"Email"},{"type":"Input","inputType":"email","placeholder":"you@example.com","name":"email","disabled":false,"required":false},{"type":"Button","label":"Submit","variant":"default","size":"default","disabled":false,"onClick":{"action":"toolCall","tool":"create_user","arguments":{"name":"{{ name }}","email":"{{ email }}"}}}]}}}>
<CodeGroup>
```python Python icon="python"
from prefab_ui.components import Button, Column, Input, Label
from prefab_ui.actions import ToolCall

with Column(gap=3):
    Label("Name")
    Input(name="name", placeholder="Your name")
    Label("Email")
    Input(name="email", input_type="email", placeholder="you@example.com")
    Button("Submit", on_click=ToolCall(
        "create_user",
        arguments={"name": "{{ name }}", "email": "{{ email }}"},
    ))
```
```json Protocol icon="brackets-curly"
{
  "view": {
    "cssClass": "gap-3",
    "type": "Column",
    "children": [
      {
        "type": "Label",
        "text": "Name"
      },
      {
        "type": "Input",
        "inputType": "text",
        "placeholder": "Your name",
        "name": "name",
        "disabled": false,
        "required": false
      },
      {
        "type": "Label",
        "text": "Email"
      },
      {
        "type": "Input",
        "inputType": "email",
        "placeholder": "you@example.com",
        "name": "email",
        "disabled": false,
        "required": false
      },
      {
        "type": "Button",
        "label": "Submit",
        "variant": "default",
        "size": "default",
        "disabled": false,
        "onClick": {
          "action": "toolCall",
          "tool": "create_user",
          "arguments": {
            "name": "{{ name }}",
            "email": "{{ email }}"
          }
        }
      }
    ]
  }
}
```
</CodeGroup>
</ComponentPreview>

This approach gives you complete control, but it requires wiring up every label, input type, and argument template yourself. For models with many fields, `Form.from_model()` handles all of that automatically.

## Unsupported Types

`from_model()` skips fields with complex types that have no natural form input mapping: `list`, `dict`, `set`, `tuple`, and nested `BaseModel` instances. If you need these, build those parts of the form manually and handle the arguments yourself.

## API Reference

<Card icon="code" title="Form Parameters">
<ParamField body="gap" type="int" default="4">
  Spacing between form children (maps to Tailwind `gap-N`).
</ParamField>

<ParamField body="on_submit" type="Action | list[Action] | None" default="None">
  Action(s) to execute when the form is submitted.
</ParamField>

<ParamField body="css_class" type="str | None" default="None">
  Additional Tailwind CSS classes.
</ParamField>
</Card>

<Card icon="code" title="Form.from_model() Parameters">
<ParamField body="model" type="type[BaseModel]" required>
  Pydantic model class to generate the form from.
</ParamField>

<ParamField body="submit_label" type="str" default='"Submit"'>
  Text for the submit button.
</ParamField>

<ParamField body="on_submit" type="Action | list[Action] | None" default="None">
  Action(s) fired on submit. A `ToolCall` with no arguments gets auto-filled from model fields.
</ParamField>

<ParamField body="css_class" type="str | None" default="None">
  Additional CSS classes on the form container.
</ParamField>
</Card>

## Protocol Reference

```json Form
{
  "type": "Form",
  "children?": "[Component]",
  "onSubmit?": "Action | [Action]",
  "cssClass?": "string"
}
```

For the complete protocol schema, see [Form](/protocol/form).
