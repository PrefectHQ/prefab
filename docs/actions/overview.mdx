---
title: Overview
description: Connect UI interactions to server tools, state changes, and navigation.
icon: bolt
---

Actions define what happens when a user interacts with a component. Click a button, toggle a switch, move a slider — the action determines whether that interaction calls a server tool, updates local state, or opens a URL.

Every component that supports interaction accepts action props like `on_click`, `on_change`, or `on_submit`. You pass an action instance (or a list of them) to wire up the behavior.

```python
from prefab_ui.components import Button
from prefab_ui.actions import SetState
from prefab_ui.actions.mcp import CallTool

Button("Run Analysis", on_click=CallTool("analyze"))
Button("Reset", on_click=SetState("count", 0))
```

There are two kinds of actions. **Client actions** mutate local state instantly with no server round-trip: [SetState](/actions/state), [ShowToast](/actions/show-toast), [OpenLink](/actions/open-link), [Fetch](/actions/fetch). **MCP actions** communicate with the host application through the Prefab SDK: [CallTool](/actions/call-tool), [SendMessage](/actions/send-message), [UpdateContext](/actions/update-context).

## Form Controls and State

Every form control automatically syncs its value to `$state` using an auto-generated state key. When a user types in an `Input`, the renderer updates that key on every keystroke — no `SetState` or `on_change` needed. Assign the component to a variable and use `.rx` to reference its current value from other components and actions.

```python
from prefab_ui.components import Input, Button, Column
from prefab_ui.actions.mcp import CallTool

with Column(gap=3):
    city_input = Input(placeholder="Enter a city...")
    Button(
        "Get Weather",
        on_click=CallTool(
            "get_weather",
            arguments={"location": city_input.rx},
        ),
    )
```

This works for all stateful controls: `Input`, `Textarea`, `Select`, `Combobox`, `RadioGroup`, `Slider`, `Checkbox`, `Switch`, `Calendar`, `DatePicker`, `Tabs`, and `Pages`. Each auto-generates a state key, and `.rx` returns a reactive reference to it.

`SetState` is still useful when you want to set state from a button click, toggle visibility, or store a value that doesn't come from a form control.

## State Interpolation

Actions support `{{ key }}` templates to inject the current client state into arguments, messages, or URLs. This is how UI values flow into server calls and other actions.

## Composing Actions

Pass a list to execute multiple actions from a single interaction:

```python
from prefab_ui.components import Button
from prefab_ui.actions import SetState
from prefab_ui.actions.mcp import CallTool

Button("Submit", on_click=[
    SetState("status", "analyzing..."),
    CallTool("process", arguments={"query": "{{ query }}"}),
])
```

Actions execute in order. This pattern is useful for updating UI state (like showing a loading indicator) before triggering a server call.
