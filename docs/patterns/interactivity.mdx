---
title: Interactivity
description: Patterns for building reactive UIs with state-driven rendering, conditional visibility, and server data refresh.
icon: wand-magic-sparkles
---

import { ComponentPreview } from '/snippets/component-preview.mdx'

## State-Driven UI

Every named form control automatically syncs its value to client state, and `{{ key }}` interpolation makes that state available to any component. There is no manual event wiring — name a control, reference the key, and the UI stays in sync.

<ComponentPreview auto json={`{"view":{"cssClass":"gap-3","type":"Column","children":[{"type":"Input","inputType":"text","placeholder":"Type your name...","name":"name","disabled":false,"required":false},{"type":"Text","content":"Hello, {{ name }}!"}]}}`}>
<CodeGroup>
```python Python icon="python"
from prefab_ui.components import Column, Input, Text

with Column(gap=3):
    Input(name="name", placeholder="Type your name...")
    Text("Hello, {{ name }}!")
```
```json Protocol icon="brackets-curly"
{
  "view": {
    "cssClass": "gap-3",
    "type": "Column",
    "children": [
      {
        "type": "Input",
        "inputType": "text",
        "placeholder": "Type your name...",
        "name": "name",
        "disabled": false,
        "required": false
      },
      {
        "type": "Text",
        "content": "Hello, {{ name }}!"
      }
    ]
  }
}
```
</CodeGroup>
</ComponentPreview>

Type in the input, and the text updates instantly. The `name="name"` prop creates a state key called `name`, and `{{ name }}` reads it wherever it appears.

## Conditional Visibility

Use `If` / `Else` blocks to show or hide content based on state. Pair with `ToggleState` to toggle visibility on demand.

<ComponentPreview auto json={`{"view":{"cssClass":"gap-2","type":"Column","children":[{"type":"Button","label":"Toggle Details","variant":"outline","size":"default","disabled":false,"onClick":{"action":"toggleState","key":"showDetails"}},{"type":"Condition","cases":[{"when":"showDetails","children":[{"type":"Alert","variant":"default","children":[{"type":"AlertTitle","content":"Here are the hidden details!"}]}]}]}]}}`}>
<CodeGroup>
```python Python icon="python"
from prefab_ui.components import Alert, AlertTitle, Button, Column, If
from prefab_ui.actions import ToggleState

with Column(gap=2):
    Button("Toggle Details", variant="outline", on_click=ToggleState("showDetails"))
    with If("showDetails"):
        with Alert():
            AlertTitle("Here are the hidden details!")
```
```json Protocol icon="brackets-curly"
{
  "view": {
    "cssClass": "gap-2",
    "type": "Column",
    "children": [
      {
        "type": "Button",
        "label": "Toggle Details",
        "variant": "outline",
        "size": "default",
        "disabled": false,
        "onClick": {
          "action": "toggleState",
          "key": "showDetails"
        }
      },
      {
        "type": "Condition",
        "cases": [
          {
            "when": "showDetails",
            "children": [
              {
                "type": "Alert",
                "variant": "default",
                "children": [
                  {
                    "type": "AlertTitle",
                    "content": "Here are the hidden details!"
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  }
}
```
</CodeGroup>
</ComponentPreview>

Clicking the button flips `showDetails` between `True` and `False`. When `False`, the alert is removed from the rendered output entirely.

## Dynamic Data Refresh

`ToolCall` with `result_key` fetches data from the server and writes the return value into client state. Other components read that data through interpolation, so the UI updates as soon as the response arrives.

<ComponentPreview auto json={`{"view":{"cssClass":"gap-3","type":"Column","children":[{"type":"Input","inputType":"text","placeholder":"Search users...","name":"search","disabled":false,"required":false},{"type":"Button","label":"Search","variant":"default","size":"default","disabled":false,"onClick":{"action":"toolCall","tool":"find_users","arguments":{"query":"{{ search }}"},"resultKey":"results"}},{"type":"DataTable","columns":[{"key":"name","header":"Name","sortable":true},{"key":"email","header":"Email","sortable":false}],"rows":"{{ results }}","searchable":true,"paginated":false,"pageSize":10}]}}`}>
<CodeGroup>
```python Python icon="python"
from prefab_ui.components import Button, Column, DataTable, DataTableColumn, Input
from prefab_ui.actions import ToolCall

with Column(gap=3):
    Input(name="search", placeholder="Search users...")
    Button("Search", on_click=ToolCall(
        "find_users",
        arguments={"query": "{{ search }}"},
        result_key="results",
    ))
    DataTable(
        columns=[
            DataTableColumn(key="name", header="Name", sortable=True),
            DataTableColumn(key="email", header="Email"),
        ],
        rows="{{ results }}",
        searchable=True,
    )
```
```json Protocol icon="brackets-curly"
{
  "view": {
    "cssClass": "gap-3",
    "type": "Column",
    "children": [
      {
        "type": "Input",
        "inputType": "text",
        "placeholder": "Search users...",
        "name": "search",
        "disabled": false,
        "required": false
      },
      {
        "type": "Button",
        "label": "Search",
        "variant": "default",
        "size": "default",
        "disabled": false,
        "onClick": {
          "action": "toolCall",
          "tool": "find_users",
          "arguments": {
            "query": "{{ search }}"
          },
          "resultKey": "results"
        }
      },
      {
        "type": "DataTable",
        "columns": [
          {
            "key": "name",
            "header": "Name",
            "sortable": true
          },
          {
            "key": "email",
            "header": "Email",
            "sortable": false
          }
        ],
        "rows": "{{ results }}",
        "searchable": true,
        "paginated": false,
        "pageSize": 10
      }
    ]
  }
}
```
</CodeGroup>
</ComponentPreview>

The user types a query, clicks Search, and the `find_users` tool runs server-side. Its return value lands in `results`, and the DataTable renders the rows.

## Search with ForEach

The same pattern works with `ForEach` for custom result layouts. Each item in the returned list becomes the interpolation context for its iteration.

<ComponentPreview auto json={`{"view":{"cssClass":"gap-3","type":"Column","children":[{"type":"Input","inputType":"text","placeholder":"Search products...","name":"q","disabled":false,"required":false},{"type":"Button","label":"Search","variant":"default","size":"default","disabled":false,"onClick":{"action":"toolCall","tool":"search_products","arguments":{"query":"{{ q }}"},"resultKey":"products"}},{"type":"ForEach","key":"products","children":[{"type":"Card","children":[{"type":"CardHeader","children":[{"type":"CardTitle","content":"{{ name }}"},{"type":"CardDescription","content":"{{ description }}"}]}]}]}]}}`}>
<CodeGroup>
```python Python icon="python"
from prefab_ui.components import (
    Button,
    Card,
    CardDescription,
    CardHeader,
    CardTitle,
    Column,
    ForEach,
    Input,
)
from prefab_ui.actions import ToolCall

with Column(gap=3):
    Input(name="q", placeholder="Search products...")
    Button("Search", on_click=ToolCall(
        "search_products",
        arguments={"query": "{{ q }}"},
        result_key="products",
    ))
    with ForEach("products"):
        with Card():
            with CardHeader():
                CardTitle("{{ name }}")
                CardDescription("{{ description }}")
```
```json Protocol icon="brackets-curly"
{
  "view": {
    "cssClass": "gap-3",
    "type": "Column",
    "children": [
      {
        "type": "Input",
        "inputType": "text",
        "placeholder": "Search products...",
        "name": "q",
        "disabled": false,
        "required": false
      },
      {
        "type": "Button",
        "label": "Search",
        "variant": "default",
        "size": "default",
        "disabled": false,
        "onClick": {
          "action": "toolCall",
          "tool": "search_products",
          "arguments": {
            "query": "{{ q }}"
          },
          "resultKey": "products"
        }
      },
      {
        "type": "ForEach",
        "key": "products",
        "children": [
          {
            "type": "Card",
            "children": [
              {
                "type": "CardHeader",
                "children": [
                  {
                    "type": "CardTitle",
                    "content": "{{ name }}"
                  },
                  {
                    "type": "CardDescription",
                    "content": "{{ description }}"
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  }
}
```
</CodeGroup>
</ComponentPreview>

When `search_products` returns a list of dicts with `name` and `description` keys, `ForEach` renders one card per result.

## Action Chains

Pass a list of actions to compose richer interactions. Actions execute in sequence, so you can update UI state before and after a server call.

<ComponentPreview auto json={`{"view":{"type":"Button","label":"Process","variant":"default","size":"default","disabled":false,"onClick":[{"action":"setState","key":"processing","value":true},{"onSuccess":{"action":"showToast","message":"Analysis complete!","variant":"success"},"onError":{"action":"showToast","message":"{{ $error }}","variant":"error"},"action":"toolCall","tool":"run_analysis","arguments":{"data":"{{ dataset }}"}},{"action":"setState","key":"processing","value":false}]}}`}>
<CodeGroup>
```python Python icon="python"
from prefab_ui.components import Button
from prefab_ui.actions import ToolCall, SetState, ShowToast

Button("Process", on_click=[
    SetState("processing", True),
    ToolCall(
        "run_analysis",
        arguments={"data": "{{ dataset }}"},
        on_success=ShowToast("Analysis complete!", variant="success"),
        on_error=ShowToast("{{ $error }}", variant="error"),
    ),
    SetState("processing", False),
])
```
```json Protocol icon="brackets-curly"
{
  "view": {
    "type": "Button",
    "label": "Process",
    "variant": "default",
    "size": "default",
    "disabled": false,
    "onClick": [
      {
        "action": "setState",
        "key": "processing",
        "value": true
      },
      {
        "onSuccess": {
          "action": "showToast",
          "message": "Analysis complete!",
          "variant": "success"
        },
        "onError": {
          "action": "showToast",
          "message": "{{ $error }}",
          "variant": "error"
        },
        "action": "toolCall",
        "tool": "run_analysis",
        "arguments": {
          "data": "{{ dataset }}"
        }
      },
      {
        "action": "setState",
        "key": "processing",
        "value": false
      }
    ]
  }
}
```
</CodeGroup>
</ComponentPreview>

`SetState("processing", True)` fires instantly, then `ToolCall` makes the server request. If the tool succeeds, `on_success` fires and the chain continues to `SetState("processing", False)`. If the tool fails, `on_error` fires and the chain stops — `processing` stays `True` so you can reflect the error state in the UI.

## Error Handling

When a `ToolCall` action fails, the error message is available as `$error` inside `on_error` callbacks. This lets you surface server-side validation messages or exceptions directly to the user.

<ComponentPreview auto json={`{"view":{"type":"Button","label":"Delete","variant":"destructive","size":"default","disabled":false,"onClick":{"onError":{"action":"showToast","message":"{{ $error }}","variant":"error"},"action":"toolCall","tool":"delete_item","arguments":{"id":"{{ item_id }}"}}}}`}>
<CodeGroup>
```python Python icon="python"
from prefab_ui.components import Button
from prefab_ui.actions import ToolCall, ShowToast

Button("Delete", variant="destructive", on_click=ToolCall(
    "delete_item",
    arguments={"id": "{{ item_id }}"},
    on_error=ShowToast("{{ $error }}", variant="error"),
))
```
```json Protocol icon="brackets-curly"
{
  "view": {
    "type": "Button",
    "label": "Delete",
    "variant": "destructive",
    "size": "default",
    "disabled": false,
    "onClick": {
      "onError": {
        "action": "showToast",
        "message": "{{ $error }}",
        "variant": "error"
      },
      "action": "toolCall",
      "tool": "delete_item",
      "arguments": {
        "id": "{{ item_id }}"
      }
    }
  }
}
```
</CodeGroup>
</ComponentPreview>

If `delete_item` raises an exception or returns an error, the message appears in a toast notification. The `$error` variable is scoped to the `on_error` callback and does not leak into broader state.
